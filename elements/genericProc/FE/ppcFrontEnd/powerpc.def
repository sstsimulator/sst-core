/* This doesn't look like -*- C -*-, but it is!
 * vim:ft=c
 *
 * powerpc.def - PowerPC machine definition
 * * This file is a part of the SimpleScalar tool suite written by
 * Todd M. Austin as a part of the Multiscalar Research Project.
 *  
 * The tool suite is currently maintained by Doug Burger and 
 * Todd M. Austin.
 * 
 * Copyright (C) 1994, 1995, 1996, 1997, 1998 by Todd M. Austin
 *
 * This source file is distributed "as is" in the hope that it will be
 * useful.  The tool set comes with no warranty, and no author or
 * distributor accepts any responsibility for the consequences of its
 * use. 
 * 
 * Everyone is granted permission to copy, modify and redistribute
 * this tool set under the following conditions:
 * 
 *    This source code is distributed for non-commercial use only. 
 *    Please contact the maintainer for restrictions applying to 
 *    commercial use.
 *
 *    Permission is granted to anyone to make or distribute copies
 *    of this source code, either as received or modified, in any
 *    medium, provided that all copyright notices, permission and
 *    nonwarranty notices are preserved, and that the distributor
 *    grants the recipient permission for further redistribution as
 *    permitted by this document.
 *
 *    Permission is granted to distribute this file in compiled
 *    or executable form under the same conditions that apply for
 *    source code, provided that either:
 *
 *    A. it is accompanied by the corresponding machine-readable
 *       source code,
 *    B. it is accompanied by a written offer, with no time limit,
 *       to give anyone a machine-readable copy of the corresponding
 *       source code in return for reimbursement of the cost of
 *       distribution.  This written offer must permit verbatim
 *       duplication by anyone, or
 *    C. it is distributed by someone who received only the
 *       executable form, and is accompanied by a copy of the
 *       written offer of source code that they received concurrently.
 *
 * In other words, you are welcome to use, share and improve this
 * source file.  You are forbidden to forbid anyone else to use, share
 * and improve what you give them.
 *
 * INTERNET: dburger@cs.wisc.edu
 * US Mail:  1210 W. Dayton Street, Madison, WI 53706
 *
 *
 *
 */

/* This file defines all aspects of the SimpleScalar instruction set
 * architecture.  Each instruction set in the architecture has a DEFINST()
 * macro call included below.  The contents of a instruction definition are
 * as follows:
 *
 *   DEFINST(<enum>,			<opcode>,
 *	     <opname>,			<operands>,
 *	     <fu_req>,			<iflags>,
 *	     <output deps...>,		<input deps...>,
 *	     <expr>)
 *
 * Where:
 *
 *   <enum>	- is an enumerator that is returned when an instruction is
 *		  decoded by SS_OP_ENUM()
 *   <opcode>	- is the opcode of this instruction
 *   <opname>   - name of this instruction as a string, used by
 *                disassembler
 *   <operands>	- specified the instruction operand fields and their
 *                printed order for disassembly, used by disassembler, the
 *                recognized operand field are (the instruction format is
 *                detailed in the header file ss.h):
 *		    J - target field
 *		    j - PC relative target (offset + PC)
 *		    s - S register field
 *		    b - S register field (base register)
 *		    t - T register field
 *		    d - D register field
 *		    S - S register field (FP register)
 *		    T - T register field (FP register)
 *		    D - D register field (FP register)
 *		    o - load address offset (offset)
 *		    i - signed immediate field value
 *		    u - unsigned immediate field value
 *		    U - upper immediate field value
 *		    H - shift amount immediate field value
 *		    B - break code
 *
 *   <fu_req>	- functional unit requirements for this instruction
 *   <iflags>	- instruction flags, accessible via the SS_OP_FLAGS()
 *		  macro, flags are defined with F_* prefix in ss.h
 *   <output deps...>
 *		- a list of up to two output dependency designators, the
 *		  following designators are recognized (place an DNA in any
 *		  unused fields:
 *		    DGPR(N)   - general purpose register N
 *		    DGPR_D(N) - double word general purpose register N
 *		    DCGPR(N)  - general purpose register conditional on
 *			        pre/post- increment/decrement mode
 *		    DFPR_L(N) - floating-point register N, as word
 *		    DFPR_F(N) - floating-point reg N, as single-prec float
 *		    DFPR_D(N) - floating-point reg N, as double-prec double
 *		    DHI	      - HI result register
 *		    DLO	      - LO result register
 *		    DFCC      - floating point condition codes
 * 		    DCPC      - current PC
 *		    DNPC      - next PC
 *		    DNA	      - no dependence
 *
 *   <input deps...>
 *		- a list of up to three input dependency designators, the
 *		  designators are defined above (place an DNA in any unused
 *		  fields.
 *
 *   <expr>	- a C expression that implements the instruction being
 * 		  defined, the expression must modify all architected state
 *		  affected by the instruction's execution, by default, the
 *		  next PC (NPC) value defaults to the current PC (CPC) plus
 *		  SS_INST_SIZE, as a result, only taken branches need to
 *		  set NPC
 *
 *		  The following predefined macros are available for use in
 *		  DEFINST() instruction expressions to access the value of
 *		  instruction operand/opcode field values:
 *
 *		    RS	    - RS register field value
 *		    RT	    - RT register field value
 *		    RD	    - RD register field value
 *		    FS	    - RS register field value
 *		    FT	    - RT register field value
 *		    FD	    - RD register field value
 *		    BS	    - RS register field value
 *		    TARG    - jump target field value
 *		    OFS	    - signed offset field value
 *		    IMM	    - signed offset field value
 *		    UIMM    - unsigned offset field value
 *		    SHAMT   - shift amount field value
 *		    BCODE   - break code field value
 *
 *		  To facilitate the construction of performance simulators
 *		  (which may want to specialize their architected state
 *		  storage format), all architected register and memory
 *		  state is accessed through the following macros:
 *
 *		    GPR(N)         - read general purpose register N
 *		    SET_GPR(N,E)   - write general purpose register N with E
 *		    GPR_D(N)       - read double word general purpose reg N
 *		    SET_GPR_D(N,E) - write double word gen purpose reg N w/ E
 *		    FPR_L(N)       - read floating-point register N, as word
 *		    SET_FPR_L(N,E) - floating-point reg N, as word, with E
 *		    FPR_F(N)       - read FP reg N, as single-prec float
 *		    SET_FPR_F(N,E) - write FP reg N, as single-prec float w/ E
 *		    FPR_D(N)       - read FP reg N, as double-prec double
 *		    SET_FPR_D(N,E) - write FP reg N, as double-prec double w/E
 *		    HI	           - read HI result register
 *		    SET_HI(E)      - write HI result register with E
 *		    LO	           - read LO result register
 *		    SET_LO(E)      - write LO result register with E
 *		    FCC	           - read floating point condition codes
 *		    SET_FCC(E)     - write floating point condition codes w/ E
 *		    CPC	           - read current PC register
 *		    NPC	           - read next PC register
 *		    SET_NPC(E)     - write next PC register with E
 *		    TPC	           - read target PC register
 *		    SET_TPC(E)     - write target PC register with E
 *
 *		    READ_SIGNED_BYTE(A)   - read signed byte from address A
 *		    READ_UNSIGNED_BYTE(A) - read unsigned byte from address A
 *		    READ_SIGNED_HALF(A)   - read signed half from address A
 *		    READ_UNSIGNED_HALF(A) - read unsigned half from address A
 *		    READ_WORD(A)          - read word from address A
 *		    WRITE_BYTE(E,A)       - write byte value E to address A
 *		    WRITE_HALF(E,A)       - write half value E to address A
 *		    WRITE_WORD(E,A)       - write word value E to address A
 *
 *		  Finally, the following helper functions are available to
 *		  assist in the construction of instruction expressions:
 *
 *		    INC_DEC(E,N,S) - execute E and update N as per pre/post-
 *				     incr/decr addressing sementics for an
 *				     access of S bytes
 *		    OVER(X,Y)      - check for overflow for X+Y, both signed
 *		    UNDER(X,Y)	   - check for umderflow for X-Y, both signed
 *		    DIV0(N)	   - check for divide by zero, N is denom
 *		    INTALIGN(N)    - check double word int reg N alignment
 *		    FPALIGN(N)	   - check double word FP reg N alignment
 *		    TALIGN(T)	   - check jump target T alignment
 *                  *note          - These macros might only apply to ints.
 */

/*Warning: The instructions here are inly the user level instruction supported by
PowerPC. Cache management and system managment user level isntructions have to be
implemented*/

#ifndef __ppc__
#define asm(...) ;
#endif

/*
 * OPCODEBUG()
 */
#define OPCODEBUG(_OPCODE) (({printf("DBUG: OPCODE=%s\n",_OPCODE);}))

/*
 * PCDEBUG()
 */
#define PCDEBUG() (({printf("DBUG: PC=%x\n",ProgramCounter)}))

/*
 *System Linkage instructions
 */

#define SC_IMPL                                                       \
{				                                      \
    SYSCALL;		                                              \
}


DEFINST(SC,                	0x11,
        "sc",              	"",
        FUClass_NA,             F_TRAP,
        DNA, DNA,               DNA, DNA, DNA,
	DNA, DNA,DNA,		DNA, DNA)


#define TWI_IMPL					    \
{                                                           \
    sword_t _sa, _sb;                                       \
    word_t _a, _b;                                          \
    _sa = GPR(RA);                                          \
    _sb = IMM;                                              \
    _a = (word_t)GPR(RA);                                   \
    _b = UIMM;                                   	    \
    if( (_sa < _sb) && (TO & 0x10) )                        \
    {                                                       \
	PPC_TRAP;					    \
    }                                                       \
    else if( (_sa > _sb) && (TO & 0x8) )                    \
    {                                                       \
	PPC_TRAP;					    \
    }                                                       \
    else if( (_sa == _sb) && (TO & 0x4) )                   \
    {							    \
	PPC_TRAP;					    \
    }                                                       \
    else  if( (_a < _b) && (TO & 0x2) )                     \
    {                                                       \
	PPC_TRAP;					    \
    }                                                       \
    else if( (_a > _b) && (TO & 0x1) )                      \
    {                                                       \
	PPC_TRAP;					    \
    }                                                       \
}

DEFINST(TWI,                    0x3,
        "twi",                  "t,a,b",
        IntALU,                 F_IMM,
        DNA,DNA,                PPC_DGPR(RA),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,         	DNA, DNA)


#define MULLI_IMPL                                    \
{                                                     \
    sword_t  _sh;                                     \
    sword_t  _sw;                                     \
    sqword_t _src;                                    \
    _sw  = GPR(RA);                                   \
    _sh  = SEXT16(IMM);                               \
    _src = _sw*_sh;                                   \
    SET_GPR(RD, (sword_t)(_src&0x00000000ffffffff));  \
}

DEFINST(MULLI,                  0x07,
        "mulli",                "d,a,i",
        IntMULT,                F_ICOMP|F_IMM|F_LONGLAT,
        PPC_DGPR(RD), DNA,      PPC_DGPR(RA), DNA, DNA,
        DNA, DNA, DNA,          DNA, DNA)


#define SUBFIC_IMPL                                   \
{                                                     \
    word_t ra;                                        \
    ra = GPR(RA);                                     \
    SET_GPR(RD,  SEXT16(IMM) - GPR(RA));              \
    if (ra == 0)                                      \
	PPC_SET_XER_CA;                               \
    else {                                            \
	if( carrygenerated(-ra,SEXT16(IMM)) ) {       \
	    PPC_SET_XER_CA;                           \
	}                                             \
	else {                                        \
	    PPC_RESET_XER_CA;                         \
	}                                             \
    }                                                 \
}

DEFINST(SUBFIC,                 	0x08,
        "subfic",               	"d,a,i",  
        IntALU,                 	F_ICOMP|F_IMM,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, DNA,
        DNA,DNA,DNA,            	DNA,DNA)


#define ADDIC_IMPL				\
{						\
    word_t ra;					\
    ra = GPR(RA);				\
    SET_GPR(RD, GPR(RA) + SEXT16(IMM) );	\
    if(carrygenerated(ra, SEXT16(IMM) ) ) {     \
    	PPC_SET_XER_CA;                         \
    }                                           \
    else{ PPC_RESET_XER_CA; }                   \
  }


DEFINST(ADDIC,                  	0x0C,
        "addic",                	"d,a,i",
        IntALU,                 	F_ICOMP|F_IMM,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, DNA,
        DNA,DNA,DNA,            	DNA,DNA)


#define CMPLI_IMPL                                              \
{                                                               \
    word_t _a, _b;                                              \
    word_t _c;                                                  \
    word_t _mask;                                               \
    if(ISSETL) {                                                \
	DECLARE_FAULT(md_fault_invalidinstruction);             \
    }                                                           \
    else {							\
	_a = GPR(RA);                                           \
	_b = UIMM;                                              \
	if(_a<_b) _c=0x8;                                       \
	else {                                                  \
	    if (_a>_b) _c=0x4;                                  \
	    else       _c=0x2;                                  \
	}                                                       \
	_c = _c | (PPC_GET_XER_SO);                             \
	_c = _c << 4 * (7 - CRFD);		                \
	_mask = ~( 0xf << 4 * (7 - CRFD));		        \
	PPC_SET_CR ( ( CR & _mask ) | _c);		        \
    } 	                                                        \
}
                

DEFINST(CMPLI,                  0xA,
        "cmpli",                "r,l,a,i",
        IntALU,                 F_ICOMP|F_IMM,
        PPC_DCR, DNA,           PPC_DGPR(RA), PPC_DGPR(RB), PPC_DCR,
        DNA, DNA, DNA,        	PPC_DXER, DNA)


#define CMPI_IMPL                                                   \
   {                                                                \
        sword_t _a, _b;                                             \
        word_t _c, _d;                                              \
        word_t _mask;                                               \
        /*OPCODEBUG("cmpi");*/ \
  	if(ISSETL) {                                                \
	  DECLARE_FAULT(md_fault_invalidinstruction);		    \
        }                                                           \
        else{                                                       \
	  _a = GPR(RA);						    \
	  _b = IMM;						    \
	  if(_a<_b) _c=0x8;					    \
	  else{					 		    \
	    if (_a>_b) _c=0x4;					    \
	    else      _c=0x2;					    \
	  }							    \
	  _c = _c | (PPC_GET_XER_SO);				    \
	  _c = _c << ( (7-CRFD)*4 );				    \
	  if(CRFD==0){						    \
	    _mask = 0xf << 28 ;					    \
	    PPC_SET_CR( (CR & (~(_mask))) | _c );		    \
	  }							    \
	  else{							    \
	    _d = _c <<28;					    \
	    _mask = (0xf << ( (7-CRFD)*4 )) | 0xf0000000;	    \
	    _mask = (0xf << ( (7-CRFD)*4 )) ;		 	    \
            /* dont know why prev line ored with 0xf000000,         \
	       removed it. hope this works */                       \
	    PPC_SET_CR((CR & (~(_mask))) | _c );		    \
	  }							    \
	}							    \
   }
    

DEFINST(CMPI,                   0xB,
        "cmpi",                 "r,l,a,i",
        IntALU,                 F_ICOMP|F_IMM,
        PPC_DCR, DNA,           PPC_DGPR(RA), PPC_DCR, PPC_DXER,
        DNA, DNA, DNA,        	DNA, DNA)


#define ADDICD_IMPL                             \
  {                                             \
    sword_t _src;				\
    _src= GPR(RA) + SEXT16(IMM);                \
    if(carrygenerated(GPR(RA), SEXT16(IMM) )){  \
        PPC_SET_XER_CA;                         \
    }                                           \
    else{ PPC_RESET_XER_CA;}                    \
    if(!(_src)) PPC_SET_CR0_EQ;                 \
    else PPC_RESET_CR0_EQ;                      \
    if(_src>0) PPC_SET_CR0_GT;                  \
    else PPC_RESET_CR0_GT;                      \
    if(_src<0) PPC_SET_CR0_LT;                  \
    else PPC_RESET_CR0_LT;                      \
    if(PPC_GET_XER_SO) PPC_SET_CR0_SO;          \
    else PPC_RESET_CR0_SO;                      \
    SET_GPR(RD, _src);                          \
  }
        
DEFINST(ADDICD,                 	0x0D,
        "addic.",               	"d,a,i",
        IntALU,                 	F_ICOMP|F_IMM,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, PPC_DCR,
        PPC_DCR,DNA,DNA,            	DNA,DNA)


#define ADDI_IMPL			 	              \
{						              \
    if(RA==0) {                                               \
        SET_GPR(RD, SEXT16(IMM) );	                      \
    }                                                         \
    else {                                                    \
        SET_GPR(RD, GPR(RA) + SEXT16(IMM) );                  \
    }                                                         \
}

DEFINST(ADDI,			0x0E,
	"addi",			"d,a,i",
	IntALU,			F_ICOMP|F_IMM,
	PPC_DGPR(RD), DNA, 	PPC_DGPR(RA), DNA, DNA,
	DNA,DNA,DNA,		DNA,DNA)




#define ADDIS_IMPL						\
  {								\
  if(RA==0) SET_GPR(RD, (IMM << 16));				\
  else      SET_GPR(RD, GPR(RA) + (IMM<<16));			\
  }

DEFINST(ADDIS,			0x0F,
        "addis",		"d,a,i",
        IntALU,			F_ICOMP|F_IMM,
        PPC_DGPR(RD),DNA,	PPC_DGPR(RA),DNA,DNA,
	DNA,DNA,DNA,		DNA,DNA)



#define ORI_IMPL						\
   {								\
	SET_GPR(RA, (GPR(RS)|UIMM));				\
   }  

DEFINST(ORI,			0x18,
        "ori",			"a,s,u",
        IntALU,			F_ICOMP|F_IMM,
        PPC_DGPR(RA),DNA,	PPC_DGPR(RS),DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)



#define ORIS_IMPL						\
   {								\
     SET_GPR(RA, (GPR(RS)|(UIMM << 16)));			\
   }  

DEFINST(ORIS,			0x19,
        "oris",			"a,s,u",
        IntALU,			F_ICOMP|F_IMM,
        PPC_DGPR(RA),DNA,	PPC_DGPR(RS),DNA,DNA,
	DNA, DNA,DNA,        	DNA, DNA)



#define XORI_IMPL		                        \
   {                                                    \
     SET_GPR(RA, (GPR(RS)^(UIMM)));                     \
   }

DEFINST(XORI,                   0x1A,
        "xori",                 "a,s,u",
        IntALU,                 F_ICOMP|F_IMM,
        PPC_DGPR(RA),DNA,       PPC_DGPR(RS),DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)


#define XORIS_IMPL                                     \
   {                                                   \
     SET_GPR(RA, (GPR(RS)^((UIMM) << 16)));            \
   }

DEFINST(XORIS,                  0x1B,
        "xoris",                "a,s,u",
        IntALU,                 F_ICOMP|F_IMM,
        PPC_DGPR(RA),DNA,       PPC_DGPR(RS),DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)

#define ANDID_IMPL                                     \
   {                                                   \
        word_t _src;                                   \
        _src = GPR(RS)& UIMM;	                       \
	SET_GPR(RA, _src);                             \
	if(!(_src)) PPC_SET_CR0_EQ;                    \
	else PPC_RESET_CR0_EQ;                         \
        if(_src>0) PPC_SET_CR0_GT;                     \
        else PPC_RESET_CR0_GT;                         \
        if(_src<0) PPC_SET_CR0_LT;                     \
        else PPC_RESET_CR0_LT;                         \
	if(PPC_GET_XER_SO) PPC_SET_CR0_SO;             \
	else PPC_RESET_CR0_SO;                         \
   }

DEFINST(ANDID,			0x1C,
	"andi.",	       	"a,s,u",
	IntALU,			F_ICOMP|F_IMM,
	PPC_DGPR(RA),DNA,	PPC_DGPR(RS),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,        	DNA, DNA)
		

#define ANDISD_IMPL                         \
{	                                    \
    word_t _src;                            \
    _src = GPR(RS)& (UIMM<<16);	            \
    SET_GPR(RA, _src);		            \
    if(!(_src)) PPC_SET_CR0_EQ;	            \
    else PPC_RESET_CR0_EQ;		    \
    if(_src>0) PPC_SET_CR0_GT;              \
    else PPC_RESET_CR0_GT;                  \
    if(_src<0) PPC_SET_CR0_LT;              \
    else PPC_RESET_CR0_LT;                  \
    if(PPC_GET_XER_SO) PPC_SET_CR0_SO;	    \
    else PPC_RESET_CR0_SO;                  \
}

DEFINST(ANDISD,			0x1D,
	"andis.",	       	"a,s,u",
	IntALU,			F_ICOMP|F_IMM,
	PPC_DGPR(RA),DNA,	PPC_DGPR(RS),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,        	DNA, DNA)

		
#define LWZ_IMPL                                               \
{                                                              \
    word_t _result;                                            \
    enum md_fault_type _fault;                                 \
    if(RA==0) {                                                \
      _result = READ_WORD(OFS, _fault);		       \
    } else {                                                   \
        _result = READ_WORD(GPR(RA)+SEXT16(OFS), _fault);      \
    }        					               \
    /*printf("wcm: lwz::_result==%p (RA=%d) _fault=%u\n",_result,RA,_fault);*/ \
    /*printf("wcm:      GPR(RA)=%p  SEXT16(OFS)=%p\n",GPR(RA),SEXT16(OFS));*/ \
    if (_fault != md_fault_none) {                             \
        DECLARE_FAULT(_fault);                                 \
    }                                                          \
    SET_GPR(RD, _result);		                       \
}


DEFINST(LWZ,                    0x20,
        "lwz",                  "d,o(a)",
        RdPort,                 F_MEM|F_LOAD|F_DISP,
	PPC_DGPR(RD),DNA,       DNA, PPC_DGPR(RA),DNA,
        DNA, DNA, DNA,        	DNA, DNA)




#define LWZU_IMPL                                               \
   {                                                            \
    word_t _result;                                             \
    enum md_fault_type _fault;                                  \
    if(RA==0||(RA==RD))                                         \
        {                                                       \
           DECLARE_FAULT(md_fault_invalidinstruction);          \
        }                                                       \
    else{                                                       \
           _result = READ_WORD(GPR(RA)+SEXT16(OFS), _fault);    \
           if (_fault != md_fault_none)                         \
       		   DECLARE_FAULT(_fault);                       \
           SET_GPR(RD, _result);                                \
	   SET_GPR(RA, GPR(RA)+SEXT16(OFS));			\
        }                                                       \
   }
        

DEFINST(LWZU,                   	0x21,
        "lwzu",                 	"d,o(a)",
        RdPort,                 	F_MEM|F_LOAD|F_DISP,
        PPC_DGPR(RD), DNA,      DNA, PPC_DGPR(RA),DNA,
        PPC_DGPR(RA), DNA, DNA,        		DNA, DNA)
   
#define LBZ_IMPL						        \
   {									\
     byte_t _result;							\
     enum md_fault_type _fault;						\
									\
     if(RA==0){								\
		_result = READ_BYTE(SEXT16(OFS),_fault);		\
	}								\
     else{								\
		 _result = READ_BYTE(GPR(RA) + SEXT16(OFS), _fault);	\
	}								\
	if (_fault != md_fault_none)                            	\
               	DECLARE_FAULT(_fault);                          	\
        SET_GPR(RD, (word_t)_result);                           	\
   }

DEFINST(LBZ,			0x22,
	"lbz",			"d,o(a)",		                  
	RdPort,			F_MEM|F_LOAD|F_DISP,
	PPC_DGPR(RD),DNA,	DNA, PPC_DGPR(RA), DNA,
        DNA, DNA, DNA,        	DNA, DNA)




#define LBZU_IMPL                                                       \
   {                                                                    \
     byte_t _result;                                                    \
     enum md_fault_type _fault;                                         \
                                                                        \
     if((RA==0)||(RA==RD)){                                             \
                DECLARE_FAULT(md_fault_invalidinstruction);		\
        }                                                               \
     else{                                                              \
                _result = READ_BYTE(GPR(RA) + SEXT16(OFS), _fault);    	\
                if (_fault != md_fault_none)                            \
                DECLARE_FAULT(_fault);                                  \
                SET_GPR(RD, (word_t)_result);                           \
		SET_GPR(RA, GPR(RA) + SEXT16(OFS));			\
        }                                                               \
   }
                        
DEFINST(LBZU,                   	0x23,
        "lbzu",                  	"d, o(a)",
        RdPort,                 	F_MEM|F_LOAD|F_DISP,
        PPC_DGPR(RD), DNA,      DNA, PPC_DGPR(RA), DNA,
        PPC_DGPR(RA), DNA, DNA,        		DNA, DNA)




#define STW_IMPL                                                       \
{                                                                      \
    word_t _src;                                                       \
    enum md_fault_type _fault;                                         \
                                                                       \
    _src = (word_t)GPR(RS);                                            \
    if(RA==0) {                                                        \
        WRITE_WORD(_src,  OFS, _fault);                                \
    }                                                                  \
    else {                                                             \
        WRITE_WORD(_src, GPR(RA) + SEXT16(OFS), _fault);               \
    }                                                                  \
    if (_fault != md_fault_none) {                                     \
        DECLARE_FAULT(_fault);                                         \
    }                                                                  \
}
                
DEFINST(STW,               0x24,
        "stw",             "s,o(a)",
        WrPort,            F_MEM|F_STORE|F_DISP,
        DNA,DNA,           PPC_DGPR(RS),PPC_DGPR(RA),DNA,
        DNA, DNA, DNA,     DNA, DNA)


#define STWU_IMPL                                                   \
{                                                                   \
    word_t _rS;                                                     \
    enum md_fault_type _fault;                                      \
    uint32 _ea = GPR(RA)+SEXT16(OFS);   /* wcm: unsigned long */    \
    if(RA==0){                                                      \
        DECLARE_FAULT(md_fault_invalidinstruction);                 \
    }                                                               \
    else {                                                          \
        _rS = (word_t)GPR(RS);                            	    \
        WRITE_WORD(_rS, _ea, _fault);                               \
        if (_fault != md_fault_none)                                \
            DECLARE_FAULT(_fault);                                  \
        SET_GPR(RA, _ea);                                           \
    }                                                               \
}
        
DEFINST(STWU,                   0x25,
        "stwu",                 "s,o(a)",
        WrPort,                 F_MEM|F_STORE|F_DISP,
        DNA,DNA,       PPC_DGPR(RS),PPC_DGPR(RA),DNA,
        PPC_DGPR(RA), DNA, DNA,           DNA, DNA)


#define STB_IMPL						\
   {								\
	byte_t	_src;						\
	enum md_fault_type _fault;                              \
	_src=(byte_t)(word_t)GPR(RS);				\
        if(RA==0){                                              \
                 WRITE_BYTE(_src, OFS, _fault);      		\
        }		                                        \
        else{                                                   \
             WRITE_BYTE( _src, GPR(RA)+SEXT16(OFS), _fault);  	\
        }                                                       \
	if (_fault != md_fault_none)		                \
                DECLARE_FAULT(_fault);                          \
   }

DEFINST(STB,			0x26,
	"stb",			"s,o(a)",
	WrPort,			F_MEM|F_STORE|F_DISP,
	DNA,DNA,		PPC_DGPR(RS),PPC_DGPR(RA),DNA,
        DNA, DNA, DNA,        	DNA, DNA)



#define STBU_IMPL                                                   \
   {                                                                \
        byte_t  _src;                                               \
        enum md_fault_type _fault;                                  \
        if(RA==0){                                                  \
	 	 DECLARE_FAULT(md_fault_invalidinstruction);        \
        }						            \
        else{                                                       \
             _src=(byte_t)(word_t)GPR(RS);                          \
             WRITE_BYTE( _src, GPR(RA)+OFS, _fault);                \
             if (_fault != md_fault_none)                           \
                DECLARE_FAULT(_fault);                              \
	     SET_GPR(RA, GPR(RA)+OFS);				    \
        }                                                           \
   }
   
DEFINST(STBU,                   0x27,
        "stbu",                 "s, o(a)",
        WrPort,                 F_MEM|F_STORE|F_DISP,
        DNA, DNA,       PPC_DGPR(RS),PPC_DGPR(RA),DNA,
        PPC_DGPR(RA), DNA, DNA,        	DNA, DNA)

     

#define LHZ_IMPL                                                        \
   {                                                                    \
    half_t _result;                                                     \
    enum md_fault_type _fault;                                          \
    if(RA==0)                                                           \
        {                                                               \
           _result = READ_HALF(OFS, _fault);                            \
        }                                                               \
    else                                                                \
        {                                                               \
	   _result = READ_HALF(GPR(RA)+OFS, _fault);                    \
        }                                                               \
	if (_fault != md_fault_none)                                	\
		DECLARE_FAULT(_fault);                                  \
        SET_GPR(RD, (word_t)_result);                                	\
   }
    

DEFINST(LHZ,                    0x28,
        "lhz",                  "d,o(a)",
        RdPort,                 F_MEM|F_LOAD|F_DISP,
        PPC_DGPR(RD),DNA,       DNA, PPC_DGPR(RA),DNA,
        DNA, DNA, DNA,        	DNA, DNA)




#define LHZU_IMPL                                                       \
   {                                                                    \
    half_t _result;                                                     \
    enum md_fault_type _fault;                                          \
    if(RA==0||(RA==RD))                                                 \
        {                                                               \
	   DECLARE_FAULT(md_fault_invalidinstruction);             	\
        }								\
    else                                                                \
        {                                                               \
           _result = READ_HALF(GPR(RA)+OFS, _fault);                    \
           if (_fault != md_fault_none)                                 \
                DECLARE_FAULT(_fault);                                  \
           SET_GPR(RD, (word_t)_result);                                \
	   SET_GPR(RA, GPR(RA)+OFS);					\
        }                                                               \
   }
    

DEFINST(LHZU,                   	0x29,
        "lhzu",                 	"d, o(a)",
        RdPort,              	   	F_MEM|F_LOAD|F_DISP,
        PPC_DGPR(RD), DNA,      DNA, PPC_DGPR(RA), DNA,
        PPC_DGPR(RA), DNA, DNA,        		DNA, DNA)


#define LHA_IMPL                                                        \
   {                                                                    \
    shalf_t _result;                                                    \
    enum md_fault_type _fault;                                          \
    if(RA==0)								\
	{								\
 	   _result = READ_HALF(OFS, _fault);		                \
  	}								\
    else								\
	{								\
	_result = READ_HALF(GPR(RA)+OFS, _fault);			\
	}								\
    if (_fault != md_fault_none)                                	\
                DECLARE_FAULT(_fault);                                  \
        SET_GPR(RD, (word_t)(sword_t)_result);                       	\
   }
    
    
DEFINST(LHA,                    0x2A,
        "lha",                  "d,o(a)",
        RdPort,                 F_MEM|F_LOAD|F_DISP,
        PPC_DGPR(RD),DNA,       DNA, PPC_DGPR(RA), DNA,
        DNA, DNA, DNA,        	DNA, DNA)




#define LHAU_IMPL                                                       \
   {                                                                    \
    shalf_t _result;                                                    \
    enum md_fault_type _fault;                                          \
    if((RA==0)||(RA==RD)){                                              \
                DECLARE_FAULT(md_fault_invalidinstruction);             \
        }                                                               \
    else{                                                               \
        _result = READ_HALF(GPR(RA)+OFS, _fault);                   	\
            if (_fault != md_fault_none)                                \
                DECLARE_FAULT(_fault);                                  \
           SET_GPR(RD, (word_t)(sword_t)_result);                      	\
	   SET_GPR(RA, GPR(RA) + OFS);                             	\
        }                                                               \
   }
    

DEFINST(LHAU,                   	0x2B,
        "lhau",                 	"d,o(a)",
        RdPort,                 	F_MEM|F_LOAD|F_DISP,  
        PPC_DGPR(RD), DNA,      DNA, PPC_DGPR(RA), DNA,
        PPC_DGPR(RA), DNA, DNA,        		DNA, DNA)


#define STHU_IMPL							\
   {									\
    half_t _src;                                                        \
    enum md_fault_type _fault;                                          \
                                                                        \
    if(RA==0){								\
		 DECLARE_FAULT(md_fault_invalidinstruction);            \
	}                                               		\
    else{								\
	    _src = (half_t)(word_t)GPR(RS);                             \
	    WRITE_HALF(_src, GPR(RA) + OFS, _fault);            	\
	    if (_fault != md_fault_none)                                \
      		DECLARE_FAULT(_fault);                                  \
	     SET_GPR(RA, GPR(RA)+OFS);					\
	} 								\
   }

DEFINST(STHU,			0x2D,
	"sthu",			"s,o(a)",
	WrPort,			F_MEM|F_STORE|F_DISP, 	
	DNA,DNA,	PPC_DGPR(RS),PPC_DGPR(RA),DNA,
        PPC_DGPR(RA), DNA, DNA,        	DNA, DNA)

	


#define STH_IMPL                                                        \
   {                                                                    \
    half_t _src;                                                        \
    enum md_fault_type _fault;                                          \
                                                                        \
    _src = (half_t)(word_t)GPR(RS);                                     \
    if(RA==0){                                                          \
                WRITE_HALF(_src,  OFS, _fault);                         \
        }                                                               \
    else{                                                               \
                WRITE_HALF(_src, GPR(RA) + OFS, _fault);                \
        }                                                               \
    if (_fault != md_fault_none)                                        \
      DECLARE_FAULT(_fault);                                            \
   }         
    
DEFINST(STH,                   0x2C,
        "sth",                 "s,o(a)",
        WrPort,                F_MEM|F_STORE|F_DISP,
        DNA,DNA,               PPC_DGPR(RS),PPC_DGPR(RA),DNA,
        DNA, DNA, DNA,         DNA, DNA)

  
#define LMW_IMPL                                                       	\
   {                                                                    \
    word_t _result,_reg;						\
    enum md_fault_type _fault;                                          \
    sword_t _ea;							\
    if(RA==0)                                                           \
        {                                                               \
           _ea = OFS;                        				\
        }                                                               \
    else                                                                \
        {                                                               \
           _ea = GPR(RA)+OFS;                				\
        }                                                               \
	_reg=RD;							\
	while(_reg<MD_NUM_IREGS){					\
		_result = READ_WORD(_ea, _fault);			\
        	if (_fault != md_fault_none)                            \
               		DECLARE_FAULT(_fault);                          \
        	SET_GPR(_reg, _result);                                 \
		_reg++;							\
		_ea=_ea+4;						\
	}								\
   }
 

DEFINST(LMW,                0x2E,
        "lmw",              "d,o(a)",
        RdPort,             F_MEM|F_LOAD|F_DISP,
        PPC_DGPR(RD),DNA,   DNA, PPC_DGPR(RA), DNA,
        DNA, DNA, DNA,      DNA, DNA)
 


#define STMW_IMPL                                                       \
   {                                                                    \
    word_t _result,_reg;                                                \
    enum md_fault_type _fault;                                          \
    sword_t _ea;                                                        \
    if(RA==0)                                                           \
        {                                                               \
           _ea = OFS;                                               	\
        }                                                               \
    else                                                                \
        {                                                               \
           _ea = GPR(RA)+OFS;                                       	\
        }                                                               \
        _reg=RD;                                                        \
        while(_reg<MD_NUM_IREGS){                                       \
		_result=GPR(_reg);					\
		/* karu comment: I believe src and dst are intechanged */ \
                WRITE_WORD(_result, _ea, _fault);		        \
                if (_fault != md_fault_none) {                          \
                        DECLARE_FAULT(_fault);                          \
		} 							\
		_result = 0;						\
		_result = READ_WORD(_ea, _fault);			\
                if (_fault != md_fault_none) {                          \
                        DECLARE_FAULT(_fault);                          \
                }                                                       \
                _reg++;                                                 \
                _ea=_ea+4;                                              \
        }                                                               \
   }


DEFINST(STMW,           0x2F,
        "stmw",         "s,o(a)",
        WrPort,         F_MEM|F_STORE|F_DISP,
        DNA,DNA,        PPC_DGPR(RS),PPC_DGPR(RA), DNA,
        DNA,DNA,DNA,    DNA, DNA)



#define LFS_IMPL                                                        \
   {                                                                    \
     word_t _result;                                                    \
     enum md_fault_type _fault;                                         \
     dfloat_t _da;							\
     if(RA==0){                                                         \
                _result = READ_WORD(OFS,_fault);                        \
        }                                                               \
     else{                                                              \
                 _result = READ_WORD(GPR(RA) + OFS, _fault);            \
        }								\
        if(_fault!=md_fault_none)                               	\
        	DECLARE_FAULT(_fault);                          	\
	_da =(dfloat_t)( *((sfloat_t*)(&_result)));			\
        PPC_SET_FPR_D(RD, _da);                                 	\
   }    
    

DEFINST(LFS,                    0x30,
        "lfs",                  "D, o(a)",
        RdPort,                 F_MEM|F_LOAD|F_DISP,
        PPC_DFPR(FD),DNA,       DNA, PPC_DGPR(RA), DNA,
        DNA, DNA, DNA,        	DNA, DNA)



#define LFSU_IMPL                                                       \
   {                                                                    \
     word_t _result;                                                    \
     enum md_fault_type _fault;                                         \
     dfloat_t _da;							\
                                                                        \
     if(RA==0){                                                         \
        	DECLARE_FAULT(md_fault_invalidinstruction);             \
     }                                                               	\
     else{                                                              \
                _result = READ_WORD(GPR(RA) + OFS, _fault);             \
                if (_fault != md_fault_none)                            \
                DECLARE_FAULT(_fault);                                  \
		_da =(dfloat_t)( *((sfloat_t*)(&_result)));		\
        	PPC_SET_FPR_D(RD, _da);                                 \
		SET_GPR(RA, GPR(RA) + OFS);				\
        }                                                               \
   }

 
DEFINST(LFSU,                   	0x31,
        "lfsu",                 	"D,o(a)",
        RdPort,                 	F_MEM|F_LOAD|F_DISP,
        PPC_DFPR(FD),PPC_DGPR(RA),      DNA, PPC_DGPR(RA), DNA,
        DNA, DNA, DNA,        		DNA, DNA)



#define LFD_IMPL                                                     \
  {								     \
    enum md_fault_type _fault;                                       \
    sword_t _ea;    						     \
    qword_t _res;						     \
    if(RA==0)                                                        \
      _ea = OFS;						     \
    else								\
      _ea = GPR(RA) + OFS;						\
    _res = READ_DOUBLE(_ea, _fault);					\
    if (_fault != md_fault_none)					\
      DECLARE_FAULT(_fault);						\
    PPC_SET_FPR_DW(FD, _res);						\
  }


DEFINST(LFD,	                0x32,
        "lfd",                  "D,o(a)",
        RdPort,                 F_MEM|F_LOAD|F_DISP,
        PPC_DFPR(FD), DNA,      DNA, PPC_DGPR(RA), DNA,
        DNA, DNA, DNA,        	DNA, DNA)



#define LFDU_IMPL                                                     \
{                                                                     \
    word_t _result_hi, _result_lo;                                    \
    enum md_fault_type _fault;                                        \
    sword_t _ea;						      \
    qword_t _res;                                                     \
    if(RA==0){                                                	      \
        DECLARE_FAULT(md_fault_invalidinstruction);                   \
    } else{						              \
        _ea = GPR(RA) + OFS;                                          \
        _result_hi = READ_WORD(_ea, _fault);                          \
        if (_fault != md_fault_none)                                  \
      	    DECLARE_FAULT(_fault);                                    \
        _result_lo = READ_WORD(_ea + 4, _fault);                      \
    	if (_fault != md_fault_none)                                  \
            DECLARE_FAULT(_fault);                                    \
        _res = ((qword_t)_result_hi)<<32;                 	      \
        _res = _res || (qword_t) _result_lo;              	      \
        memcpy( (&_res), &_result_hi, sizeof(word_t) );               \
        memcpy( (word_t *) (&_res)+1, &_result_lo, sizeof(word_t) );  \
        PPC_SET_FPR_DW(FD, _res);                                     \
        SET_GPR(RA,_ea);					      \
    }  								      \
}


DEFINST(LFDU,                   	0x33,
        "lfdu",                 	"D,o(a)",
        RdPort,                 	F_MEM|F_LOAD|F_DISP,
        PPC_DFPR(FD), PPC_DGPR(RA),     DNA, PPC_DGPR(RA), DNA,
        DNA, DNA, DNA,        		DNA, DNA)


/* Due to some differences in the assmbler between 10.3 and 10.4 (or
   probably gcc3.3 and gcc4) we require some different assembly for
   some of the floating point things. This macro seems to take care of
   it, used with the assembly flag -Dis10_3=1 */
#ifndef is10_3
#define is10_3 0
#endif
#if is10_3==1
#define OFF1 "%1"
#else
/* AFR: had to add "r0" to a number of asm statements so that gcc4
   wouldn't try and use r0 as the offset register. */      
#define OFF1 "0(%1)"
#endif


#define STFS_IMPL						    \
{								    \
    enum md_fault_type _fault;                                      \
    float tempf=0; 				                    \
    word_t *ptempf;			                            \
    qword_t _d = PPC_FPR_DW(FS);				    \
    ptempf = (word_t *) (&tempf);		                    \
    double dd = *((double*)&_d);				    \
    tempf = float(dd);						    \
    /*asm("stfs %0, " OFF1 : : "f" (_d), "g" (*ptempf) : "r0" );*/  \
    if(RA==0){							    \
        WRITE_WORD(*ptempf, OFS, _fault);	                    \
    }							            \
    else{							    \
        WRITE_WORD(*ptempf, GPR(RA)+OFS, _fault);                   \
    }		                                                    \
    if (_fault != md_fault_none)                               	    \
        DECLARE_FAULT(_fault);                                      \
}


DEFINST(STFS,			0x34,
	"stfs",			"S,o(a)",
	WrPort,			F_MEM|F_STORE|F_DISP,
	DNA,DNA,		PPC_DFPR(FS),PPC_DGPR(RA),DNA,
        DNA, DNA, DNA,        	DNA, DNA)
	



#define STFSU_IMPL                                                  \
{                                                                   \
    enum md_fault_type _fault;                                      \
    IF_CMMT(float tempf);                                         \
    IF_CMMT(word_t *ptempf);                                      \
    IF_CMMT(qword_t _d =PPC_FPR_DW(FS));                          \
    IF_CMMT(double double_a);                                     \
    IF_CMMT(memcpy(&double_a, &_d,sizeof(double)));               \
    IF_CMMT(tempf  = (float)double_a);                            \
    IF_CMMT(ptempf = (word_t *) (&tempf));                        \
    /*asm("stfs %0, " OFF1: : "f" (_d), "g" (*ptempf) : "r0");*/    \
    WRITE_WORD(*ptempf, GPR(RA)+OFS, _fault);                       \
    if (_fault != md_fault_none)                                    \
        DECLARE_FAULT(_fault);                                      \
    SET_GPR(RA, GPR(RA)+OFS);                                       \
}
        
        
DEFINST(STFSU,                  0x35,
        "stfsu",                "S,o(a)",
        WrPort,                 F_MEM|F_STORE|F_DISP,
        PPC_DGPR(RA),DNA,       PPC_DFPR(FS),PPC_DGPR(RA),DNA,
        DNA, DNA, DNA,        	DNA, DNA)
  

#define STFD_IMPL							\
  {									\
    enum md_fault_type _fault;						\
    IF_CMMT(qword_t _d = PPC_FPR_DW(FS));				\
    if(RA==0){								\
      WRITE_DOUBLE(_d, OFS, _fault);					\
    } else {								\
  WRITE_DOUBLE(_d, GPR(RA)+OFS, _fault);				\
    }									\
    if (_fault != md_fault_none)					\
      DECLARE_FAULT(_fault);						\
}


DEFINST(STFD,                   0x36,
        "stfd",                 "S, o(a)",
        WrPort,                 F_MEM|F_STORE|F_DISP,
        DNA,DNA,                PPC_DFPR(FS),PPC_DGPR(RA),DNA,
        DNA, DNA, DNA,        	DNA, DNA)

#define STFDU_IMPL                                                      \
   {                                                                    \
        enum md_fault_type _fault;                                      \
        if(RA==0){                                                      \
                DECLARE_FAULT(md_fault_invalidinstruction);             \
                }                                                       \
        else{                                                           \
                WRITE_WORD( (PPC_FPR_UW(FS)), GPR(RA)+OFS, _fault);     \
                if (_fault != md_fault_none)                            \
                        DECLARE_FAULT(_fault);                          \
                WRITE_WORD( (PPC_FPR_W(FS)), GPR(RA)+OFS+4, _fault);	\
                if (_fault != md_fault_none)                            \
                        DECLARE_FAULT(_fault);                          \
                SET_GPR(RA, GPR(RA)+OFS);                               \
        }                                                               \
   }
             
             
DEFINST(STFDU,                  0x37,
        "stfdu",                "S, o(a)",
        WrPort,                 F_MEM|F_STORE|F_DISP,
        PPC_DGPR(RA),DNA,       PPC_DFPR(FS),PPC_DGPR(RA),DNA,
        DNA, DNA, DNA,        	DNA, DNA)


/*All the instructions which have a common opcode and then an extenede opcode are
grouped together here. A name given to that group is defined in the
DEFLINK and the DEFINST for all the instructions contain the extended opcode. The
instruction decode than decodes the grouped instructions with a common opcode using 
this. To see the groups here refer to the programmers manual of PowerPC*/


DEFLINK(FDIVS_LINK, 0x3B, "fdivs_link", 0, 0x3f, 0) 
DEFLINK(FCMPU_LINK, 0x3f, "fcmpu_link", 0, 0x7ff, 0x3f) 
DEFLINK(CMP_LINK, 0x1f, "cmpl_link", 0, 0x7ff, 0) 
DEFLINK(B_LINK, 0x12, "b_link", 0, 0x3, 0) 
DEFLINK(RLWNM_LINK, 0x17, "rlwnm_link", 0, 0x1, 0) 
DEFLINK(RLWINM_LINK, 0x15, "rlwinm_link", 0, 0x1, 0) 
DEFLINK(RLWIMI_LINK, 0x14, "rlwimi_link", 0, 0x1, 0) 
DEFLINK(MCRF_LINK, 0x13, "mcrf_link", 0, 0x7ff, 0)
DEFLINK(BC_LINK, 0x10, "bc_link", 0, 0x3, 0) 
DEFLINK(VCMPEQUW_LINK, 0x4, "vcmpequw_link", 0, 0x7ff, 0) 

CONNECT(VCMPEQUW_LINK)

#define VSPLTW_IMPL						  \
{						                  \
  IF_CMMT(word_t splat = VR(RB, RA));				  \
  for (int i = 0; i < altivecWordSize; ++i) {			  \
    SET_VR(RD, i, splat);					  \
  }								  \
}

DEFINST(VSPLTW,	 	        0x28C,
	"vspltisw",		"d,a,b",
	IntALU,			F_ICOMP|F_IMM,
	PPC_VR(RD),DNA,	        PPC_VR(RB),DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)


#define VCMPEQUW_IMPL                                             \
  {								  \
    /*printf("VCMPEQUW Called vD=%ld Ra=%ld Rb=%ld cI=%x\n", */	  \
    /*RD, RA, RB, CurrentInstruction);*/			  \
    for (int i = 0; i < altivecWordSize; ++i) {			  \
      if (VR(RA,i) == VR(RB,i)) {				  \
	SET_VR(RD, i, 0xffffffff);				  \
      } else {							  \
	SET_VR(RD, i, 0);					  \
      }								  \
    }								  \
  }

DEFINST(VCMPEQUW,               0x86,
	"vcmpequw",             "d,a,b",
	IntALU,			F_ICOMP,
	PPC_VR(RD),DNA,         PPC_VR(RA),PPC_VR(RB),DNA,
        DNA, DNA, DNA,        	DNA, DNA)

#define VCMPEQUWD_IMPL							\
  {									\
    /*printf("VCMPEQUW. Called vD=%ld Ra=%ld Rb=%ld cI=%x\n",*/		\
    /*RD, RA, RB, CurrentInstruction);*/				\
    int trues = 0;							\
    for (int i = 0; i < altivecWordSize; ++i) {				\
      if (VR(RA,i) == VR(RB,i)) {					\
	trues++;							\
	SET_VR(RD, i, 0xffffffff);					\
      } else {								\
	SET_VR(RD, i, 0);						\
      }									\
    }									\
    unsigned int cr6;							\
    if (trues == altivecWordSize) {	/*true for all*/		\
      cr6 = 0x8;							\
    } else if (trues == 0) { /* true for none */			\
      cr6 = 0x2;							\
    } else {								\
      cr6 = 0;								\
    }									\
    PPC_CLEAR_CR6;							\
    PPC_SET_CR6(cr6);							\
  }

DEFINST(VCMPEQUWD,               0x486,
	"vcmpequw.",             "d,a,b",
	IntALU,			F_ICOMP,
	PPC_VR(RD),PPC_DCR,     PPC_VR(RA),PPC_VR(RB),DNA,
        DNA, DNA, DNA,        	DNA, DNA)

#define VAND_IMPL                                                 \
  {								  \
    /*printf("VAND Called vD=%ld Ra=%ld Rb=%ld\n", RD, RA, RB);*/ \
    for (int i = 0; i < altivecWordSize; ++i) {			  \
      SET_VR(RD, i, VR(RA,i) & VR(RB,i));			  \
    }								  \
  }

DEFINST(VAND,			0x404,
	"Vand",			"d,a,b",
	IntALU,			F_ICOMP,
	PPC_VR(RD),DNA,	        PPC_VR(RA),PPC_VR(RB),DNA,
        DNA, DNA, DNA,        	DNA, DNA)

CONNECT(BC_LINK)

#define BC_IMPL                                       \
 {                                                    \
    word_t _ctr, PC;                                  \
    word_t ctr_ok;                                    \
    word_t cond_ok;                                   \
    word_t nia;                                       \
    /*OPCODEBUG("bc");*/			      \
    _ctr= CNTR; PC = CPC;                             \
    if (DECREMENTS_CTR (inst)) {                      \
        _ctr--; PPC_SET_CNTR(_ctr);                   \
        if (BR_IF_CTR_ZERO (inst)) {                  \
            ctr_ok = (_ctr == 0);                     \
        } else {                                      \
            ctr_ok = (_ctr != 0);                     \
        }                                             \
    } else {                                          \
        ctr_ok = 1;                                   \
    }                                                 \
    if (CONDITIONAL_BR (inst)) {                      \
        if (BR_IF_TRUE (inst)) {                      \
            cond_ok = (CR << GET_BI (inst)) & 0x80000000;      \
        } else {                                               \
            cond_ok = !((CR << GET_BI (inst)) & 0x80000000);   \
        }						      \
    } else {                                          \
        cond_ok = 1;                                  \
    }                                                 \
    if (GET_LK (inst))                                \
      PPC_SET_LR(PC + sizeof(inst));		      \
    if (ctr_ok && cond_ok) {                          \
        if (GET_AA (inst)) {                          \
            nia = SEXT16(BD<<2);                      \
        } else {                                      \
            nia = PC + SEXT16(BD<<2);                 \
        }                                             \
        SET_NPC(nia);                                 \
    } else {                                          \
        SET_NPC(PC + sizeof(inst) );                  \
    }                                                 \
}


DEFINST(BC,                    0x0,
        "bc",                  "f,g,k",
        IntALU,                F_CTRL|F_COND|F_DIRJMP,
        PPC_DCNTR,DNA,         PPC_DCNTR,DNA,DNA,
        DNA, DNA, DNA,         DNA, DNA)


   
#define BCL_IMPL                                        \
   {                                                    \
    word_t _ctr,_bflag=0,_cond;                         \
    /*OPCODEBUG("bcl");*/ \
    _ctr= CNTR;                                         \
    if(!(0x4&BO)){                                      \
         _ctr=_ctr-1;                                   \
        PPC_SET_CNTR(_ctr);                             \
    }                                                   \
    _cond = (CR>>(31-BI))&0x1;                          \
                                                        \
     if(0x10&BO){                                       \
        if(0x14&BO) _bflag=1;                           \
        if( (0x12&BO) && (_ctr==0) ) _bflag=1;          \
        else if(_ctr!=0) _bflag=1;                      \
     }                                                  \
     else if(0x8&BO){                                   \
        if(_cond){                                      \
                if(0x4&BO) _bflag=1;                    \
                if( (0x2&BO) && (_ctr==0) ) _bflag=1;   \
                else if(_ctr!=0) _bflag=1;              \
        }                                               \
     }                                                  \
     else{                                              \
        if(!(_cond)){                                   \
                if(0x4&BO) _bflag=1;                    \
                if( (0x2&BO) && (_ctr==0) ) _bflag=1;   \
                else if(_ctr!=0) _bflag=1;              \
        }                                               \
     }                                                  \
     PPC_SET_LR(CPC+4);                                 \
     SET_TPC(CPC + SEXT16((BD<<2)));                    \
     if(_bflag)  SET_NPC(CPC + SEXT16((BD<<2)));        \
   }
    
DEFINST(BCL,                   0x1,
        "bcl",                 "f,g,k",
        IntALU,                F_CTRL|F_COND|F_DIRJMP|F_CALL,
        PPC_DLR,PPC_DCNTR,     PPC_DCNTR,DNA,DNA,
	DNA, DNA, DNA,         DNA,DNA)	

#define BCA_IMPL                                        \
   {                                                    \
    word_t _ctr,_bflag=0,_cond;                         \
    /*OPCODEBUG("bca");*/ \
    _ctr= CNTR;                                         \
    if(!(0x4&BO)){                                      \
         _ctr=_ctr-1;                                   \
        PPC_SET_CNTR(_ctr);                             \
    }                                                   \
    _cond = (CR>>(31-BI))&0x1;                          \
                                                        \
     if(0x10&BO){                                       \
        if(0x14&BO) _bflag=1;                           \
        if( (0x12&BO) && (_ctr==0) ) _bflag=1;          \
        else if(_ctr!=0) _bflag=1;                      \
     }                                                  \
     else if(0x8&BO){                                   \
        if(_cond){                                      \
                if(0x4&BO) _bflag=1;                    \
                if( (0x2&BO) && (_ctr==0) ) _bflag=1;   \
                else if(_ctr!=0) _bflag=1;              \
        }                                               \
     }                                                  \
     else{                                              \
        if(!(_cond)){                                   \
                if(0x4&BO) _bflag=1;                    \
                if( (0x2&BO) && (_ctr==0) ) _bflag=1;   \
                else if(_ctr!=0) _bflag=1;              \
        }                                               \
     }                                                  \
     SET_TPC(SEXT16((BD<<2)));         	                \
     if(_bflag)  SET_NPC(SEXT16((BD<<2)));         	\
   }
    
DEFINST(BCA,                   0x2,
        "bca",                 "f,g,k",
        IntALU,                F_CTRL|F_COND|F_DIRJMP,
        PPC_DCNTR,DNA,         PPC_DCNTR,DNA,DNA,
	DNA, DNA, DNA,         DNA,DNA)	


#define BCLA_IMPL                                       \
   {                                                    \
    word_t _ctr,_bflag=0,_cond;                         \
    /*OPCODEBUG("bcla");*/ \
    _ctr= CNTR;                                         \
    if(!(0x4&BO)){                                      \
         _ctr=_ctr-1;                                   \
        PPC_SET_CNTR(_ctr);                             \
    }                                                   \
    _cond = (CR>>(31-BI))&0x1;                          \
                                                        \
     if(0x10&BO){                                       \
        if(0x14&BO) _bflag=1;                           \
        if( (0x12&BO) && (_ctr==0) ) _bflag=1;          \
        else if(_ctr!=0) _bflag=1;                      \
     }                                                  \
     else if(0x8&BO){                                   \
        if(_cond){                                      \
                if(0x4&BO) _bflag=1;                    \
                if( (0x2&BO) && (_ctr==0) ) _bflag=1;   \
                else if(_ctr!=0) _bflag=1;              \
        }                                               \
     }                                                  \
     else{                                              \
        if(!(_cond)){                                   \
                if(0x4&BO) _bflag=1;                    \
                if( (0x2&BO) && (_ctr==0) ) _bflag=1;   \
                else if(_ctr!=0) _bflag=1;              \
        }                                               \
     }                                                  \
     PPC_SET_LR(CPC+4);					\
     SET_TPC(SEXT16((BD<<2)));         	                \
     if(_bflag)  SET_NPC(SEXT16((BD<<2)));         	\
   }
    
DEFINST(BCLA,                  0x3,
        "bcla",                "f,g,k",
        IntALU,                F_CTRL|F_COND|F_DIRJMP|F_CALL,
        PPC_DLR,PPC_DCNTR,     PPC_DCNTR,DNA,DNA,
	DNA, DNA, DNA,         DNA,DNA)	




CONNECT(MCRF_LINK)

#define MCRF_IMPL                                           \
   {                                                        \
        word_t _a, _b, _c, _d;                              \
        _c = CR;                                            \
	_a = ( 0xf  << (( 7 - CRFS)*4) ) & CR;		    \
	_a = (_c >> (( 7 - CRFS)*4)) & 0xf;		    \
	_b = _a << (( 7 - CRFD)*4);			    \
	_d = ( 0xf  << (( 7 - CRFD)*4) ) ;		    \
        PPC_SET_CR( ((_c & ~(_d)) | _b ) );                 \
   }

        

DEFINST(MCRF,                  0x0,
        "mcrf",                "r,w",
        IntALU,                F_ICOMP,
        PPC_DCR, DNA,          PPC_DCR, DNA, DNA,
        DNA, DNA, DNA,         DNA, DNA)


#define CRNOR_IMPL	                        \
   {                                            \
        word_t _a, _b, _c, _d, _m;              \
        _c = CR;                                \
        _a = (0x1)  & (_c >> (31- CRBA));       \
        _b = (0x1)  & (_c >> (31- CRBB));       \
        _d = (!(_a | _b)) << (31-CRBD);		\
		  _m = ~(1 << (31-CRBD));       \
        PPC_SET_CR( ((_c & _m) | _d ) );        \
   }
    
    
    
DEFINST(CRNOR,   	        0x42,
        "crnor",                "x,y,z",
        IntALU,                 F_ICOMP,
        PPC_DCR, DNA,           PPC_DCR, DNA, DNA,
        DNA, DNA, DNA,        	DNA, DNA)


  


#define BCLR_IMPL                                               \
   {                                                            \
     word_t nia;						\
     word_t ctr_ok, cond_ok, _ctr, PC;				\
     _ctr= CNTR;						\
     PC = CPC;							\
     ctr_ok = 0; cond_ok = 0;					\
     if (DECREMENTS_CTR (inst)) {				\
       _ctr--;							\
       if (BR_IF_CTR_ZERO (inst)) {				\
	 ctr_ok = (_ctr == 0);					\
       } else {							\
	 ctr_ok = (_ctr != 0);					\
       }							\
     } else {							\
       ctr_ok = 1;						\
     }								\
     								\
     if (CONDITIONAL_BR (inst)) {				\
       if (BR_IF_TRUE (inst)) {					\
	 cond_ok = (CR << GET_BI (inst)) & 0x80000000;		\
       } else {							\
	 cond_ok = !((CR << GET_BI (inst)) & 0x80000000);	\
       }							\
     } else {							\
       cond_ok = 1;						\
     }								\
     								\
     if (ctr_ok && cond_ok) {					\
       nia = LR & -4;						\
     } else {							\
       nia = PC + sizeof(inst);					\
     }								\
     if (GET_LK (inst)) {					\
       PPC_SET_LR(PC + sizeof(inst));				\
     }								\
     SET_NPC(nia);						\
   }

DEFINST(BCLR,                  0x20,
        "bclr",                "f,g",
        IntALU,                F_CTRL|F_COND|F_INDIRJMP,
        PPC_DCNTR,DNA,         PPC_DCNTR,PPC_DLR,DNA,
	DNA, DNA, DNA,         DNA,DNA)	

  


#define BCLRL_IMPL                                      \
   {                                                    \
    word_t _ctr,_bflag=0,_cond;                         \
    _ctr= CNTR;                                         \
    if(!(0x4&BO)){                                      \
         _ctr=_ctr-1;                                   \
        PPC_SET_CNTR(_ctr);                             \
    }                                                   \
    _cond = (CR>>(31-BI))&0x1;                          \
                                                        \
     if(0x10&BO){                                       \
        if(0x14&BO) _bflag=1;                           \
        if( (0x12&BO) && (_ctr==0) ) _bflag=1;          \
        else if(_ctr!=0) _bflag=1;                      \
     }                                                  \
     else if(0x8&BO){                                   \
        if(_cond){                                      \
                if(0x4&BO) _bflag=1;                    \
                if( (0x2&BO) && (_ctr==0) ) _bflag=1;   \
                else if(_ctr!=0) _bflag=1;              \
        }                                               \
     }                                                  \
     else{                                              \
        if(!(_cond)){                                   \
                if(0x4&BO) _bflag=1;                    \
                if( (0x2&BO) && (_ctr==0) ) _bflag=1;   \
                else if(_ctr!=0) _bflag=1;              \
        }                                               \
     }                                                  \
							\
    SET_TPC(LR &0xfffffffc);                            \
    if(_bflag)  SET_NPC(LR &0xfffffffc);                \
    PPC_SET_LR(CPC+4);					\
   }
    
DEFINST(BCLRL,                 0x21,
        "bclrl",               "f,g",  
        IntALU,                F_CTRL|F_COND|F_INDIRJMP|F_CALL,
        PPC_DCNTR,PPC_DLR,     PPC_DCNTR,PPC_DLR,DNA,
        DNA, DNA, DNA,         DNA, DNA)
  


#define CRANDC_IMPL                                           \
   {                                                          \
        word_t _a, _b, _c, _d, _m;                            \
        _c = CR;                                              \
        _a = (0x1) & (_c >> (31- CRBA));                      \
        _b = (0x1) & (_c >> (31- CRBB));                      \
		  _d = (_a & !_b) << (31-CRBD);               \
		  _m = ~(1 << (31-CRBD));                     \
        PPC_SET_CR( ((_c & _m) | _d ) );                      \
   }
    


DEFINST(CRANDC,                 0x102,
        "crandc",               "x,y,z",
        IntALU,                 F_ICOMP,
        PPC_DCR, DNA,               PPC_DCR, DNA, DNA,
        DNA, DNA, DNA,        	DNA, DNA)

#define ISYNC_IMPL                                              \
   {                                                            \
        EXEC_ISYNC;						\
   }

DEFINST(ISYNC,                  0x12C,
        "isync",                "",
        FUClass_NA,             F_MEM,
        DNA,DNA,                DNA,DNA,DNA,
        DNA, DNA, DNA,         	DNA, DNA)



#define CRXOR_IMPL                                               \
   {                                                             \
        word_t _a, _b, _c, _d,_m;                                \
        _c = CR;                                                 \
        _a = (0x1)  & (_c >> (31- CRBA));                        \
        _b = (0x1)  & (_c >> (31- CRBB));                        \
        _d = (_a ^ _b) <<(31-CRBD);                              \
		  _m = ~(1 << (31-CRBD));		         \
        PPC_SET_CR( ((_c & _m) | _d ) );                         \
   }

        
        
DEFINST(CRXOR,                 	0x182,
        "crxor",               	"x,y,z",
        IntALU,                	F_ICOMP,
        PPC_DCR, DNA,          	PPC_DCR, DNA, DNA,
        DNA, DNA, DNA,		DNA, DNA)

#define CRNAND_IMPL                                              \
   {                                                             \
        word_t _a, _b, _c, _d, _m;                               \
        _c = CR;                                                 \
        _a = (0x1)  & (_c >> (31- CRBA));                        \
        _b = (0x1)  & (_c >> (31- CRBB));                        \
        _d = (!(_a & _b)) << (31-CRBD);                          \
		_m = ~(0x1 << (31-CRBD));		         \
        PPC_SET_CR( ((_c & _m) | _d ) );                         \
   }
  
  

DEFINST(CRNAND,                 0x1C2,
        "crnand",               "x,y,z",
        IntALU,                 F_ICOMP,
        PPC_DCR, DNA,           PPC_DCR, DNA, DNA,
        DNA, DNA, DNA,        	DNA, DNA)


#define CRAND_IMPL						\
   {								\
	word_t _a, _b, _c, _d, _m;				\
	_c = CR;						\
	_a = (0x1)  & (_c >> (31- CRBA));			\
	_b = (0x1)  & (_c >> (31- CRBB));			\
	_d = (_a & _b)<<(31-CRBD);				\
	_m = ~(1<<(31-CRBD));					\
	PPC_SET_CR( ((_c & _m) | _d ) );			\
   }



DEFINST(CRAND,			0x202,
	"crand",		"x,y,z",
	IntALU,			F_ICOMP,
	PPC_DCR, DNA,		PPC_DCR, DNA, DNA,
        DNA, DNA, DNA,        	DNA, DNA)

#define CREQV_IMPL                                              \
   {                                                            \
        word_t _a, _b, _c, _d, _m;                              \
        _c = CR;                                                \
        _a = (0x1)  & (_c >> (31- CRBA));                       \
        _b = (0x1)  & (_c >> (31- CRBB));                       \
		  _d = (!(_a ^ _b)) << (31-CRBD);		\
		  _m = ~(0x1 << (31-CRBD));	                \
        PPC_SET_CR( ((_c & _m) | _d ) );                        \
   }
    


DEFINST(CREQV,                  0x242,
        "creqv",                "x,y,z",
        IntALU,                 F_ICOMP,
        PPC_DCR, DNA,           PPC_DCR, DNA, DNA,
        DNA, DNA, DNA,        	DNA, DNA)





  
#define CRORC_IMPL                                \
{                                                 \
    word_t _a, _b, _c, _d, _m;			  \
    _c = CR;                                      \
    _a = (0x1)  & (_c >> (31- CRBA));             \
    _b = (0x1)  & (_c >> (31- CRBB));             \
    _d = (_a | (!_b)) << (31-CRBD);               \
    _m = ~(0x1 << (31-CRBD));                     \
    PPC_SET_CR( (_c & _m) | _d );                 \
}
        
        
    
DEFINST(CRORC,                  0x342,
        "crorc",                "x,y,z",
        IntALU,                 F_ICOMP,
        PPC_DCR, DNA,           PPC_DCR, DNA, DNA,
        DNA, DNA, DNA,        	DNA, DNA)




#define CROR_IMPL                                               \
   {                                                            \
        word_t _a, _b, _c, _d, _m;                              \
        _c = CR;                                                \
        _a = (0x1)  & (_c >> (31- CRBA));			\
        _b = (0x1) & (_c >> (31- CRBB));                        \
        _d = (_a | _b)<<(31-CRBD);                              \
        _m = ~(1 << (31-CRBD));			                \
        PPC_SET_CR( ((_c & _m) | _d ) );                        \
   }
    


DEFINST(CROR,                  0x382,
        "cror",                "x,y,z",
        IntALU,                F_ICOMP,
        PPC_DCR, DNA,          PPC_DCR, DNA, DNA,
        DNA, DNA, DNA,         DNA, DNA)



#define BCCTR_IMPL                                      \
{                                                       \
    word_t _ctr,_bflag=0,_cond;                         \
    /*OPCODEBUG("bcctr");*/                             \
    _ctr= CNTR;                                         \
    if(!(0x4&BO)){                                      \
        _ctr=_ctr-1;                                    \
        PPC_SET_CNTR(_ctr);                             \
    }                                                   \
    _cond = (CR>>(31-BI))&0x1;                          \
                                                        \
    if(0x10&BO){                                        \
        if(0x14&BO)                  _bflag=1;          \
        if( (0x12&BO) && (_ctr==0) ) _bflag=1;          \
        else if(_ctr!=0)             _bflag=1;          \
    }                                                   \
    else if(0x8&BO){                                    \
        if(_cond){                                      \
            if(0x4&BO)                  _bflag=1;       \
            if( (0x2&BO) && (_ctr==0) ) _bflag=1;       \
            else if(_ctr!=0)            _bflag=1;       \
        }                                               \
    }                                                   \
    else{                                               \
        if(!(_cond)){                                   \
            if(0x4&BO)                  _bflag=1;       \
            if( (0x2&BO) && (_ctr==0) ) _bflag=1;       \
            else if(_ctr!=0)            _bflag=1;       \
        }                                               \
    }                                                   \
    SET_TPC(CNTR &0xfffffffc);         	                \
    if(_bflag)                                          \
        SET_NPC(CNTR &0xfffffffc);         	        \
}
    
DEFINST(BCCTR,                 0x420,
        "bcctr",               "f,g",
        IntALU,                F_CTRL|F_COND|F_INDIRJMP,
        DNA,DNA,               PPC_DCNTR,DNA,DNA,
	DNA, DNA, DNA,         DNA,DNA)	




#define BCCTRL_IMPL                                     \
   {                                                    \
    word_t _ctr,_bflag=0,_cond;                         \
    /*OPCODEBUG("bcctrl");*/                            \
    _ctr= CNTR;                                         \
    if(!(0x4&BO)){                                      \
         _ctr=_ctr-1;                                   \
        PPC_SET_CNTR(_ctr);                             \
    }                                                   \
    _cond = (CR>>(31-BI))&0x1;                          \
                                                        \
     if(0x10&BO){                                       \
        if(0x14&BO) _bflag=1;                           \
        if( (0x12&BO) && (_ctr==0) ) _bflag=1;          \
        else if(_ctr!=0) _bflag=1;                      \
     }                                                  \
     else if(0x8&BO){                                   \
        if(_cond){                                      \
                if(0x4&BO) _bflag=1;                    \
                if( (0x2&BO) && (_ctr==0) ) _bflag=1;   \
                else if(_ctr!=0) _bflag=1;              \
        }                                               \
     }                                                  \
     else{                                              \
        if(!(_cond)){                                   \
                if(0x4&BO) _bflag=1;                    \
                if( (0x2&BO) && (_ctr==0) ) _bflag=1;   \
                else if(_ctr!=0) _bflag=1;              \
        }                                               \
     }                                                  \
     PPC_SET_LR(CPC+4);					\
     SET_TPC(CNTR &0xfffffffc);                         \
     if(_bflag)  SET_NPC(CNTR &0xfffffffc);             \
   }
        
DEFINST(BCCTRL,                0x421,
        "bcctrl",              "f,g",
        IntALU,                F_CTRL|F_COND|F_INDIRJMP|F_CALL,
        PPC_DLR,DNA,           PPC_DCNTR,DNA,DNA,
	DNA, DNA, DNA,         DNA,DNA)	




CONNECT(RLWIMI_LINK)

#define RLWIMI_IMPL						\
   {								\
	word_t _n, _r, _m;                                      \
   _m = sim_mask32(MB, ME);					\
   _n = SH;							\
   _r = GPR(RS);						\
   _r = sim_rotate_left_32(_r, _n);				\
	SET_GPR(RA, ( (_r & _m) | (GPR(RA) & (~ (_m))) ) );	\
   }

DEFINST(RLWIMI,				0x0,
	"rlwimi",			"a,s,h,m,e",
	IntALU,				F_ICOMP|F_IMM,
	PPC_DGPR(RA),DNA,		PPC_DGPR(RS),DNA,DNA,
        DNA, DNA, DNA,        		DNA, DNA)




#define RLWIMID_IMPL                                            \
   {                                                            \
        word_t _n, _r,_src, _m;                                 \
         _m = sim_mask32(MB, ME);				\
         _n = SH;						\
         _r = GPR(RS);						\
         _r = sim_rotate_left_32(_r, _n);			\
        _src = ( (_r & _m) | (GPR(RA) & (~ (_m))) );            \
	if(!(_src))        PPC_SET_CR0_EQ;                      \
        else               PPC_RESET_CR0_EQ;                    \
        if(_src>0)         PPC_SET_CR0_GT;                      \
        else               PPC_RESET_CR0_GT;                    \
        if(_src<0)         PPC_SET_CR0_LT;                      \
        else               PPC_RESET_CR0_LT;                    \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                      \
        else               PPC_RESET_CR0_SO;                    \
        SET_GPR(RA, _src);                                      \
   }
    
DEFINST(RLWIMID,                0x1,
        "rlwimi.",              "a,s,h,m,e",
        IntALU,                 F_ICOMP|F_IMM,
        PPC_DGPR(RA),PPC_DCR,   PPC_DGPR(RS),DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)

  



CONNECT(RLWINM_LINK)

#define RLWINM_IMPL                                             \
   {                                                            \
        word_t _n, _r, _m;                                      \
         _m = sim_mask32(MB, ME);				\
         _n = SH;						\
         _r = GPR(RS);		                                \
         _r = sim_rotate_left_32(_r, _n);                       \
         _r = _r & _m;                                          \
         SET_GPR(RA, _r);                                       \
   }

DEFINST(RLWINM,                 0x0,
        "rlwinm",               "a,s,h,m,e",
        IntALU,                 F_ICOMP|F_IMM,
        PPC_DGPR(RA),DNA,       PPC_DGPR(RS),DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)
        


#define RLWINMD_IMPL                                            \
   {                                                            \
        word_t _n, _r, _m, _src;                                \
			_m = sim_mask32(MB, ME);		\
			_n = SH;		                \
			_r = GPR(RS);		                \
			_r = sim_rotate_left_32(_r, _n);        \
			_r = _r & _m;			        \
			SET_GPR(RA, _r);			\
			_src = _r;                              \
	/* definition has to be modified for 64bit machine */   \
        if(!(_src)) PPC_SET_CR0_EQ;                             \
        else PPC_RESET_CR0_EQ;                                  \
        if(_src>0) PPC_SET_CR0_GT;                              \
        else PPC_RESET_CR0_GT;                                  \
        if(_src<0) PPC_SET_CR0_LT;                              \
        else PPC_RESET_CR0_LT;                                  \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                      \
        else PPC_RESET_CR0_SO;                                  \
   }

DEFINST(RLWINMD,                0x1,
        "rlwinm.",              "a,s,h,m,e",
        IntALU,                 F_ICOMP|F_IMM,
        PPC_DGPR(RA),PPC_DCR,   PPC_DGPR(RS),DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)




CONNECT(RLWNM_LINK)


#if 0
#define RLWNM_IMPL                                             	\
   {                                                            \
        word_t _n, _r, _m;                                      \
        int _i, _c;                                             \
        _n = GPR(RB) & 0x1F;				        \
        _r = ((word_t)GPR(RS))<< _n;                            \
        _c = ME-MB+1;                                           \
        for(_i=0; _i<_c; _i++)                                  \
        {                                                       \
	  _m = (_m <<1) | 0x1;				        \
        }                                                       \
        _m = _m << (31-ME);                                     \
	/* AFR: added check for ME=31 */		        \
	if (ME == 31) {					        \
	  _m = 0 - (1 << MB);					\
	} else {						\
	  _m = (1 << (ME+1)) - (1 << MB);			\
	}							\
        SET_GPR(RA,  (_r & _m) );                    		\
   }
#else
#define RLWNM_IMPL                                              \
   {                                                            \
        word_t _n, _r, _m;                                      \
        _n = GPR(RB) & 0x1F;				        \
        _r = sim_rotate_left_32(GPR(RS), _n);			\
        _m = sim_mask32(MB, ME);				\
        SET_GPR(RA,  (_r & _m) );                    		\
   }
#endif
        
DEFINST(RLWNM,                  0x0,
        "rlwnm",                "a,s,b,m,e",
        IntALU,                 F_ICOMP|F_IMM,
        PPC_DGPR(RA),DNA,       PPC_DGPR(RS),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,        	DNA, DNA)




#define RLWNMD_IMPL                                              \
   {                                                             \
        word_t _n, _r, _m, _src;                                 \
        int _i, _c;                                              \
        /* should probably use sim_mask to create mask */        \
	printf("AFR: suspect instruction\n");			 \
	_m = 0;							 \
	_n = GPR(RB)&0x1F;					 \
        _r = ((word_t)GPR(RS))<< _n;                             \
        _c = ME-MB+1;                                            \
        for(_i=0; _i<_c; _i++)                                   \
        {                                                        \
                _m = (_m <<1) | 0x1;                             \
        }                                                        \
        _m = _m << (31-ME);                                      \
        _src = ( (_r & _m) );                                    \
        if(!(_src)) PPC_SET_CR0_EQ;                              \
        else PPC_RESET_CR0_EQ;                                   \
        if(_src>0) PPC_SET_CR0_GT;                               \
        else PPC_RESET_CR0_GT;                                   \
        if(_src<0) PPC_SET_CR0_LT;                               \
        else PPC_RESET_CR0_LT;                                   \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                       \
        else PPC_RESET_CR0_SO;                                   \
        SET_GPR(RA, _src);                                       \
   }
        
DEFINST(RLWNMD,                 0x1,
        "rlwnm.",               "a,s,b,m,e",
        IntALU,                 F_ICOMP|F_IMM,
        PPC_DGPR(RA),PPC_DCR,   PPC_DGPR(RS),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,        	DNA, DNA)
   

CONNECT(B_LINK)

#define opB_IMPL                                                \
   {								\
	SET_TPC( CPC + SEXT26(LI ) ); 				\
	SET_NPC( CPC + SEXT26(LI ) ); 				\
   }

DEFINST(opB,			0x0,
	"b",			"j",
	IntALU,			F_CTRL|F_UNCOND|F_DIRJMP,
	DNA,DNA,		DNA,DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)
		


#define BA_IMPL                                                  \
   {                                                             \
        SET_TPC( SEXT26(LI) );     		                 \
        SET_NPC( SEXT26(LI) );     		                 \
   }
                 
DEFINST(BA,                     0x2,
        "ba",                   "j",
        IntALU,                 F_CTRL|F_UNCOND|F_DIRJMP,
        DNA,DNA,                DNA,DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)




#define BL_IMPL                                                 \
{                                                               \
    SET_TPC( CPC + SEXT26(LI ) );                               \
    SET_NPC( CPC + SEXT26(LI ) );                               \
    PPC_SET_LR( (CPC+4) );				        \
}
                 
DEFINST(BL,                     0x1,
        "bl",                   "j",
        IntALU,                 F_CTRL|F_UNCOND|F_DIRJMP|F_CALL,
        PPC_DLR,DNA,            DNA,DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)

        
                
#define BLA_IMPL                                              \
   {                                                          \
	 SET_TPC( SEXT26(LI) );                               \
	 SET_NPC( SEXT26(LI) );                               \
	 PPC_SET_LR( (CPC+4) );	                              \
   }

DEFINST(BLA,                    0x3,
        "bla",                  "j",
        IntALU,                 F_CTRL|F_UNCOND|F_DIRJMP|F_CALL,
        PPC_DLR,DNA,            DNA,DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)

CONNECT(CMP_LINK)


#define CMP_IMPL							\
   {									\
	sword_t _a, _b;							\
	word_t _c;							\
	word_t _mask;							\
	if(ISSETL) {							\
		DECLARE_FAULT(md_fault_invalidinstruction);             \
	}								\
	else{								\
		_a = GPR(RA);						\
		_b = GPR(RB);						\
		if(_a<_b) _c=0x8;					\
		else{ 							\
                if (_a>_b) _c=0x4;				        \
			else	  _c=0x2;				\
		}							\
		_c = _c | (PPC_GET_XER_SO);			       	\
		_c = _c << ( (7-CRFD)*4 );				\
		_mask = ~( 0xf << 4 * (7 - CRFD));			\
		PPC_SET_CR( (CR & _mask)  | _c);			\
	}								\
   }


DEFINST(CMP,			0x0,
	"cmp",			"r,l,a,b",
	IntALU,			F_ICOMP,
	PPC_DCR, DNA,		PPC_DGPR(RA), PPC_DGPR(RB), PPC_DCR,
        DNA, DNA, DNA,         	PPC_DXER, DNA)



#define	TW_IMPL							\
   {								\
   	sword_t _sa, _sb;					\
   	word_t _a, _b;						\
	_sa = GPR(RA);						\
	_sb = GPR(RB);						\
	_a = (word_t)GPR(RA);					\
	_b = (word_t)GPR(RB);					\
	if( (_sa < _sb) && (TO & 0x10) ) 			\
	{							\
		TRAP;						\
	}							\
	else if( (_sa > _sb) && (TO & 0x8) )                    \
        {                                                       \
                TRAP;                                           \
        }							\
	else if( (_sa == _sb) && (TO & 0x4) )                   \
        {                                                       \
                TRAP;                                           \
        }							\
	else  if( (_a < _b) && (TO & 0x2) )                   	\
        {                                                       \
                TRAP;                                           \
        }                                                       \
        else if( (_a > _b) && (TO & 0x1) )                    	\
        {                                                       \
                TRAP;                                           \
        }                                                       \
   }


DEFINST(TW,			0x8,
	"tw",			"t,a,b",
	IntALU,             	F_RR,
        DNA,DNA,                PPC_DGPR(RA), PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,         	DNA, DNA)


#define SUBFC_IMPL                                                   \
  {                                                                  \
			word_t _r;			             \
			_r = GPR(RB) - GPR(RA);			     \
			if (GPR(RA) == 0) PPC_SET_XER_CA; else {     \
	        	if( carrygenerated( (sword_t)GPR(RB), (-(sword_t) GPR(RA)) )){\
   	      	PPC_SET_XER_CA;                                      \
     	   	}                                                    \
      	  		else { PPC_RESET_XER_CA;}                    \
			}                                            \
        SET_GPR(RD, GPR(RB) - GPR(RA) );                             \
  }


DEFINST(SUBFC,                          0x10,
        "subfc",                        "d,a,b",
        IntALU,                         F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DGPR(RB),PPC_DXER,
        DNA, DNA, DNA,                  DNA, DNA)


#define SUBFCD_IMPL                                     \
  {                                                     \
    sword_t  _src;                                      \
    sword_t _ra,_rb;                                    \
    _ra = GPR(RA);                                      \
    _rb = GPR(RB);                                      \
                                                        \
    _src = _rb - _ra;               		        \
        if(!(_src)) PPC_SET_CR0_EQ;                     \
        else PPC_RESET_CR0_EQ;                          \
        if(_src>0) PPC_SET_CR0_GT;                      \
        else PPC_RESET_CR0_GT;                          \
        if(_src<0) PPC_SET_CR0_LT;                      \
        else PPC_RESET_CR0_LT;                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;              \
        else PPC_RESET_CR0_SO;                          \
        SET_GPR(RD, _src);                              \
        if(carrygenerated(_rb, (-_ra) ) ){		\
        PPC_SET_XER_CA;                                 \
        }                                               \
        else{ PPC_RESET_XER_CA;}                        \
	if (_ra == 0) PPC_SET_XER_CA;			\
  }

DEFINST(SUBFCD,                 0x11,
        "subfc.",               "d,a,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RD), PPC_DCR,  PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER, 
        PPC_DXER,DNA,DNA,       DNA,DNA)



#define SUBFCO_IMPL                                     \
  {                                                     \
	sword_t _ra,_rb;                        	\
        _ra = GPR(RA);                 			\
        _rb = GPR(RB);                          	\
         if (UNDER(_rb, _ra)){                          \
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
        SET_GPR(RD, (_rb - _ra));                       \
        if(carrygenerated( _rb, (-_ra) ) ){             \
        PPC_SET_XER_CA;                                 \
        }                                               \
        else{ PPC_RESET_XER_CA;}                        \
	if (_ra == 0) PPC_SET_XER_CA;                   \
  }

DEFINST(SUBFCO,                 	0x410,
        "subfco",               	"d,a,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER,
        DNA,DNA,DNA,            	DNA,DNA)
    

#define SUBFCOD_IMPL                                    \
  {                                                     \
        sword_t  _src;                                  \
   	sword_t _ra,_rb;                               	\
        _ra = GPR(RA);                                  \
        _rb = GPR(RB);                                  \
         if (UNDER(_rb, _ra)){                          \
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
         _src = _rb - _ra;                              \
        SET_GPR(RD, _src);                              \
        if(!(_src)) PPC_SET_CR0_EQ;                     \
        else PPC_RESET_CR0_EQ;                          \
        if(_src>0) PPC_SET_CR0_GT;                      \
        else PPC_RESET_CR0_GT;                          \
        if(_src<0) PPC_SET_CR0_LT;                      \
        else PPC_RESET_CR0_LT;                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;              \
        else PPC_RESET_CR0_SO;                          \
        if(carrygenerated(_rb, (- _ra) )){              \
        PPC_SET_XER_CA;                                 \
        }                                               \
        else                                            \
          { PPC_RESET_XER_CA;}                          \
        if (_ra == 0)                                   \
          PPC_SET_XER_CA;			        \
  }
        
DEFINST(SUBFCOD,                	0x411,   
        "subfco.",              	"d,a,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER,
        PPC_DCR,DNA,DNA,            	PPC_DCR,DNA)
  

#define LWZX_IMPL                                                       \
   {                                                                    \
    word_t _result;                                                     \
    enum md_fault_type _fault;                                          \
    if(RA==0)                                                           \
        {                                                               \
           _result = READ_WORD(GPR(RB), _fault);                        \
        }                                                               \
    else                                                                \
        {                                                               \
           _result = READ_WORD(GPR(RA)+GPR(RB), _fault);                \
        }                                                               \
        if (_fault != md_fault_none)                                    \
               DECLARE_FAULT(_fault);                                   \
        SET_GPR(RD, _result);                                           \
   }

       
DEFINST(LWZX,                   0x2E,
        "lwzx",                 "d,a,b",
        RdPort,                 F_MEM|F_LOAD|F_RR,
        PPC_DGPR(RD),DNA,       DNA, PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,        	DNA, DNA)


#define MFCR_IMPL						\
   {								\
	SET_GPR(RD, CR);					\
   }


DEFINST(MFCR,			0x26,
	"mfcr",			"d",
	IntALU,			F_ICOMP,	
	PPC_DGPR(RD),DNA,	PPC_DCR,DNA,DNA,
        DNA, DNA, DNA,         	DNA, DNA)


//AFR:
#define LWARX_IMPL EXEC_LWARX //LWZX_IMPL

//AFR: changed LWARX to rdPort instead of IntALU
DEFINST(LWARX,			0x28,
	"lwarx",		"d,a,b",
	RdPort,			F_MEM|F_LOAD|F_RR,
	PPC_DGPR(RD),DNA,	DNA, PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,          DNA, DNA)


#define CMPL_IMPL                                               \
{								\
    unsigned int compare;   					\
    unsigned int mask;						\
    word_t ra, rb;						\
    if (0 == GET_L (inst)) {   				        \
        /* 32-bit values */					\
        ra = GPR(RA); rb = GPR(RB);			        \
        if (ra > rb)						\
            compare = CR_GT_BIT;				\
        else if (ra < rb)				        \
            compare = CR_LT_BIT;				\
        else		                                        \
            compare = CR_EQ_BIT;				\
    } else {	                                                \
        /* 64-bit values */					\
        printf("STDOUT: ERROR!!! 64 bit unimplemented!\n");     \
        exit(1);                                                \
    }	                                                        \
    /* compare = compare | P->xer.SO; */                        \
    compare = compare | (PPC_GET_XER_SO);                       \
    compare = compare << 4 * (7 - GET_BF(inst) );               \
    mask = ~( 0xf << 4 * (7 - GET_BF(inst) ));	                \
    /* P->cr = ( P->cr & mask ) | compare; */                   \
    PPC_SET_CR( (CR & mask) | compare);                         \
}


DEFINST(CMPL,                   0x40,
        "cmpl",                 "r,l,a,b",
        IntALU,                 F_ICOMP,
        PPC_DCR, DNA,           PPC_DGPR(RA), PPC_DGPR(RB), PPC_DCR,
        DNA, DNA, DNA,        	DNA, DNA)



#define DCBST_IMPL                                              \
   {                                                            \
	if(RA==0){						\
        	EXEC_DCBST(GPR(RB));                            \
	}							\
	else{							\
        	EXEC_DCBST(GPR(RA)+GPR(RB));                    \
	}							\
   }

DEFINST(DCBST,                  0x6C,
        "dcbst",                "a,b",
        IntALU, 	        F_RR,
        DNA,DNA,                PPC_DGPR(RA),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,         	DNA, DNA)


#define LWZUX_IMPL                                                      \
   {                                                                    \
    word_t _result;                                                     \
    enum md_fault_type _fault;                                          \
    if(RA==0||(RA==RD))                                                 \
        {                                                               \
           DECLARE_FAULT(md_fault_invalidinstruction);                  \
        }                                                               \
    else{                                                               \
           _result = READ_WORD(GPR(RA)+GPR(RB), _fault);                \
           if (_fault != md_fault_none)                                 \
                   DECLARE_FAULT(_fault);                               \
           SET_GPR(RD, _result);                                        \
           SET_GPR(RA, GPR(RA)+GPR(RB));                                \
        }                                                               \
   }
        

DEFINST(LWZUX,                  	0x6E,
        "lwzux",                	"d,a,b",
        RdPort,                 	F_MEM|F_LOAD|F_RR,
        PPC_DGPR(RD),PPC_DGPR(RA),      DNA, PPC_DGPR(RA), DNA,
        DNA, DNA, DNA,        		DNA, DNA)


#define LBZX_IMPL							\
   {									\
     byte_t _result;                                                    \
     enum md_fault_type _fault;                                         \
                                                                        \
     if(RA==0){                                                         \
                _result = READ_BYTE(GPR(RB),_fault);                    \
        }                                                               \
     else{                                                              \
                 _result = READ_BYTE(GPR(RA) + GPR(RB), _fault);        \
        }                                                               \
	if(_fault!=md_fault_none)                               	\
        	DECLARE_FAULT(_fault);                          	\
        SET_GPR(RD,(word_t)_result);                            	\
  }

DEFINST(LBZX,                   0xAE,
        "lbzx",                 "d,a,b",
        RdPort,                 F_MEM|F_LOAD|F_RR,
        PPC_DGPR(RD),DNA,       DNA, PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,        	DNA, DNA)


#define DCBI_IMPL						\
{								\
    if(RA==0){                                                  \
        EXEC_DCBI(GPR(RB));				        \
    }                                                           \
    else{                                                       \
        EXEC_DCBI(GPR(RA)+GPR(RB));                             \
    }                                                           \
}

DEFINST(DCBI,			0x3AC,
	"dcbi",			"a,b",
	IntALU,			F_RR,
	DNA,DNA,		PPC_DGPR(RA),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,          DNA, DNA)

#define DCBF_IMPL						\
   {								\
        if(RA==0){                                              \
         EXEC_DCBF(GPR(RB));				        \
       }                                                        \
       else{                                                    \
         EXEC_DCBF(GPR(RA)+GPR(RB));                            \
      }                                                         \
   }

DEFINST(DCBF,			0xAC,
	"dcbf",			"a,b",
	IntALU,			F_RR,
	DNA,DNA,		PPC_DGPR(RA),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,          DNA, DNA)


#define LVX_IMPL                                                  \
  {                                                               \
    md_fault_type _fault;					  \
    simAddress _tmemEA;						  \
    if (RA==0) {						  \
      _tmemEA = GPR(RB);					  \
    } else {							  \
      _tmemEA = GPR(RA)+GPR(RB);				  \
    }								  \
    for (int i = 0; i < altivecWordSize; ++i) {			  \
      IF_CMMT(word_t res = READ_WORD(_tmemEA+(i<<2), _fault));	  \
      SET_VR(RD, i, res);					  \
    }								  \
    if (_fault != md_fault_none)                                  \
      DECLARE_FAULT(_fault);                                      \
  }
 

 DEFINST(LVX,                  0xCE,
	 "lvx",                "d,a,b",
	 RdPort,               F_MEM|F_LOAD|F_RR|F_VEC,
	 PPC_VR(RD),DNA,     DNA, PPC_DGPR(RA), PPC_DGPR(RB),
	 DNA, DNA, DNA,       	DNA, DNA)

#define LBZUX_IMPL                                                      \
   {                                                                    \
     byte_t _result;                                                    \
     enum md_fault_type _fault;                                         \
                                                                        \
     if((RA==0)||(RA==RD)){                                             \
                DECLARE_FAULT(md_fault_invalidinstruction);             \
        }                                                               \
     else{                                                              \
                _result = READ_BYTE(GPR(RA) + GPR(RB), _fault);         \
                if (_fault != md_fault_none)                            \
                DECLARE_FAULT(_fault);                                  \
                SET_GPR(RD, (word_t)_result);                           \
	 	SET_GPR(RA, GPR(RA) + GPR(RB));                        	\
        }                                                               \
   }

DEFINST(LBZUX,                  	0xEE,
        "lbzux",                 	"d,a,b",
        RdPort,                 	F_MEM|F_LOAD|F_RR,
        PPC_DGPR(RA),PPC_DGPR(RD),	DNA, PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,        		DNA, DNA)




#define MTCRF_IMPL                                          \
{                                                           \
    word_t _m,_crm, _c, _a;				    \
    int _i, _b, _d;					    \
    _crm = CRM;						    \
    _d = GPR(RS);					    \
    for (_i = 0; _i < 8; _i++) {			    \
	_b = (_crm >> _i) & 0x1;			    \
	if (_b == 1) {					    \
	   _c = CR;					    \
	    _a = (_d >> (_i*4) ) & 0xf;			    \
	    _m = (0xf << ( (_i)*4) );			    \
	    PPC_SET_CR( (_c & ~_m) | (_a << ((_i)*4)) );    \
	}						    \
    }							    \
}


DEFINST(MTCRF,                  0x120,   
        "mtcrf",                "R,s",   
        IntALU,                 F_ICOMP,
        PPC_DCR,DNA,           	PPC_DGPR(RS),DNA,DNA,
        DNA, DNA, DNA,         	DNA, DNA)



#define STWX_IMPL                                                       \
   {                                                                    \
    word_t _src;                                                        \
    enum md_fault_type _fault;                                          \
    _src = (word_t)GPR(RS);                                     	\
                                                                        \
    if(RA==0){                                                          \
            WRITE_WORD(_src, GPR(RB), _fault);                          \
        }                                                               \
    else{                                                               \
            WRITE_WORD(_src, GPR(RA) + GPR(RB), _fault);                \
        }                                                               \
    if (_fault != md_fault_none)                                        \
           DECLARE_FAULT(_fault);                                       \
   }

DEFINST(STWX,                  0x12E,
        "stwx",                "s,a,b",
        WrPort,                F_MEM|F_STORE|F_RR,
        DNA,DNA,               PPC_DGPR(RS),PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,         DNA, DNA)


#define STWCXD_IMPL EXEC_STWCXD

//AFR: changed STWCXD to WrPort instead of IntALU, changed flags
DEFINST(STWCXD,                 0x12D,
        "stwcx.",               "s,a,b",
        WrPort,                 F_MEM|F_STORE|F_RR,
        PPC_DCR,DNA,   PPC_DGPR(RS),PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,         	PPC_DCR, DNA)




#define STWUX_IMPL                                                      \
   {                                                                    \
    word_t _src;                                                        \
    enum md_fault_type _fault;                                          \
                                                                        \
    if(RA==0){                                                          \
                 DECLARE_FAULT(md_fault_invalidinstruction);            \
        }                                                               \
    else{                                                               \
            _src = (word_t)GPR(RS);                             	\
            WRITE_WORD(_src, GPR(RA) + GPR(RB), _fault);                \
            if (_fault != md_fault_none)                                \
                DECLARE_FAULT(_fault);                                  \
             SET_GPR(RA, GPR(RA)+GPR(RB));                              \
        }                                                               \
   }

DEFINST(STWUX,                  0x16E,
        "stwux",                "s,a,b",
        WrPort,                 F_MEM|F_STORE|F_RR,
        PPC_DGPR(RA),DNA,       PPC_DGPR(RS),PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,        	DNA, DNA)

#define STBX_IMPL                                                       \
   {                                                                    \
        byte_t  _src;                                                   \
        enum md_fault_type _fault;                                      \
        _src=(byte_t)(word_t)GPR(RS);                                   \
        if(RA==0){                                                      \
                 WRITE_BYTE(_src, GPR(RB), _fault);                     \
        }                                                               \
        else{                                                           \
             WRITE_BYTE( _src, GPR(RA)+GPR(RB), _fault);                \
        }                                                               \
        if (_fault != md_fault_none)                                    \
                DECLARE_FAULT(_fault);                                  \
   }
   
DEFINST(STBX,                   0x1AE,
        "stbx",                 "s,a,b",
        WrPort,                 F_MEM|F_STORE|F_RR,
        DNA,DNA,                PPC_DGPR(RS),PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,        	DNA, DNA)


#define STVX_IMPL				                  \
  {								  \
    md_fault_type _fault;					  \
    simAddress _tmemEA;						  \
    if (RA==0) {						  \
      _tmemEA = GPR(RB);					  \
    } else {							  \
      _tmemEA = GPR(RA)+GPR(RB);			          \
    }								  \
    for (int i = 0; i < altivecWordSize; ++i) {			  \
      WRITE_WORD(VR(RS,i), _tmemEA+(i<<2), _fault);		  \
    }								  \
    if (_fault != md_fault_none)                                  \
      DECLARE_FAULT(_fault);                                      \
  }

DEFINST(STVX,                   0x1CE,
	"stv",                 "s,a,b",
	WrPort,                F_MEM|F_STORE|F_RR|F_VEC,
	DNA,DNA,               PPC_VR(RS),PPC_DGPR(RA),PPC_DGPR(RB),
	DNA,DNA,DNA,           DNA,DNA)

#define DCBTST_IMPL                                             \
   {                                                            \
	if(RA==0){						\
	        EXEC_DCBTST(GPR(RB));                           \
	}							\
	else{	        					\
		EXEC_DCBTST(GPR(RA)+GPR(RB));                   \
	}							\
   }
        
DEFINST(DCBTST,                 0x1EC,
        "dcbtst",               "a,b",
        IntALU,             	F_RR,
        DNA, DNA,               PPC_DGPR(RA),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,          DNA, DNA)



#define STBUX_IMPL                                                      \
   {                                                                    \
        byte_t  _src;                                                   \
        enum md_fault_type _fault;                                      \
        if(RA==0){                                                      \
                 DECLARE_FAULT(md_fault_invalidinstruction);            \
        }                                                               \
        else{                                                           \
             _src=(byte_t)(word_t)GPR(RS);                              \
             WRITE_BYTE( _src, GPR(RA)+GPR(RB), _fault);                \
             if (_fault != md_fault_none)                               \
                DECLARE_FAULT(_fault);                                  \
		SET_GPR(RA, GPR(RA)+GPR(RB));                           \
        }                                                               \
   }

DEFINST(STBUX,                  0x1EE,
        "stbux",                "s,a,b",
        WrPort,                 F_MEM|F_STORE|F_RR, 
        PPC_DGPR(RA),DNA,       PPC_DGPR(RS),PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,        	DNA, DNA)




#define DCBT_IMPL                                               \
   {                                                            \
	if(RA==0){						\
        	EXEC_DCBT(GPR(RB));                             \
	}							\
	else{        						\
		EXEC_DCBT(GPR(RA)+GPR(RB));                     \
	}							\
   }

DEFINST(DCBT,                   0x22C,
        "dcbt",                 "a,b",
        IntALU,             	F_RR,
        DNA,DNA,                PPC_DGPR(RA),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,          DNA, DNA)

   


#define LHZX_IMPL                                                       \
   {                                                                    \
    half_t _result;                                                     \
    enum md_fault_type _fault;                                          \
    if(RA==0)                                                           \
        {                                                               \
           _result = READ_HALF(GPR(RB), _fault);                        \
        }                                                               \
    else                                                                \
        {                                                               \
           _result = READ_HALF(GPR(RA)+GPR(RB), _fault);                \
        }                                                               \
        if (_fault != md_fault_none)                                    \
                DECLARE_FAULT(_fault);                                  \
        SET_GPR(RD, (word_t)_result);                                   \
   }


DEFINST(LHZX,                   0x22E,
        "lhzx",                 "d,a,b",
        RdPort,                 F_MEM|F_LOAD|F_RR,
        PPC_DGPR(RD),DNA,       DNA, PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,        	DNA, DNA)



#define ECIWX_IMPL                                              \
{                                                               \
    IF_CMMT(word_t _result=0);                                  \
    enum md_fault_type _fault;                                  \
    printf("warning, ECIWX instr\n");		                \
    assert(0);                                                  \
    if(RA==0){                                                  \
        /*_result = EXEC_ECIWX(GPR(RB),_fault);*/               \
    }else{                                                      \
        /*_result = EXEC_ECIWX(GPR(RA) + GPR(RB), _fault);*/    \
    }                                                           \
    if (_fault != md_fault_none)                                \
        DECLARE_FAULT(_fault);                                  \
    SET_GPR(RD, (word_t)_result);                               \
}


DEFINST(ECIWX,                  0x26C, 
        "eciwx",                "d,a,b",
        IntALU,                 F_MEM,
        PPC_DGPR(RD),DNA,       PPC_DGPR(RA),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,         	DNA, DNA)





#define LHZUX_IMPL                                                      \
   {                                                                    \
    half_t _result;                                                     \
    enum md_fault_type _fault;                                          \
    if(RA==0||(RA==RD))                                                 \
        {                                                               \
           DECLARE_FAULT(md_fault_invalidinstruction);                  \
        }                                                               \
    else                                                                \
        {                                                               \
           _result = READ_HALF(GPR(RA)+GPR(RB), _fault);                \
           if (_fault != md_fault_none)                                 \
                DECLARE_FAULT(_fault);                                  \
           SET_GPR(RD, (word_t)_result);	                        \
           SET_GPR(RA, GPR(RA)+GPR(RB));                                \
        }                                                               \
   }


DEFINST(LHZUX,                  	0x26E,
        "lhzux",                	"d,a,b",
        RdPort,                 	F_MEM|F_LOAD|F_RR,
        PPC_DGPR(RD),PPC_DGPR(RA),      DNA, PPC_DGPR(RA),DNA,
        DNA, DNA, DNA,        		DNA, DNA)



/*FixMe: What to do with the error handler here */
//#warning Need to Fix MFSPR time register reading
#define MFSPR_IMPL                                              \
   {                                                            \
	word_t _s, _d;						\
	_s = SPR;						\
	_d = (_s & 0x1F) + (( _s >> 5)&0x1F);			\
	if (_d ==1)						\
	{							\
		SET_GPR(RD, XER);				\
	}							\
	else if (_d ==8)                                        \
        {                                                       \
                SET_GPR(RD, LR); 	                        \
        }                                                       \
        else if (_d == 9)                                       \
        {                                                       \
                SET_GPR(RD, CNTR);                              \
        }                                                       \
        else if (_d == 21)                                      \
        {                                                       \
	  /*SET_GPR(RD, proc->TimeStamp()>>32);*/		\
        }                                                       \
        else if (_d == 20)                                      \
        {                                                       \
	  /*SET_GPR(RD, proc->TimeStamp()&0xffffffff);*/	\
        }                                                       \
	else{							\
	/*Error handler is invoked here*/			\
	}                                                       \
   }
        
    
DEFINST(MFSPR,                 0x2A6,
        "mfspr",               "d,P",
        IntALU,                F_ICOMP, 
        PPC_DGPR(RD),DNA,      PPC_DXER_LR_CNTR(SPRVAL),DNA,DNA,
        DNA, DNA, DNA,         DNA, DNA)




#define LHAX_IMPL                                                      	\
   {                                                                    \
    shalf_t _result;                                                    \
    enum md_fault_type _fault;                                          \
    if(RA==0){                                              		\
	 _result = READ_HALF(GPR(RB), _fault);                  	\
        }                                                               \
    else{                                                               \
        _result = READ_HALF(GPR(RA)+GPR(RB), _fault);                   \
        }                                                               \
	if (_fault != md_fault_none)                                	\
		DECLARE_FAULT(_fault);                                  \
        SET_GPR(RD, (word_t)(sword_t)_result);                       	\
   }
        
        
DEFINST(LHAX,                   0x2AE,
        "lhax",                 "d,a,b",
        RdPort,                 F_MEM|F_LOAD|F_RR,
        PPC_DGPR(RD),DNA,	DNA, PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,        	DNA, DNA)

#define MFTB_IMPL {                                               \
    word_t _n ;                                                   \
    _n = ((RB << 5) | RA) ;                                       \
    if (_n == 268) {                                              \
        SET_GPR(RD, (TBR & 0x00000000ffffffffll)) ;               \
    }                                                             \
    else if (_n == 269) {                                         \
        SET_GPR(RD, ((TBR & 0xffffffff00000000ll) >> 32)) ;       \
    }                                                             \
    else {                                                        \
        printf ("Incorrect value for tbr.\n") ;                   \
    }                                                             \
}

DEFINST(MFTB, 0x2E6, 
        "mftb", "t", IntALU, F_ICOMP,
        PPC_DGPR(RD), DNA,      DNA, DNA, DNA,
        DNA, DNA, DNA,          DNA, DNA)

#define LHAUX_IMPL                                                      \
   {                                                                    \
    shalf_t _result;                                                    \
    enum md_fault_type _fault;                                          \
    if((RA==0)||(RA==RD)){                                              \
                DECLARE_FAULT(md_fault_invalidinstruction);             \
        }                                                               \
    else{                                                               \
        _result = READ_HALF(GPR(RA)+GPR(RB), _fault);                   \
            if (_fault != md_fault_none)                                \
                DECLARE_FAULT(_fault);                                  \
           SET_GPR(RD, (word_t)(sword_t)_result);                       \
           SET_GPR(RA, GPR(RA) + GPR(RB));                              \
        }                                                               \
   }
        

DEFINST(LHAUX,                  	0x2EE,
        "lhaux",                	"d,a,b",
        RdPort,                 	F_MEM|F_LOAD|F_RR,
        PPC_DGPR(RD),PPC_DGPR(RA),      DNA, PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,        		DNA, DNA)
   
    
  

#define STHX_IMPL                                                      	\
   {                                                                    \
    half_t _src;                                                        \
    enum md_fault_type _fault;                                          \
    _src = (half_t)(word_t)GPR(RS);                             	\
                                                                        \
    if(RA==0){                                                          \
            WRITE_HALF(_src, GPR(RB), _fault);                		\
        }                                                               \
    else{                                                               \
            WRITE_HALF(_src, GPR(RA) + GPR(RB), _fault);                \
        }                                                               \
    if (_fault != md_fault_none)                                	\
           DECLARE_FAULT(_fault);                                  	\
   }
        
DEFINST(STHX,                  0x32E,
        "sthx",                "s,a,b",
        WrPort,                F_MEM|F_STORE|F_RR,  
        DNA,DNA, 	       PPC_DGPR(RS),PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,         DNA, DNA)


/*FixMe: The functional unit class and the instruction unit flags
need to be checked*/
   



#define ECOWX_IMPL                                                   \
{                                                                    \
    IF_CMMT(word_t _result=0);                                       \
    enum md_fault_type _fault;                                       \
    printf("warning, ECOWX instr\n");			             \
    assert(0);                                                       \
    if(RA==0){                                                       \
        /*_result = EXEC_ECOWX(GPR(RS),GPR(RB),_fault);*/            \
        }                                                            \
    else{                                                            \
        /*_result = EXEC_ECOWX(GPR(RS),GPR(RA) + GPR(RB),_fault);*/  \
    }                                                                \
    if (_fault != md_fault_none)                                     \
        DECLARE_FAULT(_fault);                                       \
    SET_GPR(RS, (word_t)_result);                                    \
}
  
DEFINST(ECOWX,                  0x36C,
        "ecowx",                "s,a,b",
        IntALU,                 F_MEM,
        DNA, DNA,               PPC_DGPR(RA),PPC_DGPR(RB),PPC_DGPR(RS),
        DNA, DNA, DNA,          DNA, DNA)


#define STHUX_IMPL                                                      \
{                                                                       \
    half_t _src;                                                        \
    enum md_fault_type _fault;                                          \
                                                                        \
    if(RA==0){                                                          \
        DECLARE_FAULT(md_fault_invalidinstruction);                     \
    }                                                                   \
    else{                                                               \
        _src = (half_t)(word_t)GPR(RS);                                 \
        WRITE_HALF(_src, GPR(RA) + GPR(RB), _fault);                    \
        if (_fault != md_fault_none)                                    \
            DECLARE_FAULT(_fault);                                      \
        SET_GPR(RA, GPR(RA)+GPR(RB));				        \
    }                                                                   \
}

        
DEFINST(STHUX,                  0x369,
        "sthux",                "s,a,b",
        WrPort,                 F_MEM|F_STORE|F_RR,
        PPC_DGPR(RA),DNA,       PPC_DGPR(RS),PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,        	DNA, DNA)

        



/*FixMe: What to do with the error handler here */

#define MTSPR_IMPL                                              \
   {                                                            \
        word_t _s, _d;                                          \
        _s = SPR;                                               \
        _d = (_s & 0x1f) + (( _s >> 5)&0x1F);                   \
        if (_d ==1)                                             \
        {                                                       \
                PPC_SET_XER(GPR(RD));                           \
        }                                                       \
        else if (_d ==8)                                        \
        {                                                       \
                PPC_SET_LR(GPR(RD));                            \
        }                                                       \
        else if (_d == 9)                                       \
        {                                                       \
                PPC_SET_CNTR(GPR(RD));                          \
        }                                                       \
        else{                                                   \
        /*Error handler is invoked here*/                       \
        }                                                       \
   }
    
    
DEFINST(MTSPR,                          0x3A6,
        "mtspr",                        "p, s",
        IntALU,                         F_ICOMP,  
        PPC_DXER_LR_CNTR(SPRVAL), DNA,	PPC_DGPR(RS),DNA,DNA,
        DNA, DNA, DNA,                  DNA, DNA)


#define SYNC_IMPL                                               \
   {                                                            \
        EXEC_SYNC;                                              \
   }

/* Note: Not sure about the functional unit, but put int, so as not to
   confuse ssBackend */

DEFINST(SYNC,                  0x4AC,
        "sync",                "",
        IntALU,                F_SYNC,
        DNA,DNA,               DNA,DNA,DNA,
        DNA, DNA, DNA,         DNA, DNA)





#define MCRXR_IMPL                                              \
   {                                                            \
	word_t _src, _m, _c;					\
	_src = (XER >> 28) & 0xf;				\
	_src = _src << ( (7-CRFD)*4 );				\
	PPC_SET_XER(XER & 0x0fffffff);				\
	_m = 0xf << ( (7-CRFD)*4 );				\
	_c = CR;						\
	PPC_SET_CR( (_c & (~(_m))) | _src );			\
   }
        
DEFINST(MCRXR,                  0x400,
        "mcrxr",                "r",
        IntALU,                 F_ICOMP,
        PPC_DCR,PPC_DXER,      	PPC_DCR,PPC_DXER,DNA,
        DNA, DNA, DNA,         	DNA, DNA)



#define LSWX_IMPL                               \
   {                                            \
        sword_t _ea;                            \
        word_t _n, _r,_i, _val;                 \
        byte_t _result;                         \
        enum md_fault_type _fault;              \
        if(RA==0){                              \
                _ea=GPR(RB);                    \
        }                                       \
        else _ea= GPR(RA)+GPR(RB);              \
                                                \
        _n = XER & 0xff;     	                \
                                                \
        _r=RD;                                  \
        _i = 0;                                 \
		  SET_GPR(_r, 0x0);	        \
        while(_n>0){                            \
                if(_i==32){                     \
                        _r = (_r+1)%32;         \
                        SET_GPR(_r,0x0);        \
                        _i=0;                   \
                }                               \
        _val=GPR(_r);                           \
         _result = READ_BYTE(_ea, _fault);      \
        if (_fault != md_fault_none)            \
               DECLARE_FAULT(_fault);           \
        _val = _val |( ((word_t)_result)<<( 24 - _i));\
        SET_GPR(_r,_val);                       \
        _i=_i+8;                                \
        _ea++;                                  \
        _n--;                                   \
        }                                       \
   }

DEFINST(LSWX,                   0x42A,
        "lswx",                 "d,a,b",
        RdPort,                 F_MEM|F_LOAD|F_RR,
        DNA,DNA, 	        DNA, PPC_DGPR(RA),PPC_DGPR(RB),
        DNA,DNA,DNA,        PPC_DXER,DNA)



#define LWBRX_IMPL                                                \
   {                                                              \
     byte_t _src1, _src2, _src3, _src4;                           \
     enum md_fault_type _fault;                                   \
     sword_t _ea;					          \
     if(RA==0){                                                   \
	_ea= GPR(RB);					          \
        }                                                         \
     else{                                                        \
	_ea=GPR(RA)+GPR(RB);				          \
	}						          \
        _src1 = READ_BYTE(_ea, _fault);          	          \
     if (_fault != md_fault_none)                                 \
           DECLARE_FAULT(_fault);                                 \
        _src2 = READ_BYTE(_ea+1, _fault);                   	  \
     if (_fault != md_fault_none)                                 \
           DECLARE_FAULT(_fault);                                 \
        _src3 = READ_BYTE(_ea+2, _fault);                   	  \
     if (_fault != md_fault_none)                                 \
           DECLARE_FAULT(_fault);                                 \
        _src4 = READ_BYTE(_ea+3, _fault);                         \
     if (_fault != md_fault_none)                                 \
           DECLARE_FAULT(_fault);                                 \
     								  \
     /* AFR: changed || to | */	                                  \
     SET_GPR(RD,( ((word_t)_src1) | (((word_t)_src2) << 8) | (((word_t)_src3) << 16) | (((word_t)_src4) << 24) ) ); \
   }    
    
DEFINST(LWBRX,                  0x42C,
        "lwbrx",                "d,a,b",
        RdPort,                 F_MEM|F_LOAD|F_RR,
        PPC_DGPR(RD),DNA,       DNA, PPC_DGPR(RA),PPC_DGPR(RA),
        DNA, DNA, DNA,        	DNA, DNA)


#define LFSX_IMPL                                                       \
   {                                                                    \
     word_t _result;                                                    \
     enum md_fault_type _fault;                                         \
     dfloat_t _da;							\
     if(RA==0){                                                         \
                _result = READ_WORD(GPR(RB),_fault);			\
        }                                                               \
     else{                                                              \
                 _result = READ_WORD(GPR(RA) + GPR(RB), _fault);	\
        }                                                               \
                if (_fault != md_fault_none)                            \
                DECLARE_FAULT(_fault);                                  \
                _da =(dfloat_t)( *((sfloat_t*)(&_result)));             \
                PPC_SET_FPR_D(RD, _da);                                 \
   }


DEFINST(LFSX,                   0x42E,
        "lfsx",                 "D,a,b",
        RdPort,                 F_MEM|F_LOAD|F_RR,
        PPC_DFPR(FD),DNA,       DNA, PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,        	DNA, DNA)




#define LFSUX_IMPL                                                      \
   {                                                                    \
     word_t _result;                                                    \
     enum md_fault_type _fault;                                         \
     dfloat_t _da;							\
     if(RA==0){                                                         \
                DECLARE_FAULT(md_fault_invalidinstruction);             \
     }                                                                  \
     else{                                                              \
                _result = READ_WORD(GPR(RA) + GPR(RB), _fault);         \
                if (_fault != md_fault_none)                            \
                DECLARE_FAULT(_fault);                                  \
		_da =(dfloat_t)( *((sfloat_t*)(&_result)));		\
        	PPC_SET_FPR_D(RD, _da);                                	\
                SET_GPR(RA, GPR(RA) + GPR(RB));                         \
        }                                                               \
   }
                 

DEFINST(LFSUX,                  	0x46E,
        "lfsux",                	"D,a,b",
        RdPort,                 	F_MEM|F_LOAD|F_RR,
        PPC_DFPR(FD),PPC_DGPR(RA),     DNA, PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,        		DNA, DNA)


#define LSWI_IMPL				\
   {						\
	sword_t _ea;				\
	word_t _n, _r,_i, _val;			\
	byte_t _result;				\
    	enum md_fault_type _fault;		\
	if(RA==0){				\
		_ea=0;				\
	}					\
	else _ea= GPR(RA);			\
						\
	if(NB==0) _n = 32;			\
	else _n=NB;				\
						\
	_r=RD;					\
	_i = 0;					\
	SET_GPR(_r, 0);		\
	while(_n>0){				\
		if(_i==32){			\
			_r = (_r+1)%32;		\
			SET_GPR(_r,0x0);	\
			_i=0;			\
		}				\
	_val=GPR(_r);				\
         _result = READ_BYTE(_ea, _fault);	\
        if (_fault != md_fault_none)	{	\
               DECLARE_FAULT(_fault);		\
			} 						\
	_val = _val |( ((word_t)_result)<<( 24 - _i));\
	SET_GPR(_r,_val);			\
	_i=_i+8;				\
	_ea++;					\
	_n--;					\
	}					\
   }

DEFINST(LSWI,			0x4AA,
	"lswi",			"d,a,N",
	RdPort,			F_MEM|F_LOAD|F_RR,
	DNA,DNA,		DNA, PPC_DGPR(RA),DNA,
	DNA,DNA,DNA,	DNA,DNA)




#define LFDX_IMPL                                                       \
  {                                                                     \
    enum md_fault_type _fault;                                          \
    sword_t _ea;							\
    qword_t _res;                                                       \
    if(RA==0) _ea = GPR(RB);                                            \
    else      _ea = GPR(RA) + GPR(RB);                             	\
                                                                        \
    _res = READ_DOUBLE(_ea, _fault);					\
    if (_fault != md_fault_none)					\
      DECLARE_FAULT(_fault);						\
    PPC_SET_FPR_DW(FD, _res);                                               \
  }
   
   
DEFINST(LFDX,                   0x4AE,
        "lfdx",                 "D,a,b",
        RdPort,                 F_MEM|F_LOAD|F_RR,
        PPC_DFPR(FD), DNA,      DNA, PPC_DGPR(RA), PPC_DGPR(RB), 
        DNA, DNA, DNA,        	DNA, DNA)




#define LFDUX_IMPL                                                      \
  {                                                                     \
    word_t _result_hi, _result_lo;                                      \
    enum md_fault_type _fault;                                          \
    sword_t _ea;   							\
    qword_t _res;                                                 	\
    if(RA==0){                                                          \
                DECLARE_FAULT(md_fault_invalidinstruction);             \
     }                                                                  \
    else{                                                               \
                _ea = GPR(RA) + GPR(RB);                           	\
                                                                        \
                _result_hi = READ_WORD(_ea, _fault);                    \
                if (_fault != md_fault_none)                            \
                        DECLARE_FAULT(_fault);                          \
                 _result_lo = READ_WORD(_ea + 4, _fault);               \
                if (_fault != md_fault_none)                            \
                         DECLARE_FAULT(_fault);                         \
                _res = ((qword_t)_result_hi)<<32;                 	\
                _res = _res || (qword_t) _result_lo;              	\
					 memcpy( (&_res), &_result_hi, sizeof(word_t) );         \
				    memcpy( (word_t *) (&_res)+1, &_result_lo, sizeof(word_t) ); \
                PPC_SET_FPR_DW(FD, _res);                               \
                SET_GPR(RA,_ea);                                        \
        }                                                               \
  }


DEFINST(LFDUX,                  	0x4EE,
        "lfdux",                	"D,a,b",
        RdPort,                 	F_MEM|F_LOAD|F_RR,
        PPC_DFPR(FD), PPC_DGPR(RA),     DNA, PPC_DGPR(RA), PPC_DGPR(RB), 
        DNA, DNA, DNA,        		DNA, DNA)





#define STSWX_IMPL                              \
   {                                            \
        sword_t _ea;                            \
        word_t _n, _r,_i, _val;                 \
        byte_t _result;                         \
        enum md_fault_type _fault;              \
        if(RA==0){                              \
                _ea=GPR(RB);                    \
        }                                       \
        else _ea= GPR(RA)+GPR(RB);              \
                                                \
        _n = XER & 0xff;                	\
                                                \
        _r=RD;                                  \
        _i = 0;                                 \
        while(_n>0){                            \
                if(_i==32){                     \
                        _r = (_r+1)%32;         \
                        _i=0;                   \
                }                               \
        _val = GPR(_r);                         \
        _result =(byte_t)( 0xff & (_val>>(24-_i)) );\
        WRITE_BYTE(_result, _ea, _fault);       \
        if (_fault != md_fault_none)            \
               DECLARE_FAULT(_fault);           \
        _i=_i+8;                                \
        _ea++;                                  \
        _n--;                                   \
        }                                       \
   }

DEFINST(STSWX,                  0x52A,
        "stswx",                "s,a,N",
        WrPort,                 F_MEM|F_STORE|F_RR,
        DNA,DNA,                PPC_DGPR(RS), PPC_DGPR(RA),DNA,
        DNA,DNA,DNA,            PPC_DXER, DNA )




#define STWBRX_IMPL                                                     \
   {                                                                    \
    word_t _src;                                                        \
    enum md_fault_type _fault;                                          \
    byte_t _src1, _src2, _src3, _src4;                                  \
    _src1 =(byte_t)( (word_t)(GPR(RS)) & 0xff );                        \
    _src2 =(byte_t)( ((word_t)(GPR(RS)) & 0xff00)>>8 );                 \
    _src3 =(byte_t)( ((word_t)(GPR(RS)) & 0xff0000)>>16 );              \
    _src4 =(byte_t)( ((word_t)(GPR(RS)) & 0xff000000)>>24 );            \
    /*AFR: changed || to | */						\
    _src = (((word_t)_src1)<<24) | (((word_t)_src2)<<16) | (((word_t)_src3)<<8) | ((word_t)_src4);\
    if(RA==0){                                                          \
                WRITE_WORD( _src, GPR(RB), _fault);                     \
        }                                                               \
    else{                                                               \
                WRITE_WORD( _src, GPR(RA)+GPR(RB), _fault);             \
    }                                                                   \
    if (_fault != md_fault_none)                            		\
	    DECLARE_FAULT(_fault);                          		\
  }

DEFINST(STWBRX,                 0x52C,
        "stwbrx",               "s,a,b",
        WrPort,                 F_MEM|F_STORE|F_RR,
        DNA,DNA,                PPC_DGPR(RS),PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,        	DNA, DNA)


#define STFSX_IMPL                                                  \
{                                                                   \
   enum md_fault_type _fault;                                       \
   IF_CMMT(float tempf);                                          \
   IF_CMMT(word_t *ptempf);                                       \
   IF_CMMT(double double_a);                                      \
   IF_CMMT(qword_t _d =PPC_FPR_DW(FS));                           \
   IF_CMMT(memcpy(&double_a,&_d,sizeof(double)));                 \
   IF_CMMT(tempf = (float)double_a);                              \
   IF_CMMT(ptempf = (word_t *) (&tempf));                         \
   if(RA==0){                                                       \
      WRITE_WORD(*ptempf, GPR(RA), _fault);                         \
   }                                                                \
   else{                                                            \
      WRITE_WORD(*ptempf, GPR(RA)+GPR(RB), _fault);                 \
   }                                                                \
   if (_fault != md_fault_none)                                     \
      DECLARE_FAULT(_fault);                                        \
}         
             

DEFINST(STFSX,                  0x52E,
        "stfsx",                "S,a,b",
        WrPort,                 F_MEM|F_STORE|F_RR,   
        DNA,DNA,                PPC_DFPR(FS),PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,        	DNA, DNA)





#define STFSUX_IMPL                                                  \
{                                                                    \
    enum md_fault_type _fault;                                       \
    IF_CMMT(float tempf);                                          \
    IF_CMMT(word_t *ptempf);                                       \
    IF_CMMT(qword_t _d =PPC_FPR_DW(FS));                           \
    IF_CMMT(double double_a);                                      \
    IF_CMMT(memcpy(&double_a, &_d, sizeof(double)));               \
    IF_CMMT(tempf  = (float) double_a);                            \
    IF_CMMT(ptempf = (word_t *) (&tempf));                         \
    WRITE_WORD(*ptempf, GPR(RA)+GPR(RB), _fault);                    \
    if (_fault != md_fault_none)                                     \
        DECLARE_FAULT(_fault);                                       \
    SET_GPR( RA, GPR(RA) + GPR(RB) );                                \
} 


DEFINST(STFSUX,                 0x56E,
        "stfsux",               "S,a,b",
        WrPort,                 F_MEM|F_STORE|F_RR,
        PPC_DGPR(RA),DNA,       PPC_DFPR(FS),PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,        	DNA, DNA)



#define STSWI_IMPL                                    \
{                                                     \
    sword_t _ea;                                      \
    word_t _n, _r,_i, _val;                           \
    byte_t _result;                                   \
    enum md_fault_type _fault;                        \
    if(RA==0)                                         \
        _ea=0;                                        \
    else                                              \
        _ea= GPR(RA);                                 \
                                                      \
    if(NB==0) _n = 32;                                \
    else      _n=NB;                                  \
                                                      \
    _r=RD;                                            \
    _i = 0;                                           \
    while(_n>0) {                                     \
        if(_i==32) {                                  \
            _r = (_r+1)%32;                           \
            _i=0;                                     \
        }                                             \
        _val = GPR(_r);                               \
        _result =(byte_t)( 0xff & (_val>>(24-_i)) );  \
        WRITE_BYTE(_result, _ea, _fault);      	      \
        if (_fault != md_fault_none) {                \
            DECLARE_FAULT(_fault);                    \
        }	                                      \
        _i=_i+8;                                      \
        _ea++;                                        \
        _n--;                                         \
    }                                                 \
}

DEFINST(STSWI,                  0x5AA,
        "stswi",                "s,a,N",
        WrPort,                 F_MEM|F_STORE|F_RR,
        DNA,DNA,                PPC_DGPR(RS), PPC_DGPR(RA),DNA, 
	DNA,DNA,DNA,	        DNA, DNA )




#define STFDX_IMPL                                      \
{                                                       \
    enum md_fault_type _fault;                          \
    sword_t _ea;					\
    if(RA==0) {                                         \
        _ea=GPR(RB);					\
    } else{                                             \
        _ea=GPR(RA)+GPR(RB);				\
    } 							\
    WRITE_WORD((PPC_FPR_UW(FS)), _ea, _fault);		\
    if (_fault != md_fault_none)                        \
        DECLARE_FAULT(_fault);                          \
    WRITE_WORD((PPC_FPR_W(FS)), _ea+4, _fault);		\
    if (_fault != md_fault_none)                        \
        DECLARE_FAULT(_fault);                          \
}
    
  
DEFINST(STFDX,            0x5AE,
        "stfdx",          "S,a,b",
        WrPort,           F_MEM|F_STORE|F_RR,
        DNA,DNA,          PPC_DFPR(FS),PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,    DNA, DNA)




#define STFDUX_IMPL                                                 \
{                                                                   \
    enum md_fault_type _fault;                                      \
    if(RA==0){                                                      \
        DECLARE_FAULT(md_fault_invalidinstruction);                 \
    } else {                                                        \
        WRITE_WORD( (PPC_FPR_UW(FS)), GPR(RA)+GPR(RB), _fault);	    \
        if (_fault != md_fault_none)                                \
            DECLARE_FAULT(_fault);                                  \
        WRITE_WORD( (PPC_FPR_W(FS)), GPR(RA)+GPR(RB)+4, _fault);    \
        if (_fault != md_fault_none)                                \
            DECLARE_FAULT(_fault);                                  \
        SET_GPR(RA, GPR(RA)+GPR(RB));                               \
    }                                                               \
}
        
        
DEFINST(STFDUX,                 0x5EE,
        "stfdux",               "S,a,b",
        WrPort,                 F_MEM|F_STORE|F_RR,
        PPC_DGPR(RA),DNA,       PPC_DFPR_DW(FS),PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,        	DNA, DNA)



#define LHBRX_IMPL						    \
{								    \
    byte_t _src1, _src2;					    \
    enum md_fault_type _fault;                                      \
    sword_t _ea;						    \
    if(RA!=0){                                                      \
        _ea=GPR(RA)+GPR(RB);					    \
    } else {                                                        \
        _ea=0+GPR(RB);					            \
    }								    \
    _src1 = READ_BYTE(_ea, _fault);                     	    \
    if (_fault != md_fault_none)                                    \
        DECLARE_FAULT(_fault);                                      \
    _src2 = READ_BYTE(_ea+1, _fault);                   	    \
    if (_fault != md_fault_none)                                    \
        DECLARE_FAULT(_fault);                                      \
    /* AFR: || -> |*/						    \
    SET_GPR(RD,( ((word_t)_src1) | (((word_t)_src2) << 8) ) );	    \
}

DEFINST(LHBRX,			0x62C,
	"lhbrx",		"d,a,b",
	RdPort,			F_MEM|F_LOAD|F_RR,
	PPC_DGPR(RD),DNA,	DNA, PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,        	DNA, DNA)


/* For now, EIEIO is treated like SYNC. This is not correct, but close
   enough for now.*/

#define EIEIO_IMPL						\
   {								\
	EXEC_EIEIO;						\
   }

DEFINST(EIEIO,			0x6AC,
	"eieio",		"",
	IntALU,		        F_SYNC,
	DNA,DNA,		DNA,DNA,DNA,
        DNA, DNA, DNA,         	DNA, DNA)


  
#define STHBRX_IMPL							\
   {									\
    half_t _src;							\
    enum md_fault_type _fault;						\
    byte_t _src1, _src2;						\
    _src1 =(byte_t)( (word_t)(GPR(RS)) & 0xff );			\
    _src2 =(byte_t)( ((word_t)(GPR(RS)) & 0xff00)>>8 );			\
    /* AFR: || -> | */							\
    _src = (((half_t)_src1)<<8) | ((half_t)_src2); 			\
    if(RA==0){								\
		WRITE_HALF( _src, GPR(RB), _fault);			\
	}								\
    else{								\
		WRITE_HALF( _src, GPR(RA)+GPR(RB), _fault);             \
    }									\
    if (_fault != md_fault_none)                            		\
	    DECLARE_FAULT(_fault);                          		\
   }

DEFINST(STHBRX,			0x72C,
	"sthbrx",		"s,a,b",
	WrPort,			F_MEM|F_STORE|F_RR,
	DNA,DNA,		PPC_DGPR(RS),PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,        	DNA, DNA)



#define ICBI_IMPL                                               \
   {                                                            \
	if(RA==0){						\
		EXEC_ICBI(GPR(RB));                     	\
	}							\
        else{							\
		EXEC_ICBI(GPR(RA)+GPR(RB));                     \
	} 							\
  }    

DEFINST(ICBI,                   0x7AC,
        "icbi",                 "a,b",
        IntALU,             	F_RR,
        DNA,DNA,                PPC_DGPR(RA),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,          DNA, DNA)



#define DCBZ_IMPL                                               \
   {                                                            \
	if(RA==0){						\
	        EXEC_DCBZ(GPR(RB));                     	\
	}							\
	else{	        					\
		EXEC_DCBZ((GPR(RA)+GPR(RB)));                     \
	}							\
   }    	
    
//AFR: opcode was 0x3ec
DEFINST(DCBZ,                   0x7EC,
        "dcbz",                 "a,b",
        IntALU,             	F_RR,
        DNA,DNA,                PPC_DGPR(RA),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,          DNA, DNA)



#define STFIWX_IMPL						\
   {								\
        enum md_fault_type _fault;				\
        if(RA==0){						\
                 WRITE_WORD((PPC_FPR_UW(FS)), GPR(RB), _fault);	\
                }						\
        else{							\
             WRITE_WORD((PPC_FPR_UW(FS)),GPR(RA)+GPR(RB),_fault);	\
        }							\
        if (_fault != md_fault_none)				\
                DECLARE_FAULT(_fault);				\
   }
        
                
DEFINST(STFIWX,                 0x7AE,
        "stfiwx",               "S,a,b",
        WrPort,                 F_MEM|F_STORE|F_RR,
        DNA,DNA,                PPC_DFPR(FS),PPC_DGPR(RA),PPC_DGPR(RB),
        DNA, DNA, DNA,        	DNA, DNA)


#define ADDC_IMPL				\
  {						\
	sword_t _ra,_rb;			\
	_ra = GPR(RA);				\
	_rb = GPR(RB);				\
        SET_GPR(RD, _ra + _rb);			\
	if(carrygenerated(_ra, _rb)){		\
		PPC_SET_XER_CA;			\
	}					\
	else { PPC_RESET_XER_CA;}		\
  }


DEFINST(ADDC,                   0x14,
        "addc",                 "d,a,b",    
        IntALU,                 F_ICOMP,
        PPC_DGPR(RD), DNA,      PPC_DGPR(RA), PPC_DGPR(RB), DNA,
        DNA,DNA,DNA,            DNA,DNA)


#define ADDCD_IMPL					\
  {							\
    sword_t  _src;					\
    sword_t _ra,_rb;                                   \
    _ra = GPR(RA);                                      \
    _rb = GPR(RB);                                      \
							\
    _src = _ra + _rb;					\
        if(!(_src)) PPC_SET_CR0_EQ;		      	\
        else PPC_RESET_CR0_EQ;				\
        if(_src>0) PPC_SET_CR0_GT;		      	\
        else PPC_RESET_CR0_GT;				\
        if(_src<0) PPC_SET_CR0_LT;		       	\
        else PPC_RESET_CR0_LT;				\
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;	       	\
        else PPC_RESET_CR0_SO;				\
        SET_GPR(RD, _src);				\
	if(carrygenerated(_ra, _rb)){			\
	PPC_SET_XER_CA;					\
	}						\
	else{ PPC_RESET_XER_CA;}		      	\
}


DEFINST(ADDCD,                  0x15,
       "addc.",                "d,a,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RD), PPC_DCR,  PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER, 
        PPC_DXER,DNA,DNA,       DNA,DNA)


#define ADDCO_IMPL                                      \
  {                                                     \
	sword_t _ra,_rb;                        	\
        _ra = GPR(RA);                 			\
        _rb = GPR(RB);                          	\
         if (OVER(_ra, _rb)){                   	\
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
        SET_GPR(RD, (_ra + _rb));                 	\
	if(carrygenerated(_ra, _rb)){			\
	PPC_SET_XER_CA;					\
	}						\
	else{ PPC_RESET_XER_CA;}	      		\
  }     

DEFINST(ADDCO,                  	0x414,
        "addco",                	"d,a,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER,
        DNA,DNA,DNA,            	DNA,DNA)




#define ADDCOD_IMPL                                     \
  {                                                     \
        sword_t  _src;                                  \
        sword_t _ra,_rb;                                \
        _ra = GPR(RA);                                  \
        _rb = GPR(RB);                                  \
         if (OVER(_ra, _rb)){                           \
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
         _src = _ra + _rb;                              \
        SET_GPR(RD, _src);                              \
        if(!(_src)) PPC_SET_CR0_EQ;                     \
        else PPC_RESET_CR0_EQ;                          \
        if(_src>0) PPC_SET_CR0_GT;                      \
        else PPC_RESET_CR0_GT;                          \
        if(_src<0) PPC_SET_CR0_LT;                      \
        else PPC_RESET_CR0_LT;                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;              \
        else PPC_RESET_CR0_SO;                          \
	if(carrygenerated(_ra, _rb)){		        \
	PPC_SET_XER_CA;					\
	}						\
	else{ PPC_RESET_XER_CA;}			\
  }
 
DEFINST(ADDCOD,                 	0x415,
        "addco.",               	"d,a,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER,
        PPC_DCR,DNA,DNA,            	PPC_DCR,DNA)
        


#define MULHWU_IMPL                                                     \
  {                                                                     \
        qword_t _res;							\
        _res = (qword_t)((unsigned int)GPR(RA)) *			\
	  (qword_t)((unsigned int)GPR(RB));				\
        _res = (_res >> 32);                                            \
        SET_GPR(RD, (word_t)(_res));                                    \
  }

DEFINST(MULHWU,                 0x16,
        "mulhwu",               "d,a,b", 
        IntMULT,                F_ICOMP|F_LONGLAT,
        PPC_DGPR(RD), DNA,      PPC_DGPR(RA), PPC_DGPR(RB), DNA,
	DNA, DNA, DNA,		DNA,DNA)


#define MULHWUD_IMPL							\
  {									\
    qword_t _src;							\
    _src = (qword_t)((unsigned int)GPR(RA)) *				\
      (qword_t)((unsigned int)GPR(RB));					\
    _src = (_src >> 32);						\
    SET_GPR(RD, (word_t)(_src));					\
    if(!(_src)) PPC_SET_CR0_EQ;						\
    else PPC_RESET_CR0_EQ;						\
    if(_src>0) PPC_SET_CR0_GT;						\
    else PPC_RESET_CR0_GT;						\
    if(_src<0) PPC_SET_CR0_LT;						\
    else PPC_RESET_CR0_LT;						\
    if(PPC_GET_XER_SO) PPC_SET_CR0_SO;					\
    else PPC_RESET_CR0_SO;						\
  }
  
DEFINST(MULHWUD,                0x17,
        "mulhwu.",              "d,a,b",
        IntMULT,                F_ICOMP|F_LONGLAT,
        PPC_DGPR(RD), DNA,      PPC_DGPR(RA), PPC_DGPR(RB), DNA,
        DNA, DNA, DNA,          DNA,DNA)




#define SLW_IMPL							\
   {									\
	word_t  _s, _b, _n;						\
	_b = GPR(RB);							\
	_n = _b&0x1F;							\
	_s = GPR(RS);							\
	if(!(_b&0x20)){ 						\
		SET_GPR(RA, (_s<<_n));					\
	}								\
	else{								\
		SET_GPR(RA,0);						\
	}								\
   }

DEFINST(SLW,			0x30,
	"slw",			"a,s,b",
	IntALU,			F_ICOMP,
	PPC_DGPR(RA),DNA,	PPC_DGPR(RB),PPC_DGPR(RS),DNA,
        DNA, DNA, DNA,        	DNA, DNA)


#define SLWD_IMPL                                                       \
   {                                                                    \
        word_t  _s, _b, _n, _src;                                       \
        _b = GPR(RB);                                                   \
        _n = _b&0x1F;                                                   \
        _s = GPR(RS);                                                   \
        if(!(_b&0x20)){                                                 \
		_src = (_s<<_n);				        \
                SET_GPR(RA, _src);                                  	\
		if(!(_src)) PPC_SET_CR0_EQ;                                 \
        	else PPC_RESET_CR0_EQ;                                  \
        	if(_src>0) PPC_SET_CR0_GT;                                  \
        	else PPC_RESET_CR0_GT;                                  \
        	if(_src<0) PPC_SET_CR0_LT;                                  \
        	else PPC_RESET_CR0_LT;                                  \
        	if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                          \
        	else PPC_RESET_CR0_SO;                                  \
        }                                                               \
        else{                                                           \
                SET_GPR(RA,0);                                          \
		PPC_SET_CR0_EQ; 					\
                PPC_RESET_CR0_GT;                                      	\
                PPC_RESET_CR0_LT;                                      	\
                if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                      \
                else PPC_RESET_CR0_SO;                                  \
        }                                                               \
   }

DEFINST(SLWD,                   0x31,
        "slw.",                 "a,s,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA),PPC_DCR,  	PPC_DGPR(RS),PPC_DGPR(RB),PPC_DCR,
        DNA, DNA, DNA,        	DNA, DNA)



#define SRW_IMPL                                                        \
   {                                                                    \
        word_t  _s, _b, _n;						\
        _b = GPR(RB);                                                   \
        _n = _b&0x1F;                                                   \
        _s =((word_t) GPR(RS) )>>_n;					\
        SET_GPR(RA, _s);	                                	\
   }

DEFINST(SRW,                    0x430,
        "srw",                  "a,s,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA), DNA,     	PPC_DGPR(RB),PPC_DGPR(RS),DNA,
        DNA, DNA, DNA,        	DNA, DNA)



#define SRWD_IMPL                                                       \
   {                                                                    \
        word_t  _s, _b, _n, _src;                                       \
        _b = GPR(RB);                                                   \
        _n = _b&0x1F;                                                   \
        _s = GPR(RS);                                                   \
         _src = (_s>>_n);                                        	\
         SET_GPR(RA, _src);                                     	\
         if(!(_src)) PPC_SET_CR0_EQ;                                 	\
         else PPC_RESET_CR0_EQ;                                      	\
         if(_src>0) PPC_SET_CR0_GT;                                  	\
         else PPC_RESET_CR0_GT;                                      	\
         if(_src<0) PPC_SET_CR0_LT;                                  	\
         else PPC_RESET_CR0_LT;                                      	\
         if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                            	\
         else PPC_RESET_CR0_SO;                                      	\
    }

DEFINST(SRWD,                   0x431,
        "srw.",                 "a,s,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA),PPC_DCR,   PPC_DGPR(RS),PPC_DGPR(RB),PPC_DCR,
        DNA, DNA, DNA,          DNA, DNA)




#define SRAW_IMPL                                                       \
   {                                                                    \
        sword_t  _s, _b, _n, _src,_m=0;					\
        int _i;                                                         \
        _b = GPR(RB);                                                   \
        _n = _b&0x1F;           		                        \
	_s = GPR(RS);							\
	if(_b&0x20){							\
		if(_s<0){						\
		 _src = 0xffffffff;					\
		if(_s&0x7fffffff) PPC_SET_XER_CA;			\
		else PPC_RESET_XER_CA;					\
		}							\
		else{							\
		 _src=0x0;						\
		 PPC_RESET_XER_CA;					\
		}							\
	}								\
	else{								\
		_src=_s>>_n;						\
	 	if(_s<0){                                              	\
			for(_i=0;_i<_n;_i++){				\
				_m= _m<<1;				\
				_m=_m|0x1;				\
			}						\
                        if(_s&_m) PPC_SET_XER_CA;                   	\
                        else PPC_RESET_XER_CA;                          \
                }                                                       \
		else PPC_RESET_XER_CA;					\
        }                                                               \
        SET_GPR(RA, _src);                                              \
   }
                
DEFINST(SRAW,                   	0x630,
        "sraw",                 	"a,s,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RA), PPC_DXER,         PPC_DGPR(RB),PPC_DGPR(RS),PPC_DXER,
        DNA, DNA, DNA,          	DNA, DNA)


#define SRAWD_IMPL                                                      \
   {                                                                    \
        sword_t  _s, _b, _n, _src,_m=0;                                   \
        int _i;                                                         \
        _b = GPR(RB);                                                   \
        _n = _b&0x1F;                                                   \
        _s = GPR(RS);                                                   \
        if(_b&0x20){                                                    \
                if(_s<0){                                               \
                         _src = 0xffffffff;                             \
                        if(_s&0x7fffffff) PPC_SET_XER_CA;               \
                        else PPC_RESET_XER_CA;                          \
                }                                                       \
                else{                                                   \
                 _src=0x0;                                              \
                 PPC_RESET_XER_CA;                                      \
                }                                                       \
        }                                                               \
        else{                                                           \
                _src=_s>>_n;                                            \
                if(_s<0){                                               \
                        for(_i=0;_i<_n;_i++){                           \
                                _m= _m<<1;                              \
                                _m=_m|0x1;                              \
                        }                                               \
                        if(_s&_m) PPC_SET_XER_CA;                       \
                        else PPC_RESET_XER_CA;                          \
                }                                                       \
                else PPC_RESET_XER_CA;                                  \
        }                                                               \
        SET_GPR(RA, _src);                                              \
        if(!(_src)) PPC_SET_CR0_EQ;                                     \
        else PPC_RESET_CR0_EQ;                                          \
        if(_src>0) PPC_SET_CR0_GT;                                      \
        else PPC_RESET_CR0_GT;                                          \
        if(_src<0) PPC_SET_CR0_LT;                                      \
        else PPC_RESET_CR0_LT;                                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                              \
        else PPC_RESET_CR0_SO;                                          \
   }

DEFINST(SRAWD,                  	0x631,
        "sraw.",                	"a,s,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RA), PPC_DXER,         PPC_DGPR(RB),PPC_DGPR(RS),PPC_DXER,
        PPC_DCR, DNA, DNA,          	PPC_DCR, DNA)
        
 

#define SRAWI_IMPL                                                      \
   {                                                                    \
        sword_t  _s, _b, _n, _src,_m=0;                                   \
        int _i;                                                         \
        _b = SH;                        	                        \
        _n = _b&0x1F;                                                   \
        _s = GPR(RS);                                                   \
        if(_b&0x20){                                                    \
                if(_s<0){                                               \
                         _src = 0xffffffff;                             \
                        if(_s&0x7fffffff) PPC_SET_XER_CA;               \
                        else PPC_RESET_XER_CA;                          \
                }                                                       \
                else{                                                   \
                 _src=0x0;                                              \
                 PPC_RESET_XER_CA;                                      \
                }                                                       \
        }                                                               \
        else{                                                           \
                _src=_s>>_n;                                            \
                if(_s<0){                                               \
                        for(_i=0;_i<_n;_i++){                           \
                                _m= _m<<1;                              \
                                _m=_m|0x1;                              \
                        }                                               \
                        if(_s&_m) PPC_SET_XER_CA;                       \
                        else PPC_RESET_XER_CA;                          \
                }                                                       \
                else PPC_RESET_XER_CA;                                  \
        }                                                               \
        SET_GPR(RA, _src);                                              \
   }
    
DEFINST(SRAWI,                  0x670,
        "srawi",                "a,s,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA), PPC_DXER, PPC_DGPR(RB),PPC_DGPR(RS),PPC_DXER,
        DNA, DNA, DNA,          DNA, DNA)






#define SRAWID_IMPL                                                     \
   {                                                                    \
        sword_t  _s, _b, _n, _src,_m=0;                                   \
        int _i;                                                         \
        _b = SH;                                                   	\
        _n = _b&0x1F;                                                   \
        _s = GPR(RS);                                                   \
        if(_b&0x20){                                                    \
                if(_s<0){                                               \
                         _src = 0xffffffff;                             \
                        if(_s&0x7fffffff) PPC_SET_XER_CA;               \
                        else PPC_RESET_XER_CA;                          \
                }                                                       \
                else{                                                   \
                 _src=0x0;                                              \
                 PPC_RESET_XER_CA;                                      \
                }                                                       \
        }                                                               \
        else{                                                           \
                _src=_s>>_n;                                            \
                if(_s<0){                                               \
                        for(_i=0;_i<_n;_i++){                           \
                                _m= _m<<1;                              \
                                _m=_m|0x1;                              \
                        }                                               \
                        if(_s&_m) PPC_SET_XER_CA;                       \
                        else PPC_RESET_XER_CA;                          \
                }                                                       \
                else PPC_RESET_XER_CA;                                  \
        }                                                               \
        SET_GPR(RA, _src);                                              \
        if(!(_src)) PPC_SET_CR0_EQ;                                         \
        else PPC_RESET_CR0_EQ;                                          \
        if(_src>0) PPC_SET_CR0_GT;                                          \
        else PPC_RESET_CR0_GT;                                          \
        if(_src<0) PPC_SET_CR0_LT;                                          \
        else PPC_RESET_CR0_LT;                                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                                  \
        else PPC_RESET_CR0_SO;                                          \
   }
                        
DEFINST(SRAWID,                 	0x671,
        "srawi.",               	"a,s,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RA), PPC_DXER,         PPC_DGPR(RB),PPC_DGPR(RS),PPC_DXER,
        PPC_DCR, DNA, DNA,          	PPC_DCR, DNA)





#define CNTLZW_IMPL							\
   {									\
	int _n=0;							\
	word_t _src, _mask;						\
	_mask = 0x80000000;						\
	_src = GPR(RS);							\
	while(_n<32)							\
	{								\
		if(_mask&_src) break;					\
		else{							\
			_n++;						\
			_mask = _mask >>1;				\
		}							\
	}								\
	SET_GPR(RA, _n);						\
   }

DEFINST(CNTLZW,			0x34,
	"cntlzw",		"a,s",
	IntALU,			F_ICOMP,
	PPC_DGPR(RA),DNA,	PPC_DGPR(RS),DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)





#define CNTLZWD_IMPL                                                    \
   {                                                                    \
        int _n=0;                                                       \
        word_t _src, _mask;                                             \
        _mask = 0x80000000;                                             \
        _src = GPR(RS);                                                 \
        while(_n<32)                                                    \
        {                                                               \
                if(_mask&_src) break;                                   \
                else{                                                   \
                        _n++;                                           \
                        _mask = _mask >>1;                              \
                }                                                       \
        }                                                               \
        SET_GPR(RA, _n);                                                \
        if(!(_n)) PPC_SET_CR0_EQ;                                     	\
        else PPC_RESET_CR0_EQ;                                          \
        if(_n>0) PPC_SET_CR0_GT;                                      	\
        else PPC_RESET_CR0_GT;                                          \
        if(_n<0) PPC_SET_CR0_LT;                                        \
        else PPC_RESET_CR0_LT;                                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                              \
        else PPC_RESET_CR0_SO;                                          \
   }

DEFINST(CNTLZWD,                0x35,
        "cntlzw.",              "a,s",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA),PPC_DCR,   PPC_DGPR(RS),DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)

  


#define AND_IMPL							\
   {									\
	SET_GPR(RA, GPR(RS)& GPR(RB));					\
   }

DEFINST(AND,			0x38,
	"and",			"a,s,b",
	IntALU,			F_ICOMP,
	PPC_DGPR(RA),DNA,	PPC_DGPR(RS),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,        	DNA, DNA)
		


#define ANDD_IMPL                                                       \
   {                                                                    \
	sword_t	_src;							\
	_src = GPR(RS)& GPR(RB);					\
        SET_GPR(RA, _src);                                  		\
	if(!(_src)) PPC_SET_CR0_EQ;				        \
	else PPC_RESET_CR0_EQ;						\
        if(_src>0) PPC_SET_CR0_GT;                                      \
        else PPC_RESET_CR0_GT;                                          \
        if(_src<0) PPC_SET_CR0_LT;                                      \
        else PPC_RESET_CR0_LT;                                          \
	if(PPC_GET_XER_SO) PPC_SET_CR0_SO;				\
	else PPC_RESET_CR0_SO;						\
   }

DEFINST(ANDD,                   0x39,
        "and.",                 "a,s,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA),PPC_DCR,	PPC_DGPR(RS),PPC_DGPR(RB),PPC_DCR,
        DNA, DNA, DNA,        	DNA, DNA)





#define ANDC_IMPL                                                       \
   {                                                                    \
        SET_GPR(RA, GPR(RS)& (~(GPR(RB))));                             \
   }
        
DEFINST(ANDC,                   0x78,
        "andc",                 "a,s,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA),DNA,           PPC_DGPR(RS),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,        	DNA, DNA)

   

#define ANDCD_IMPL                                                      \
   {                                                                    \
        sword_t _src;                                                   \
        _src = GPR(RS)& (~(GPR(RB)));					\
        SET_GPR(RA, _src);                                              \
        if(!(_src)) PPC_SET_CR0_EQ;                                     \
        else PPC_RESET_CR0_EQ;                                          \
        if(_src>0) PPC_SET_CR0_GT;                                      \
        else PPC_RESET_CR0_GT;                                          \
        if(_src<0) PPC_SET_CR0_LT;                                      \
        else PPC_RESET_CR0_LT;                                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                              \
        else PPC_RESET_CR0_SO;                                          \
   }

DEFINST(ANDCD,                  0x79,
        "andc.",                "a,s,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA),DNA,       PPC_DGPR(RS),PPC_DGPR(RB),PPC_DCR,
        DNA, DNA, DNA,        	DNA, DNA)



#define MULHW_IMPL							\
  {                                                                     \
	sqword_t _res;							\
	_res = (sqword_t) GPR(RA) * (sqword_t)GPR(RB); 			\
	_res = (_res >> 32);						\
	SET_GPR(RD, (sword_t)(_res));					\
  }
   
DEFINST(MULHW,                  0x96,
        "mulhw",                "d,a,b", 
        IntMULT,                F_ICOMP|F_LONGLAT,
        PPC_DGPR(RD), DNA,      PPC_DGPR(RA), PPC_DGPR(RB), DNA,
	DNA, DNA, DNA,		DNA, DNA)
 
#define MULHWD_IMPL					\
  {							\
        sqword_t _src;					\
        _src = (sqword_t) GPR(RA) * (sqword_t)GPR(RB);	\
        _src = (_src >> 32);				\
        SET_GPR(RD, (sword_t)(_src));			\
        if(!(_src)) PPC_SET_CR0_EQ;			\
        else PPC_RESET_CR0_EQ;				\
        if(_src>0) PPC_SET_CR0_GT;			\
        else PPC_RESET_CR0_GT;				\
        if(_src<0) PPC_SET_CR0_LT;			\
        else PPC_RESET_CR0_LT;				\
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;	        \
        else PPC_RESET_CR0_SO;				\
  }

DEFINST(MULHWD,                 	0x97,
        "mulhw.",               	"d,a,b",
        IntMULT,                	F_ICOMP|F_LONGLAT,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER,
        PPC_DCR, DNA, DNA,          	PPC_DCR, DNA)


#define NOR_IMPL                                                        \
   {                                                                    \
        SET_GPR(RA, ~(GPR(RS) | GPR(RB)));                              \
   }

DEFINST(NOR,                    0xF8,
        "nor",                  "a,s,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA),DNA,       PPC_DGPR(RS),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,        	DNA, DNA)


#define NORD_IMPL                                                       \
   {                                                                    \
        sword_t _src;                                                   \
        _src = ~(GPR(RS)| GPR(RB));                                     \
        SET_GPR(RA, _src);                                              \
        if(!(_src)) PPC_SET_CR0_EQ;                                     \
        else PPC_RESET_CR0_EQ;                                          \
        if(_src>0) PPC_SET_CR0_GT;                                      \
        else PPC_RESET_CR0_GT;                                          \
        if(_src<0) PPC_SET_CR0_LT;                                      \
        else PPC_RESET_CR0_LT;                                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                              \
        else PPC_RESET_CR0_SO;                                          \
   }

DEFINST(NORD,                  0xF9,
        "nor.",                "a,s,b",
        IntALU,                F_ICOMP,
        PPC_DGPR(RA),PPC_DCR,  PPC_DGPR(RS),PPC_DGPR(RB),PPC_DCR,
        DNA, DNA, DNA,         DNA, DNA)




#define SUBF_IMPL                                                       \
  {                                                                     \
        SET_GPR(RD, GPR(RB) - GPR(RA));                                 \
  }

DEFINST(SUBF,                   0x50,
        "subf",                 "d,a,b", 
        IntALU,                 F_ICOMP,
        PPC_DGPR(RD), DNA,      PPC_DGPR(RA), PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,          DNA, DNA)


#define SUBFO_IMPL					\
  {							\
	if (UNDER(GPR(RB), GPR(RA))){                   \
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
        SET_GPR(RD, GPR(RB) - GPR(RA));			\
  }
        
DEFINST(SUBFO,                  	0x450,
        "subfo",                	"d,a,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER,
	DNA,DNA,DNA,			DNA,DNA)
        



#define SUBFOD_IMPL                                     \
  {                                                     \
        sword_t  _src;                                  \
         if (UNDER(GPR(RB), GPR(RA))){                  \
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
         _src = GPR(RB) - GPR(RA);                      \
        SET_GPR(RD, _src);                              \
        if(!(_src)) PPC_SET_CR0_EQ;                         \
        else PPC_RESET_CR0_EQ;                              \
        if(_src>0) PPC_SET_CR0_GT;                          \
        else PPC_RESET_CR0_GT;                              \
        if(_src<0) PPC_SET_CR0_LT;                          \
        else PPC_RESET_CR0_LT;                              \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                  \
        else PPC_RESET_CR0_SO;                              \
  }
        
DEFINST(SUBFOD,                 	0x451,
        "subfo.",               	"d,a,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER,
        PPC_DCR,DNA,DNA,            	PPC_DCR,DNA)


#define SUBFD_IMPL                                                      \
  {                                                                     \
    sword_t  _src;                                                      \
                                                                        \
    _src = GPR(RB) - GPR(RA);                                           \
        if(!(_src)) PPC_SET_CR0_EQ;                                     \
        else PPC_RESET_CR0_EQ;                                          \
        if(_src>0) PPC_SET_CR0_GT;                                      \
        else PPC_RESET_CR0_GT;                                          \
        if(_src<0) PPC_SET_CR0_LT;                                      \
        else PPC_RESET_CR0_LT;                                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                              \
        else PPC_RESET_CR0_SO;                                          \
        SET_GPR(RD, _src);                                              \
   }

DEFINST(SUBFD,                  	0x51,
        "subf.",                	"d,a,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DCR,          PPC_DGPR(RA), PPC_DGPR(RB), PPC_DCR,
	DNA, DNA, DNA,			DNA,DNA)


#define NEG_IMPL                                                       	\
  {                                                                     \
    SET_GPR(RD, -GPR(RA));                                		\
  }
 
DEFINST(NEG,                    0xD0,
        "neg",                  "d,a",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RD), DNA,      PPC_DGPR(RA), DNA, DNA,
	DNA, DNA, DNA,		DNA,DNA)


#define NEGD_IMPL							\
  { 									\
    sword_t _src;                                                       \
    _src = -GPR(RA);							\
    SET_GPR(RD, _src);                                              	\
        if(!(_src)) PPC_SET_CR0_EQ;					\
        else PPC_RESET_CR0_EQ;                                          \
        if(_src>0) PPC_SET_CR0_GT;                                      \
        else PPC_RESET_CR0_GT;                                          \
        if(_src<0) PPC_SET_CR0_LT;                                      \
        else PPC_RESET_CR0_LT;                                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                              \
        else PPC_RESET_CR0_SO;                                          \
        SET_GPR(RD, _src);                                              \
  }


DEFINST(NEGD,                   	0xD1,
        "neg.",                	 	"d,a",
        IntALU,                	 	F_ICOMP,
        PPC_DGPR(RD), PPC_DCR,          PPC_DGPR(RA), DNA, DNA,
	DNA,DNA,DNA,			DNA,DNA)



#define NEGO_IMPL			\
  {					\
    SET_GPR(RD, -GPR(RA));		\
    if(((word_t)GPR(RA))==0x80000000){	\
	PPC_SET_XER_OV;PPC_SET_XER_SO;	\
    }					\
    else{PPC_RESET_XER_OV;}		\
  }
        
DEFINST(NEGO,                   0x4D0,
        "nego",                 "d,a",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RD), DNA,      PPC_DGPR(RA), DNA, DNA,
        DNA, DNA, DNA,          DNA,DNA)
 

#define NEGOD_IMPL			\
  {					\
    sword_t _src;			\
    _src = -GPR(RA);			\
    SET_GPR(RD, _src);			\
        if(!(_src)) PPC_SET_CR0_EQ;	\
        else PPC_RESET_CR0_EQ;		\
        if(_src>0) PPC_SET_CR0_GT;	\
        else PPC_RESET_CR0_GT;		\
        if(_src<0) PPC_SET_CR0_LT;	\
        else PPC_RESET_CR0_LT;		\
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;	\
        else PPC_RESET_CR0_SO;		\
        SET_GPR(RD, _src);		\
    if(((word_t)GPR(RA))==0x80000000){	\
	PPC_SET_XER_OV;PPC_SET_XER_SO;	\
    }					\
    else{PPC_RESET_XER_OV;}		\
  }

DEFINST(NEGOD,                  	0x4D1,   
        "nego.",                	"d,a",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DCR,          PPC_DGPR(RA), DNA, DNA,
        DNA,DNA,DNA,            	DNA,DNA)



#define SUBFE_IMPL                              \
  {                               	        \
	sword_t _ra,_rb,_ca;                    \
        _ra = ~((sword_t)GPR(RA));              \
        _rb = GPR(RB);                          \
        _ca = PPC_GET_XER_CA;                   \
        SET_GPR(RD, _ra + _rb+_ca);		\
        if(carrygenerated(_rb, _ra)){		\
                PPC_SET_XER_CA;                 \
        }                                       \
        else if(carrygenerated(_rb+_ra,_ca)){	\
                PPC_SET_XER_CA;                 \
        }                                       \
        else { PPC_RESET_XER_CA;}               \
  }

DEFINST(SUBFE,                  0x110,
        "subfe",                "d,a,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RD), DNA,      PPC_DGPR(RA), PPC_DGPR(RB), DNA, 
        DNA,DNA,DNA,            DNA,DNA)





#define SUBFED_IMPL                                     \
  {                                                     \
    sword_t  _src;                                      \
  sword_t _ra,_rb,_ca;                                	\
    _ra = ~((sword_t)GPR(RA));                          \
    _rb = GPR(RB);                                      \
    _ca = PPC_GET_XER_CA;                               \
                                                        \
    _src = _ra + _rb+_ca;    				\
        if(!(_src)) PPC_SET_CR0_EQ;                     \
        else PPC_RESET_CR0_EQ;                          \
        if(_src>0) PPC_SET_CR0_GT;                      \
        else PPC_RESET_CR0_GT;                          \
        if(_src<0) PPC_SET_CR0_LT;                      \
        else PPC_RESET_CR0_LT;                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;              \
        else PPC_RESET_CR0_SO;                          \
        SET_GPR(RD, _src);                              \
        if(carrygenerated(_rb, _ra)){           	\
        PPC_SET_XER_CA;                                 \
        }                                               \
        else if(carrygenerated( (_rb+ _ra),_ca ) ){	\
        PPC_SET_XER_CA;                                 \
        }                                               \
        else{ PPC_RESET_XER_CA;}                        \
  }
 

DEFINST(SUBFED,                 0x111,
        "subfe.",               "d,a,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RD), PPC_DCR,  PPC_DGPR(RA), PPC_DGPR(RB), PPC_DCR,
        PPC_DXER,DNA,DNA,       PPC_DXER,DNA)
        

#define SUBFEO_IMPL                                     \
  {                                                     \
	sword_t _ra,_rb,_ca;                        	\
        _ra = ~((sword_t)GPR(RA));                 	\
        _rb = GPR(RB);     			       	\
	_ca = PPC_GET_XER_CA;				\
         if (OVER(_rb, _ra )){   			\
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
         else if (OVER(_rb+ _ra, _ca)){  		\
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
        SET_GPR(RD, _rb + _ra+_ca);      		\
        if(carrygenerated(_rb, _ra)){                   \
        PPC_SET_XER_CA;                                 \
        }                                               \
        else if(carrygenerated(_rb+ _ra, _ca)){         \
        PPC_SET_XER_CA;                                 \
        }                                               \
        else{ PPC_RESET_XER_CA;}                        \
  }

DEFINST(SUBFEO,                 	0x510,
        "subfeo",               	"d,a,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER,
        DNA,DNA,DNA,            	DNA,DNA)




#define SUBFEOD_IMPL                                    \
  {                                                     \
        sword_t  _src;                                  \
        sword_t _ra,_rb,_ca;                            \
        _ra = ~((sword_t)GPR(RA));                      \
        _rb = GPR(RB);                                  \
        _ca = PPC_GET_XER_CA;                           \
        if (OVER( _rb, _ra)){				\
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else if (OVER(_rb+ _ra,_ca)){    		\
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
         _src = _rb + _ra+_ca;				\
        SET_GPR(RD, _src);                              \
        if(!(_src)) PPC_SET_CR0_EQ;                     \
             else PPC_RESET_CR0_EQ;                     \
        if(_src>0) PPC_SET_CR0_GT;                      \
        else PPC_RESET_CR0_GT;                          \
        if(_src<0) PPC_SET_CR0_LT;                      \
        else PPC_RESET_CR0_LT;                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;              \
        else PPC_RESET_CR0_SO;                          \
        if(carrygenerated(_rb, _ra ) ){                 \
        PPC_SET_XER_CA;                                 \
        }                                               \
        else if(carrygenerated(_rb+_ra,_ca)){           \
        PPC_SET_XER_CA;                                 \
        }                                               \
        else{ PPC_RESET_XER_CA;}                        \
  }


DEFINST(SUBFEOD,                	0x511,
        "subfeo.",              	"d,a,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER,
        PPC_DCR,DNA,DNA,            	PPC_DCR,DNA)





#define ADDE_IMPL                               \
{                                             	\
  	sword_t _ra,_rb,_ca;			\
	_ra = GPR(RA);				\
	_rb = GPR(RB);				\
	_ca = PPC_GET_XER_CA;			\
        SET_GPR(RD, _ra + _rb+ _ca);         	\
        if(carrygenerated(_ra, _rb)){           \
                PPC_SET_XER_CA;                 \
        }                                       \
        else if((_ca!=0)&&carrygenerated(_ra + _rb, _ca)){ \
                PPC_SET_XER_CA;                 \
        }                                       \
	else { PPC_RESET_XER_CA;}               \
  }

DEFINST(ADDE,                   	0x114,
        "adde",                 	"d,a,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER,  
        DNA,DNA,DNA,            	DNA,DNA)
        

#define ADDED_IMPL                                      \
  {                                                     \
    sword_t  _src;                                      \
    sword_t _ra,_rb,_ca;                                \
    _ra = GPR(RA);                                      \
    _rb = GPR(RB);                                      \
    _ca = PPC_GET_XER_CA;                               \
    _src = _ra + _rb+ _ca;                	        \
        if(!(_src)) PPC_SET_CR0_EQ;                     \
        else PPC_RESET_CR0_EQ;                          \
        if(_src>0) PPC_SET_CR0_GT;                      \
        else PPC_RESET_CR0_GT;                          \
        if(_src<0) PPC_SET_CR0_LT;                      \
        else PPC_RESET_CR0_LT;                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;              \
        else PPC_RESET_CR0_SO;                          \
        SET_GPR(RD, _src);                              \
        if(carrygenerated(_ra, _rb)){           	\
        PPC_SET_XER_CA;                                 \
        }                                               \
        else if((_ca!=0)&&carrygenerated( _ra+ _rb,_ca ) ){	\
        PPC_SET_XER_CA;                                 \
        }                                               \
        else{ PPC_RESET_XER_CA;}                        \
}       
        
DEFINST(ADDED,                  0x115,
        "adde.",                "d,a,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RD), PPC_DCR,  PPC_DGPR(RA), PPC_DGPR(RB), PPC_DCR, 
        PPC_DXER,DNA,DNA,       PPC_DXER,DNA)




#define ADDEO_IMPL                	                \
  {                                                     \
	sword_t _ra,_rb,_ca;                        	\
	_ca = PPC_GET_XER_CA;				\
        _ra = GPR(RA);                 			\
        _rb = GPR(RB);                          	\
         if (OVER(_ra, _rb)){                   	\
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
         else if (OVER(_ra+ _rb, _ca)){  	        \
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
        SET_GPR(RD, _ra+_rb+_ca);                       \
        if(carrygenerated(_ra, _rb)){                   \
        PPC_SET_XER_CA;                                 \
        }                                               \
        else if((_ca!=0)&&carrygenerated(_ra+_rb, _ca)){\
        PPC_SET_XER_CA;                                 \
        }                                               \
        else{ PPC_RESET_XER_CA;}                        \
  }
  
DEFINST(ADDEO,                  	0x514,
        "addeo",               	 	"d,a,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER,
        DNA,DNA,DNA,            	DNA,DNA)


#define ADDEOD_IMPL                                     \
  {                                                     \
        sword_t  _src;                                  \
	sword_t _ra,_rb,_ca;                            \
        _ra = GPR(RA);                                  \
        _rb = GPR(RB);                                  \
	_ca = PPC_GET_XER_CA;				\
        if (OVER(_ra, _rb)){                   		\
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else if ((_ca!=0)&&OVER(_ra+ _rb,_ca)){		\
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
         _src = _ra+_rb+_ca;           			\
        SET_GPR(RD, _src);                              \
        if(!(_src)) PPC_SET_CR0_EQ;                     \
        else PPC_RESET_CR0_EQ;                          \
        if(_src>0) PPC_SET_CR0_GT;                      \
        else PPC_RESET_CR0_GT;                          \
        if(_src<0) PPC_SET_CR0_LT;                      \
        else PPC_RESET_CR0_LT;                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;              \
        else PPC_RESET_CR0_SO;                          \
        if(carrygenerated(_ra, _rb)){                   \
        PPC_SET_XER_CA;                                 \
        }                                               \
        else if(carrygenerated(_ra+_rb,_ca)){           \
        PPC_SET_XER_CA;                                 \
        }                                               \
        else{ PPC_RESET_XER_CA;}                        \
  }

DEFINST(ADDEOD,                	 	0x515,
        "addeo.",              		"d,a,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER,
        PPC_DCR,DNA,DNA,            	PPC_DCR,DNA)




#define SUBFZE_IMPL                                 \
  {                                                 \
    SET_GPR(RD, (~((sword_t)GPR(RA))) + PPC_GET_XER_CA  );      \
    if( carrygenerated(~((sword_t)GPR(RA)) , PPC_GET_XER_CA) ){ \
        PPC_SET_XER_CA;                             \
    }                                               \
    else{ PPC_RESET_XER_CA;}                        \
  }

DEFINST(SUBFZE,                 	0x190,
        "subfze",               	"d,a",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, DNA,
        DNA,DNA,DNA,            	DNA,DNA)


#define SUBFZED_IMPL                            \
  {                                             \
    sword_t _src;                               \
    _src= (~((sword_t)GPR(RA))) + PPC_GET_XER_CA;\
    if( carrygenerated((~((sword_t)GPR(RA))), PPC_GET_XER_CA) ){\
        PPC_SET_XER_CA;                             \
    }                                               \
    else{ PPC_RESET_XER_CA;}                        \
        if(!(_src)) PPC_SET_CR0_EQ;                 \
        else PPC_RESET_CR0_EQ;                      \
        if(_src>0) PPC_SET_CR0_GT;                  \
        else PPC_RESET_CR0_GT;                      \
        if(_src<0) PPC_SET_CR0_LT;                  \
        else PPC_RESET_CR0_LT;                      \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;          \
        else PPC_RESET_CR0_SO;                      \
        SET_GPR(RD, _src);                          \
  }

DEFINST(SUBFZED,                	0x191,
        "subfze.",              	"d,a",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, PPC_DCR,
        PPC_DCR,DNA,DNA,            	DNA,DNA)





#define SUBFZEO_IMPL                                    \
  {                                                     \
 	sword_t _ra,_ca;                        	\
        _ra = ~((sword_t)GPR(RA));                 	\
        _ca = PPC_GET_XER_CA;                          	\
         if (OVER(_ra, _ca)){            		\
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
        SET_GPR(RD, _ra +_ca);      			\
        if(carrygenerated(_ra, _ca)){        		\
        PPC_SET_XER_CA;                                 \
        }                                               \
        else{ PPC_RESET_XER_CA;}                        \
  }

DEFINST(SUBFZEO,               	 	0x590,
        "subfzeo",              	"d,a",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, DNA,
        DNA,DNA,DNA,            	DNA,DNA)




#define SUBFZEOD_IMPL                                   \
  {                                                     \
        sword_t  _src;                                  \
	sword_t _ra,_ca;				\
	_ca = PPC_GET_XER_CA;				\
	_ra = ~((sword_t)GPR(RA));			\
        if (OVER(_ra,_ca)){                		\
               PPC_SET_XER_SO; PPC_SET_XER_OV;          \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
         _src = _ra +_ca;                  	        \
        SET_GPR(RD, _src);                              \
        if(!(_src)) PPC_SET_CR0_EQ;                     \
        else PPC_RESET_CR0_EQ;                          \
        if(_src>0) PPC_SET_CR0_GT;                      \
        else PPC_RESET_CR0_GT;                          \
        if(_src<0) PPC_SET_CR0_LT;                      \
        else PPC_RESET_CR0_LT;                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;              \
        else PPC_RESET_CR0_SO;                          \
        if(carrygenerated(_ra,_ca)){                    \
        PPC_SET_XER_CA;                                 \
        }                                               \
        else{ PPC_RESET_XER_CA;}                        \
  }
   
   
   

DEFINST(SUBFZEOD,               	0x591,
        "subfzeo.",             	"d,a",
        IntALU,                 	F_ICOMP, 
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, PPC_DCR,
        PPC_DCR,DNA,DNA,            	DNA,DNA)




#define ADDZE_IMPL                                  \
  {                                                 \
    SET_GPR(RD, GPR(RA) + PPC_GET_XER_CA  );        \
    if( carrygenerated(GPR(RA), PPC_GET_XER_CA) ){  \
        PPC_SET_XER_CA;                             \
    }                                               \
    else{ PPC_RESET_XER_CA;}                        \
  }

DEFINST(ADDZE,                  	0x194,
        "addze",                	"d,a",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, DNA,
        DNA,DNA,DNA,            	DNA,DNA)


#define ADDZED_IMPL                             \
  {                                             \
    sword_t _src;                               \
    _src= GPR(RA) + PPC_GET_XER_CA;                 \
    if( carrygenerated(GPR(RA), PPC_GET_XER_CA) ){  \
        PPC_SET_XER_CA;                             \
    }                                               \
    else{ PPC_RESET_XER_CA;}                        \
        if(!(_src)) PPC_SET_CR0_EQ;                 \
        else PPC_RESET_CR0_EQ;                      \
        if(_src>0) PPC_SET_CR0_GT;                  \
        else PPC_RESET_CR0_GT;                      \
        if(_src<0) PPC_SET_CR0_LT;                  \
        else PPC_RESET_CR0_LT;                      \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;          \
        else PPC_RESET_CR0_SO;                      \
        SET_GPR(RD, _src);                          \
  }
        
DEFINST(ADDZED,                 	0x195,
        "addze.",               	"d,a",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, PPC_DCR,
        PPC_DCR,DNA,DNA,            	DNA,DNA)
    
   
#define ADDZEO_IMPL                                     \
  {                                                     \
 	sword_t _ra,_ca;                        	\
        _ra = GPR(RA);                 			\
        _ca = PPC_GET_XER_CA;                          	\
         if (OVER(_ra, _ca)){            		\
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;} 		        \
        SET_GPR(RD, _ra + _ca);      			\
        if(carrygenerated(_ra, _ca)){        		\
        PPC_SET_XER_CA;                                 \
        }                                               \
        else{ PPC_RESET_XER_CA;}                        \
  }

DEFINST(ADDZEO,                 	0x594,
        "addzeo",               	"d,a",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, DNA,
        DNA,DNA,DNA,            	DNA,DNA)
 


#define ADDZEOD_IMPL                                    \
  {                                                     \
        sword_t  _src;                                  \
	sword_t _ra,_ca;				\
	_ra = GPR(RA);					\
	_ca = PPC_GET_XER_CA;				\
        if (OVER(_ra,_ca)){                		\
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
         _src = _ra + _ca;                       	\
        SET_GPR(RD, _src);                              \
        if(!(_src)) PPC_SET_CR0_EQ;                     \
        else PPC_RESET_CR0_EQ;                          \
        if(_src>0) PPC_SET_CR0_GT;                      \
        else PPC_RESET_CR0_GT;                          \
        if(_src<0) PPC_SET_CR0_LT;                      \
        else PPC_RESET_CR0_LT;                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;              \
        else PPC_RESET_CR0_SO;                          \
        if(carrygenerated(_ra,_ca)){                    \
        PPC_SET_XER_CA;                                 \
        }                                               \
        else{ PPC_RESET_XER_CA;}                        \
  }

        
    
                
DEFINST(ADDZEOD,                	0x595,
        "addzeo.",              	"d,a",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, PPC_DCR,
        PPC_DCR,DNA,DNA,            	DNA,DNA)



#define SUBFME_IMPL                             \
  {                                             \
	sword_t _ra,_ca;			\
	_ra = ~((sword_t)GPR(RA));		\
	_ca = PPC_GET_XER_CA;			\
    SET_GPR(RD, _ra + _ca - 1 );                \
    if( carrygenerated(_ra, (_ca-1)) ){         \
        PPC_SET_XER_CA;                         \
    }                                           \
    else{ PPC_RESET_XER_CA;}                    \
  }

DEFINST(SUBFME,                 	0x1D0,
        "subfme",               	"d,a",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, DNA,
        DNA,DNA,DNA,            	DNA,DNA)

#define SUBFMED_IMPL                            \
  {                                             \
    sword_t _src;                               \
    sword_t _ra,_ca;                            \
        _ra = ~((sword_t)GPR(RA));              \
        _ca =PPC_GET_XER_CA;                    \
    _src= _ra + _ca -1;     			\
    if( carrygenerated(_ra, (_ca-1)) ){		\
        PPC_SET_XER_CA;                         \
    }                                           \
    else{ PPC_RESET_XER_CA;}                    \
        if(!(_src)) PPC_SET_CR0_EQ;             \
        else PPC_RESET_CR0_EQ;                  \
        if(_src>0) PPC_SET_CR0_GT;              \
        else PPC_RESET_CR0_GT;                  \
        if(_src<0) PPC_SET_CR0_LT;              \
        else PPC_RESET_CR0_LT;                  \
       if(PPC_GET_XER_SO) PPC_SET_CR0_SO;       \
        else PPC_RESET_CR0_SO;                  \
        SET_GPR(RD, _src);                      \
  }
    
DEFINST(SUBFMED,                	0x1D1,
        "subfme.",              	"d,a,i",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, PPC_DCR,
        PPC_DCR,DNA,DNA,            	DNA,DNA) 



#define SUBFMEO_IMPL                                    \
  {                                                     \
 	sword_t _ra,_ca;                        	\
        _ra = ~((sword_t)GPR(RA));                 	\
        _ca = PPC_GET_XER_CA;                          	\
        if (OVER(_ra, (_ca-1))){            		\
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
        SET_GPR(RD, _ra +_ca-1);      			\
        if(carrygenerated(_ra, (_ca-1))){           	\
        PPC_SET_XER_CA;                                 \
        }                                               \
        else{ PPC_RESET_XER_CA;}                        \
  }

DEFINST(SUBFMEO,                	0x5D0,   
        "subfmeo",              	"d,a",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, DNA,
        DNA,DNA,DNA,            	DNA,DNA)

#define SUBFMEOD_IMPL                                   \
  {                                                     \
        sword_t  _src;                                  \
   	sword_t _ra,_ca;                               	\
        _ra = ~((sword_t)GPR(RA));                      \
        _ca = PPC_GET_XER_CA;                           \
        if (OVER(_ra,(_ca-1))){    			\
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
         _src = _ra + _ca -1;      			\
        SET_GPR(RD, _src);                              \
        if(!(_src)) PPC_SET_CR0_EQ;                     \
        else PPC_RESET_CR0_EQ;                          \
        if(_src>0) PPC_SET_CR0_GT;                      \
        else PPC_RESET_CR0_GT;                          \
        if(_src<0) PPC_SET_CR0_LT;                      \
        else PPC_RESET_CR0_LT;                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;              \
        else PPC_RESET_CR0_SO;                          \
        if(carrygenerated(_ra,(_ca-1))){		\
        PPC_SET_XER_CA;                                 \
        }                                               \
        else{ PPC_RESET_XER_CA;}                        \
  }


DEFINST(SUBFMEOD,               	0x5D1,
        "subfmeo.",             	"d,a",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, PPC_DCR,
        PPC_DCR,DNA,DNA,            	DNA,DNA)
        



#define ADDME_IMPL                              \
  {                                             \
    SET_GPR(RD, GPR(RA) + PPC_GET_XER_CA - 1 ); \
    if( carrygenerated(GPR(RA), (PPC_GET_XER_CA-1)) ){ \
        PPC_SET_XER_CA;                         \
    }                                           \
    else{ PPC_RESET_XER_CA;}                    \
  }


DEFINST(ADDME,                  	0x1D4,
        "addme",                	"d,a",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, DNA,
        DNA,DNA,DNA,            	DNA,DNA)




#define ADDMED_IMPL                             \
  {                                             \
    sword_t _src;                               \
    sword_t _ra,_ca;                        	\
    _ra = (sword_t)GPR(RA);                     \
    _ca =PPC_GET_XER_CA;                        \
    _src= _ra + _ca-1;                          \
    if( carrygenerated(_ra, (_ca-1)) ){         \
        PPC_SET_XER_CA;                         \
    }                                           \
    else{ PPC_RESET_XER_CA;}                    \
        if(!(_src)) PPC_SET_CR0_EQ;             \
        else PPC_RESET_CR0_EQ;                  \
        if(_src>0) PPC_SET_CR0_GT;              \
        else PPC_RESET_CR0_GT;                  \
        if(_src<0) PPC_SET_CR0_LT;              \
        else PPC_RESET_CR0_LT;                  \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;      \
        else PPC_RESET_CR0_SO;                  \
        SET_GPR(RD, _src);                      \
  }

DEFINST(ADDMED,                 	0x1D5,
        "addme.",               	"d,a,i",
        IntALU,                 	F_ICOMP,   
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, PPC_DCR,
        PPC_DCR,DNA,DNA,            	DNA,DNA)
    






#define ADDMEO_IMPL                                     \
  {                                                     \
        sword_t _ra,_ca;                        	\
        _ra = GPR(RA);                 			\
	_ca = PPC_GET_XER_CA;				\
	if (OVER(_ra, (_ca-1))){            		\
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
        SET_GPR(RD, _ra +_ca-1);   			\
        if(carrygenerated(_ra, (_ca-1))){           	\
        PPC_SET_XER_CA;                                 \
        }                                               \
        else{ PPC_RESET_XER_CA;}                        \
  }
    
DEFINST(ADDMEO,                 	0x5D4,
        "addmeo",               	"d,a",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, DNA,
        DNA,DNA,DNA,            	DNA,DNA)


#define ADDMEOD_IMPL                                    \
  {                                                     \
        sword_t  _src;                                  \
	 sword_t _ra,_ca;                            	\
        _ra = GPR(RA);                                  \
        _ca = PPC_GET_XER_CA;                           \
	if (OVER(_ra,_ca-1)){    			\
                PPC_SET_XER_SO; PPC_SET_XER_OV;         \
        }                                               \
        else {PPC_RESET_XER_OV;}                        \
         _src = _ra +_ca-1;           			\
        SET_GPR(RD, _src);                              \
        if(!(_src)) PPC_SET_CR0_EQ;                     \
        else PPC_RESET_CR0_EQ;                          \
        if(_src>0) PPC_SET_CR0_GT;                      \
        else PPC_RESET_CR0_GT;                          \
        if(_src<0) PPC_SET_CR0_LT;                      \
        else PPC_RESET_CR0_LT;                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;              \
        else PPC_RESET_CR0_SO;                          \
        if(carrygenerated(_ra,(_ca-1))){		\
        PPC_SET_XER_CA;                                 \
        }                                               \
        else{ PPC_RESET_XER_CA;}                        \
  }




DEFINST(ADDMEOD,                	0x5D5,
        "addmeo.",              	"d,a",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, PPC_DCR,
        PPC_DCR,DNA,DNA,            	DNA,DNA)




#define MULLW_IMPL                                      \
  {                                                     \
    sword_t _sw,_sh;                                    \
    sqword_t  _src;                                      \
   _sw = GPR(RA);                                       \
    _sh = GPR(RB);                                      \
    _src = _sw*_sh;                                     \
    SET_GPR(RD, (sword_t)(_src&0x00000000ffffffff));    \
   }

DEFINST(MULLW,                  0x1D6,
        "mullw",                "d,a,b",
        IntMULT,                F_ICOMP|F_LONGLAT,
        PPC_DGPR(RD), DNA,      PPC_DGPR(RA), PPC_DGPR(RB), DNA,
        DNA, DNA, DNA,          DNA, DNA)



#define MULLWO_IMPL                                     \
  {                                                     \
    sword_t _sw,_sh;                                    \
    sqword_t  _src;                                      \
   _sw = GPR(RA);                                       \
    _sh = GPR(RB);                                      \
    _src = _sw*_sh;                                     \
    SET_GPR(RD, (sword_t)(_src&0x00000000ffffffffll));    \
    if(_src&0xffffffff00000000ll){                        \
        PPC_SET_XER_SO; PPC_SET_XER_OV;                 \
     }                                                  \
     else PPC_RESET_XER_OV;                             \
   }
 
DEFINST(MULLWO,                 	0x5D6,
        "mullwo",               	"d,a,b",
        IntMULT,                	F_ICOMP|F_LONGLAT,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), DNA, PPC_DXER,
        DNA, DNA, DNA,          	DNA, DNA)



#define MULLWD_IMPL                                     \
{                                                       \
    sword_t _sw,_sh;                                    \
    sqword_t  _src;                                     \
    _sw = GPR(RA);                                      \
    _sh = GPR(RB);                                      \
    _src = _sw*_sh;                                     \
    SET_GPR(RD, (sword_t)(_src&0x00000000ffffffffll));  \
    if(!(_src)) PPC_SET_CR0_EQ;                         \
    else PPC_RESET_CR0_EQ;                              \
    if(_src>0) PPC_SET_CR0_GT;                          \
    else PPC_RESET_CR0_GT;                              \
    if(_src<0) PPC_SET_CR0_LT;                          \
    else PPC_RESET_CR0_LT;                              \
    if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                  \
    else PPC_RESET_CR0_SO;                              \
}

 
DEFINST(MULLWD,                 	0x1D7,
        "mullw.",               	"d,a,b",
        IntMULT,                	F_ICOMP|F_LONGLAT,
        PPC_DGPR(RD), PPC_DCR,          PPC_DGPR(RA), DNA, PPC_DCR,
        DNA, DNA, DNA,          	DNA, DNA)



#define MULLWOD_IMPL                                     \
{                                                        \
    sword_t _sw,_sh;                                     \
    sqword_t  _src;                                      \
    _sw = GPR(RA);                                       \
    _sh = GPR(RB);                                       \
    _src = _sw*_sh;                                      \
    SET_GPR(RD, (sword_t)(_src&0x00000000ffffffffll));   \
    if(_src&0xffffffff00000000ll) {                      \
        PPC_SET_XER_SO; PPC_SET_XER_OV;                  \
    }                                                    \
    else PPC_RESET_XER_OV;                               \
    if(!(_src)) PPC_SET_CR0_EQ;                          \
    else PPC_RESET_CR0_EQ;                               \
    if(_src>0) PPC_SET_CR0_GT;                           \
    else PPC_RESET_CR0_GT;                               \
    if(_src<0) PPC_SET_CR0_LT;                           \
    else PPC_RESET_CR0_LT;                               \
    if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                   \
    else PPC_RESET_CR0_SO;                               \
}
 
DEFINST(MULLWOD,                 	0x5D7,
        "mullow.",               	"d,a,b",
        IntMULT,                 	F_ICOMP|F_LONGLAT,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DXER, PPC_DCR,
        PPC_DCR, DNA, DNA,           	DNA, DNA)



#define ADD_IMPL				    \
{                                                   \
    SET_GPR(RD, GPR(RA) + GPR(RB));                 \
}

DEFINST(ADD,                    0x214,
        "add",                  "d,a,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RD), DNA,      PPC_DGPR(RA), PPC_DGPR(RB), DNA,
	DNA,DNA,DNA,		DNA,DNA)



#define ADDD_IMPL                                     	\
  {                                                     \
    sword_t  _src;                                      \
    sword_t _ra,_rb;					\
    _ra = GPR(RA);					\
    _rb = GPR(RB);					\
    _src = _ra + _rb;                                   \
        if(!(_src)) PPC_SET_CR0_EQ;                     \
        else PPC_RESET_CR0_EQ;                          \
        if(_src>0) PPC_SET_CR0_GT;                      \
        else PPC_RESET_CR0_GT;                          \
        if(_src<0) PPC_SET_CR0_LT;                      \
        else PPC_RESET_CR0_LT;                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;              \
        else PPC_RESET_CR0_SO;                          \
        SET_GPR(RD, _src);                              \
}
 
DEFINST(ADDD,                   	0x215,
        "add.",                 	"d,a,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DCR,          PPC_DGPR(RA), PPC_DGPR(RB), PPC_DCR,
	DNA,DNA,DNA,			DNA,DNA)





#define ADDO_IMPL					\
  {							\
	sword_t _ra,_rb;                        	\
        _ra = GPR(RA);                 			\
        _rb = GPR(RB);                          	\
	 if (OVER(_ra, _rb)){				\
         	PPC_SET_XER_SO; PPC_SET_XER_OV;	        \
	}						\
	else {PPC_RESET_XER_OV;}			\
        SET_GPR(RD, (_ra + _rb));		        \
  }

DEFINST(ADDO,                   	0x614,
        "addo",                 	"d,a,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER,
	DNA,DNA,DNA,			DNA,DNA)



#define ADDOD_IMPL                                      \
{                                                       \
    sword_t  _src;					\
    sword_t _ra,_rb;                        	        \
    _ra = GPR(RA);                 			\
    _rb = GPR(RB);                 			\
    if (OVER(_ra, _rb)){                    	        \
        PPC_SET_XER_SO; PPC_SET_XER_OV;                 \
    }                                                   \
    else {PPC_RESET_XER_OV;}                            \
    _src = _ra + _rb;				        \
    SET_GPR(RD, _src);                 		        \
    if(!(_src)) PPC_SET_CR0_EQ;		     	        \
    else PPC_RESET_CR0_EQ;				\
    if(_src>0) PPC_SET_CR0_GT;		       	        \
    else PPC_RESET_CR0_GT;				\
    if(_src<0) PPC_SET_CR0_LT;		       	        \
    else PPC_RESET_CR0_LT;			 	\
    if(PPC_GET_XER_SO) PPC_SET_CR0_SO;	       	        \
    else PPC_RESET_CR0_SO;				\
}
   
DEFINST(ADDOD,                  	0x615,
        "addo.",                	"d,a,b",
        IntALU,                 	F_ICOMP,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER,
        PPC_DCR,DNA,DNA,            	PPC_DCR,DNA)




#define EQV_IMPL			      		\
{						      	\
    SET_GPR( RA, ~( (GPR(RS))^(GPR(RB)) ) );	       	\
}

DEFINST(EQV,			0x238,
	"eqv",			"a,s,b",
	IntALU,			F_ICOMP,
	PPC_DGPR(RA),DNA,	PPC_DGPR(RS),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,        	DNA, DNA)



#define EQVD_IMPL                                                       \
   {                                                                    \
	word_t _src;							\
	_src= ~( (GPR(RS))^(GPR(RB)) );					\
	SET_GPR( RA, _src);						\
	if(!(_src)) PPC_SET_CR0_EQ;                                     \
        else PPC_RESET_CR0_EQ;                                          \
        if(_src>0) PPC_SET_CR0_GT;                                      \
        else PPC_RESET_CR0_GT;                                          \
        if(_src<0) PPC_SET_CR0_LT;                                      \
        else PPC_RESET_CR0_LT;                                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                              \
        else PPC_RESET_CR0_SO;                                          \
   }
    
DEFINST(EQVD,                   0x239,
        "eqv.",                 "a,s,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA),PPC_DCR,   PPC_DGPR(RS),PPC_DGPR(RB),PPC_DCR,
        DNA, DNA, DNA,        	DNA, DNA)



#define XOR_IMPL                                                        \
   {                                                                    \
        SET_GPR(RA, (GPR(RS) ^ GPR(RB)));                               \
   }

DEFINST(XOR,                    0x278,
        "xor",                  "a,s,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA),DNA,       PPC_DGPR(RS),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,        	DNA, DNA)


#define XORD_IMPL                                                       \
   {                                                                    \
        sword_t _src;                                                   \
        _src = GPR(RS) ^ GPR(RB);                                       \
        SET_GPR(RA, _src);                                              \
        if(!(_src)) PPC_SET_CR0_EQ;                                     \
        else PPC_RESET_CR0_EQ;                                          \
        if(_src>0) PPC_SET_CR0_GT;                                      \
        else PPC_RESET_CR0_GT;                                          \
        if(_src<0) PPC_SET_CR0_LT;                                      \
        else PPC_RESET_CR0_LT;                                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                              \
        else PPC_RESET_CR0_SO;                                          \
   }
    
DEFINST(XORD,                  0x279,
        "xor.",                "a,s,b",
        IntALU,                F_ICOMP,
        PPC_DGPR(RA),PPC_DCR,  PPC_DGPR(RS),PPC_DGPR(RB),PPC_DCR,
        DNA, DNA, DNA,         DNA, DNA)
        

#define ORC_IMPL					\
   {							\
        SET_GPR( RA, ( GPR(RS) | (~GPR(RB)) ) );	\
   }
        
DEFINST(ORC,                    0x338,
        "orc",                  "a,s,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA),DNA,       PPC_DGPR(RS),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,          DNA, DNA)

#define ORCD_IMPL				\
   {						\
        sword_t _src;				\
        _src = GPR(RS)| (~(GPR(RB)));		\
        SET_GPR(RA, _src);			\
        if(!(_src)) PPC_SET_CR0_EQ;    		\
        else PPC_RESET_CR0_EQ;			\
        if(_src>0) PPC_SET_CR0_GT;	       	\
        else PPC_RESET_CR0_GT;			\
        if(_src<0) PPC_SET_CR0_LT;	       	\
        else PPC_RESET_CR0_LT;			\
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;    	\
        else PPC_RESET_CR0_SO;			\
   }


DEFINST(ORCD,                  0x339,
        "orc.",                "a,s,b",
        IntALU,                F_ICOMP,
        PPC_DGPR(RA),PPC_DCR,  PPC_DGPR(RS),PPC_DGPR(RB),PPC_DCR,
        DNA, DNA, DNA,         DNA, DNA)
 


#define OR_IMPL	                                		        \
   {                                                                    \
        SET_GPR(RA, (GPR(RS) | GPR(RB)));                              	\
   }
   
DEFINST(OR,	                0x378,
        "or",                   "a,s,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA),DNA,       PPC_DGPR(RS),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,        	DNA, DNA)


#define ORD_IMPL                                                        \
   {                                                                    \
        sword_t _src;                                                   \
        _src = GPR(RS)| GPR(RB);                                        \
        SET_GPR(RA, _src);                                              \
        if(!(_src)) PPC_SET_CR0_EQ;                                     \
        else PPC_RESET_CR0_EQ;                                          \
        if(_src>0) PPC_SET_CR0_GT;                                      \
        else PPC_RESET_CR0_GT;                                          \
        if(_src<0) PPC_SET_CR0_LT;                                      \
        else PPC_RESET_CR0_LT;                                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                              \
        else PPC_RESET_CR0_SO;                                          \
   }

DEFINST(ORD,                   0x379,
        "or.",                 "a,s,b",
        IntALU,                F_ICOMP,
        PPC_DGPR(RA),PPC_DCR,  PPC_DGPR(RS),PPC_DGPR(RB),PPC_DCR,
        DNA, DNA, DNA,         DNA, DNA)



#define DIVWU_IMPL                                              \
  {                                                             \
    if (GPR(RB) == 0)                                           \
    {                                                           \
        /*do nothing*/                                          \
    }                                                           \
   else{                                                        \
    SET_GPR(RD, (word_t)GPR(RA) / (word_t)GPR(RB));		\
   }                                                            \
  }
        
DEFINST(DIVWU,                  0x396,
        "divwu",                "d,a,b",
        IntDIV,                 F_ICOMP|F_LONGLAT,
        PPC_DGPR(RD), DNA,      PPC_DGPR(RA), PPC_DGPR(RB), DNA,
        DNA, DNA, DNA,          DNA, DNA)


#define DIVWUD_IMPL                                             \
 {                                                             \
    word_t  _src;                                               \
    if (GPR(RB) == 0)                                           \
        {                                                       \
                /*do nothing*/                                  \
        }                                                       \
   else{                                                        \
    _src = (word_t)GPR(RA) / (word_t)GPR(RB);			\
        if(!(_src)) PPC_SET_CR0_EQ;                             \
        else PPC_RESET_CR0_EQ;                                  \
        if(_src>0) PPC_SET_CR0_GT;                              \
        else PPC_RESET_CR0_GT;                                  \
        if(_src<0) PPC_SET_CR0_LT;                              \
        else PPC_RESET_CR0_LT;                                  \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                      \
        else PPC_RESET_CR0_SO;                                  \
        SET_GPR(RD, _src);                                      \
      }                                                         \
  }

DEFINST(DIVWUD,                 	0x397,
        "divwu.",               	"d,a,b",
        IntDIV,                 	F_ICOMP|F_LONGLAT,
        PPC_DGPR(RD), PPC_DCR,          PPC_DGPR(RA), PPC_DGPR(RB), PPC_DCR,
        DNA, DNA, DNA,          	DNA, DNA)



#define DIVWUO_IMPL                                             \
  {                                                             \
    if (GPR(RB) == 0)                                           \
    {                                                           \
        PPC_SET_XER_OV;                                         \
    }                                                           \
   else{                                                        \
        SET_GPR(RD, (word_t)GPR(RA) / (word_t)GPR(RB));		\
        PPC_RESET_XER_OV;                                       \
   }                                                            \
  }
        
DEFINST(DIVWUO,                 	0x796,
        "divwuo",               	"d,a,b",
        IntDIV,                 	F_ICOMP|F_LONGLAT,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER,
        DNA, DNA, DNA,          	DNA, DNA)




#define DIVWUOD_IMPL                                            \
  {                                                             \
    word_t  _src;                                              	\
    if (GPR(RB) == 0)                                           \
        {                                                       \
        PPC_SET_XER_OV;                                         \
        }                                                       \
   else{                                                        \
        PPC_RESET_XER_OV;                                       \
        _src = (word_t)GPR(RA) / (word_t)GPR(RB);	        \
        if(!(_src)) PPC_SET_CR0_EQ;                             \
        else PPC_RESET_CR0_EQ;                                  \
        if(_src>0) PPC_SET_CR0_GT;                              \
        else PPC_RESET_CR0_GT;                                  \
        if(_src<0) PPC_SET_CR0_LT;                              \
        else PPC_RESET_CR0_LT;                                  \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                      \
        else PPC_RESET_CR0_SO;                                  \
        SET_GPR(RD, _src);                                      \
      }                                                         \
  }

DEFINST(DIVWUOD,                	0x797,
        "divwuo.",              	"d,a,b",
        IntDIV,                 	F_ICOMP|F_LONGLAT,
        PPC_DGPR(RD), PPC_DCR,          PPC_DGPR(RA), PPC_DGPR(RB), PPC_DCR,
        PPC_DXER, DNA, DNA,         	PPC_DXER, DNA)


#define NAND_IMPL                                                       \
   {                                                                    \
        SET_GPR(RA, ~(GPR(RS)& GPR(RB)));                               \
   }
   
DEFINST(NAND,                   0x3B8,
        "nand",                 "a,s,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA),DNA,       PPC_DGPR(RS),PPC_DGPR(RB),DNA,
        DNA, DNA, DNA,        	DNA, DNA)




#define NANDD_IMPL                                                      \
   {                                                                    \
        sword_t _src;                                                   \
        _src = ~(GPR(RS)& GPR(RB));                                     \
        SET_GPR(RA, _src);                                              \
        if(!(_src)) PPC_SET_CR0_EQ;                                     \
        else PPC_RESET_CR0_EQ;                                          \
        if(_src>0) PPC_SET_CR0_GT;                                      \
        else PPC_RESET_CR0_GT;                                          \
        if(_src<0) PPC_SET_CR0_LT;                                      \
        else PPC_RESET_CR0_LT;                                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                              \
        else PPC_RESET_CR0_SO;                                          \
   }

DEFINST(NANDD,                  0x3B9,
        "nand.",                "a,s,b",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA),PPC_DCR,   PPC_DGPR(RS),PPC_DGPR(RB),PPC_DCR,
        DNA, DNA, DNA,        	DNA, DNA)





#define EXTSB_IMPL							\
   {									\
   	SET_GPR( RA, SEXT8( GPR(RS) & 0xff ) );				\
   }

DEFINST(EXTSB,			0x774,
	"extsb",		"a,s",
	IntALU,			F_ICOMP,
	PPC_DGPR(RA),DNA,	PPC_DGPR(RS),DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)


#define EXTSBD_IMPL                                                     \
   {                                                                    \
	word_t _src;                                                    \
        _src= SEXT8(GPR(RS)&0xff);                             		\
        SET_GPR( RA, _src);                                             \
        if(!(_src)) PPC_SET_CR0_EQ;                                     \
        else PPC_RESET_CR0_EQ;                                          \
        if(_src>0) PPC_SET_CR0_GT;                                      \
        else PPC_RESET_CR0_GT;                                          \
        if(_src<0) PPC_SET_CR0_LT;                                      \
        else PPC_RESET_CR0_LT;                                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                              \
        else PPC_RESET_CR0_SO;                                          \
   }

DEFINST(EXTSBD,                 0x775,
        "extsb.",               "a,s",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA),PPC_DCR,   PPC_DGPR(RS),DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)




#define EXTSH_IMPL                                                      \
   {                                                                    \
        SET_GPR( RA, SEXT16(GPR(RS)&0xffff) );             		\
   }

DEFINST(EXTSH,                  0x734,
        "extsh",                "a,s",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA),DNA,       PPC_DGPR(RS),DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)



#define EXTSHD_IMPL                                                     \
   {                                                                    \
        word_t _src;                                                    \
        _src= SEXT16(GPR(RS)&0xffff);                                   \
        SET_GPR( RA, _src);                                             \
        if(!(_src)) PPC_SET_CR0_EQ;                                     \
        else PPC_RESET_CR0_EQ;                                          \
        if(_src>0) PPC_SET_CR0_GT;                                      \
        else PPC_RESET_CR0_GT;                                          \
        if(_src<0) PPC_SET_CR0_LT;                                      \
        else PPC_RESET_CR0_LT;                                          \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                              \
        else PPC_RESET_CR0_SO;                                          \
   }
        
DEFINST(EXTSHD,                 0x735,
        "extsh.",               "a,s",
        IntALU,                 F_ICOMP,
        PPC_DGPR(RA),PPC_DCR,   PPC_DGPR(RS),DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)



/*This does not generate a divide by zero exception so the body is
left blank. If there are modfications, they can be pulgged easily*/

#define DIVW_IMPL               	                        \
  {                                                             \
    if (GPR(RB) == 0)  						\
    {								\
	/*do nothing*/						\
    }								\
    else if( ((sword_t)GPR(RB)==(-1)) && ((word_t)GPR(RA)==0x80000000) )\
	 {							\
	/*do nothing*/						\
	}							\
   else{							\
    SET_GPR(RD, GPR(RA) / GPR(RB));				\
   }								\
  }

DEFINST(DIVW,                   0x3D6,
        "divw",                 "d,a,b", 
        IntDIV,                 F_ICOMP|F_LONGLAT,
        PPC_DGPR(RD), DNA,      PPC_DGPR(RA), PPC_DGPR(RB), DNA,
        DNA, DNA, DNA,        	DNA, DNA)





#define DIVWO_IMPL                                              \
  {                                                             \
    if (GPR(RB) == 0)                                           \
    {                                                           \
	PPC_SET_XER_OV;						\
    }                                                           \
    else if( ((sword_t)GPR(RB)==(-1)) && ((word_t)GPR(RA)==0x80000000) )\
    {                                                           \
	PPC_SET_XER_OV;						\
     }                                                          \
   else{                                                        \
    	SET_GPR(RD, GPR(RA) / GPR(RB));                         \
	PPC_RESET_XER_OV;				      	\
   }    	                                                \
  }

 
DEFINST(DIVWO,                  0x7D6,
        "divwo",                "d,a,b",
        IntDIV,                 F_ICOMP|F_LONGLAT,
        PPC_DGPR(RD), PPC_DXER,         PPC_DGPR(RA), PPC_DGPR(RB), PPC_DXER,
        DNA, DNA, DNA,          DNA, DNA)






#define DIVWD_IMPL	                                        \
  {                                                             \
    sword_t  _src;					 	\
    if (GPR(RB) == 0)                                           \
    	{                                                       \
        	/*do nothing*/                                  \
    	}                                                       \
    else if( ((sword_t)GPR(RB)==(-1)) && ((word_t)GPR(RA)==0x80000000) )\
         {                                                      \
        /*do nothing*/                                          \
        }                                                       \
   else{                                                        \
    _src = GPR(RA) / GPR(RB);                                   \
        if(!(_src)) PPC_SET_CR0_EQ;                             \
        else PPC_RESET_CR0_EQ;                                  \
        if(_src>0) PPC_SET_CR0_GT;                              \
        else PPC_RESET_CR0_GT;                                  \
        if(_src<0) PPC_SET_CR0_LT;                              \
        else PPC_RESET_CR0_LT;                                  \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                      \
        else PPC_RESET_CR0_SO;                                  \
	SET_GPR(RD, _src);                                 	\
      }								\
  }

DEFINST(DIVWD,                  	0x3D7,
        "divw.",                	"d,a,b",
        IntDIV,                 	F_ICOMP|F_LONGLAT,
        PPC_DGPR(RD), PPC_DCR,          PPC_DGPR(RA), PPC_DGPR(RB), PPC_DCR,
        DNA, DNA, DNA,        		DNA, DNA)






#define DIVWOD_IMPL						\
  {                                                             \
    sword_t  _src;                                              \
    if (GPR(RB) == 0)                                           \
        {                                                       \
	PPC_SET_XER_OV;						\
        }                                                       \
    else if( ((sword_t)GPR(RB)==(-1)) && ((word_t)GPR(RA)==0x80000000) )\
         {                                                      \
	PPC_SET_XER_OV;						\
        }                                                       \
   else{                                                        \
	PPC_RESET_XER_OV;					\
        _src = GPR(RA) / GPR(RB);                               \
        if(!(_src)) PPC_SET_CR0_EQ;                             \
        else PPC_RESET_CR0_EQ;                                  \
        if(_src>0) PPC_SET_CR0_GT;                              \
        else PPC_RESET_CR0_GT;                                  \
        if(_src<0) PPC_SET_CR0_LT;                              \
        else PPC_RESET_CR0_LT;                                  \
        if(PPC_GET_XER_SO) PPC_SET_CR0_SO;                      \
        else PPC_RESET_CR0_SO;                                  \
        SET_GPR(RD, _src);                                      \
      }                                                         \
  }

DEFINST(DIVWOD,                 	0x7D7,
        "divwo.",               	"d,a,b",
        IntDIV,                 	F_ICOMP|F_LONGLAT,
        PPC_DGPR(RD), PPC_DCR,          PPC_DGPR(RA), PPC_DGPR(RB), PPC_DCR,
        PPC_DXER, DNA, DNA,         	PPC_DXER, DNA)
 

CONNECT(FDIVS_LINK)


#ifdef __ppc__
#define FDIVS_IMPL_PPC_ASM(double_dest,fpscrout,fpscrin,double_a,double_b) {  \
    asm ("mtfsf 0xFF,%2\n fdivs %0,%3,%4\n mffs %1"     \
         : "=f" (double_dest), "=f" (fpscrout)          \
         : "f" (fpscrin), "f" (double_a),               \
           "f" (double_b) );                \
}
#else
#define FDIVS_IMPL_PPC_ASM(one,two,three,four,five) {}
#endif


#define FDIVS_IMPL                                     \
{                                                       \
    qword_t _a, _b;                                      \
    qword_t *dest;                                        \
    double double_a, double_b, double_dest;                \
    double fpscrin=0, fpscrout;			     \
    int *fp1;                                                \
    word_t _fp;                                               \
    if(PPC_INSTRUCTION_MODE) {                                 \
        _fp = FPSCR;                                            \
        fp1 = (int *)(&fpscrin)+1;                              \
        memcpy(fp1, &_fp, 4);                                   \
        _a = PPC_FPR_DW(RA);                                    \
        _b = PPC_FPR_DW(RB);                                    \
        memcpy(&double_a, &_a, sizeof(_a));                     \
        memcpy(&double_b, &_b, sizeof(_b));                     \
        if(ppcInstruction::fpu_mode_cplusplus) {                \
            double_dest = double_a / double_b;                  \
        } else if(ppcInstruction::fpu_mode_software) {          \
            /* WCM: TODO SOFTFLOAT IMPLEMENTATION */            \
	    fprintf(stderr,"need softfloat implementation of fdivs\n"); \
	    assert(0);                                          \
        } else if(ppcInstruction::fpu_mode_asm_ppc)  {          \
            /* double_dest = double_a * double_c; */            \
            asm ("mtfsf 0xFF,%2\n fdivs %0,%3,%4\n mffs %1"     \
                 : "=f" (double_dest), "=f" (fpscrout)          \
                 : "f" (fpscrin), "f" (double_a),               \
                   "f" (double_b) );                            \
            fp1 = (int *) (&fpscrout);                          \
            memcpy(&_fp, (fp1+1), 4);                           \
	}                                                       \
        dest = (qword_t *) (&double_dest);                      \
        PPC_SET_FPR_DW(FD, *dest);                              \
        /*PPC_SET_FPSCR( *(int *) (fp1+1));*/                   \
        PPC_SET_FPSCR(_fp);                                     \
        if(ppcInstruction::debugPrintFPSCR) {                   \
            printf("FPSCR: %#x fdivs (%g / %g = %g)\n",         \
                   _fp,double_a,double_b,double_dest);          \
        }                                                       \
    }                                                           \
}
                                                         
DEFINST(FDIVS,                  0x24,
        "fdivs",                "D,A,B",
        FloatDIV,               F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,  PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPSCR,
        DNA, DNA, DNA,          DNA, DNA)


#define FDIVSD_IMPL                                     \
  {                                                     \
	 FDIVS_IMPL;											\
    PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000)); \
  }

DEFINST(FDIVSD,                 	0x25,
        "fdivs.",               	"D,A,B",
        FloatDIV,               	F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,       PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPSCR,
        PPC_DCR, DNA, DNA,          	PPC_DCR, DNA)



#define FSUBS_IMPL                                 \
{                                                   \
    qword_t _a, _b;                                  \
    qword_t *dest;                                    \
    double double_a, double_b, double_dest;            \
    double fpscrin=0.0, fpscrout;                       \
    int *fp1;                                            \
    word_t _fp;                                           \
    if(PPC_INSTRUCTION_MODE) {                             \
        _fp = FPSCR;                                        \
        fp1 = (int *)(&fpscrin)+1;                          \
        memcpy(fp1, &_fp, 4);                               \
        _a = PPC_FPR_DW(RA);                                \
        _b = PPC_FPR_DW(RB);                                \
        memcpy(&double_a, &_a, sizeof(_a));	            \
        memcpy(&double_b, &_b, sizeof(_b));		    \
        if(ppcInstruction::fpu_mode_cplusplus ||            \
           ppcInstruction::fpu_mode_software) {             \
            double_dest = double_a - double_b;              \
        } else if(ppcInstruction::fpu_mode_software) {      \
            /* WCM: TODO SOFTFLOAT IMPLEMENTATION */        \
	    fprintf(stderr,"need softfloat implementation of fsubs\n"); \
	    assert(0);                                          \
        } else if(ppcInstruction::fpu_mode_asm_ppc) {       \
            /* double_dest = double_a - double_b;      */   \
            asm("mtfsf 0xFF,%2\n fsubs %0,%3,%4\n mffs %1"  \
                : "=f" (double_dest), "=f" (fpscrout)       \
                : "f" (fpscrin), "f" (double_a),            \
                  "f" (double_b) );                         \
            fp1 = (int *) (&fpscrout);                      \
            memcpy(&_fp, (fp1+1), 4);                       \
        }                                                   \
        dest = (qword_t *) (&double_dest);                  \
        PPC_SET_FPR_DW(FD, *dest);                          \
        PPC_SET_FPSCR(_fp);                                 \
        /*PPC_SET_FPSCR( *(int *) (fp1+1));*/               \
        if(ppcInstruction::debugPrintFPSCR) {               \
            printf("FPSCR: %#x fsubs (%g - %g = %g)\n",     \
                   _fp, double_a, double_b, double_dest);   \
        }                                                   \
    }                                                       \
}
        
DEFINST(FSUBS,                  	0x28,   
        "fsubs",                	"D,A,B",
        FloatADD,               	F_FCOMP, 
        PPC_DFPR(FD), PPC_DFPSCR,       PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPSCR,
        DNA, DNA, DNA,          	DNA, DNA)




#define FSUBSD_IMPL                                     \
  {                                                     \
	 FSUBS_IMPL;					\
    PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000)); \
  }

DEFINST(FSUBSD,                 	0x29,
        "fsubs.",               	"D,A,B",
        FloatADD,               	F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,       PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPSCR,
        PPC_DCR, DNA, DNA,          	PPC_DCR, DNA)




#define FADDS_IMPL                             \
{                                               \
    qword_t _a, _b;                              \
    qword_t *dest;                                \
    double double_a, double_b, double_dest;        \
    double fpscrin=0.0, fpscrout;                   \
    int *fp1;                                        \
    word_t _fp;                                       \
    if(PPC_INSTRUCTION_MODE) {                         \
        _fp = FPSCR;                                    \
        fp1 = (int *)(&fpscrin)+1;                       \
        memcpy(fp1, &_fp, 4);                             \
        _a = PPC_FPR_DW(RA);                               \
        _b = PPC_FPR_DW(RB);                                \
        memcpy(&double_a, &_a, sizeof(_a));		     \
        memcpy(&double_b, &_b, sizeof(_b));		      \
        if(ppcInstruction::fpu_mode_cplusplus) {               \
            double_dest = double_a + double_b;                 \
        } else if(ppcInstruction::fpu_mode_software) {         \
            float32 f32_a, f32_b, f32_dest;                    \
            float a,b,dest;                                    \
            a = (float)double_a;                               \
            b = (float)double_b;                               \
            float_rounding_mode = PPCHW_GET_FPSCR_RN(FPSCR);   \
            memcpy(&f32_a, &a, sizeof(float32));               \
            memcpy(&f32_b, &b, sizeof(float32));               \
	    f32_dest = float32_add(f32_a, f32_b);              \
            memcpy(&dest, &f32_dest, sizeof(float));           \
            double_dest = (double)dest;                        \
            _fp = fpscr_set_S(_fp, FP_ADDOP, dest, a, b,       \
                              float_exception_flags,           \
                              float_rounding_flags);           \
        } else if(ppcInstruction::fpu_mode_asm_ppc)  {         \
            asm("mtfsf 0xFF,%2\n fadds %0,%3,%4\n mffs %1"     \
                : "=f" (double_dest),                          \
                  "=f" (fpscrout)                              \
                : "f" (fpscrin),                               \
                  "f" (double_a),                              \
                  "f" (double_b) );                            \
            fp1 = (int *) (&fpscrout);                         \
            memcpy(&_fp, (fp1+1), 4);                          \
        }                                                      \
        dest = (qword_t *) (&double_dest);                     \
        PPC_SET_FPR_DW(FD, *dest);                             \
        PPC_SET_FPSCR(_fp);                                    \
        if(ppcInstruction::debugPrintFPSCR) {                  \
            printf("FPSCR: %#x fadds (%g + %g = %g)\n",        \
                   _fp, double_a, double_b, double_dest);           \
        }                                                      \
    }                                                          \
}

DEFINST(FADDS,                      0x2A,
        "fadds",                    "D,A,B",
        FloatADD,                   F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,   PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPSCR,
        DNA, DNA, DNA,              DNA, DNA)
                


#define FADDSD_IMPL                                       \
{                                                         \
    FADDS_IMPL                                            \
    PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000));   \
}

DEFINST(FADDSD,                 	0x2B,
        "fadds.",               	"D,A,B",
        FloatADD,       		F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,       PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPSCR,
        PPC_DCR, DNA, DNA,          	PPC_DCR, DNA)



#define FMULS_IMPL                                  \
{                                                    \
    qword_t _a, _c;                                   \
    qword_t *dest;                                     \
    double double_a, double_c, double_dest;             \
    double fpscrin=0.0, fpscrout;                        \
    int *fp1;                                             \
    word_t _fp;                                            \
    if(PPC_INSTRUCTION_MODE) {                              \
        _fp = FPSCR;                                         \
        fp1 = (int *)(&fpscrin)+1;                           \
        memcpy(fp1, &_fp, 4);                                \
        _a = PPC_FPR_DW(RA);                                 \
        _c = PPC_FPR_DW(RC);                                 \
        memcpy(&double_a, &_a, sizeof(_a));                  \
        memcpy(&double_c, &_c, sizeof(_c));                  \
        if(ppcInstruction::fpu_mode_cplusplus) {             \
            double_dest = double_a * double_c;               \
        } else if (ppcInstruction::fpu_mode_software) {      \
	    fprintf(stderr,"need softfloat implementation of fmuls\n"); \
	    assert(0); \
        } else if(ppcInstruction::fpu_mode_asm_ppc) {        \
            /* double_dest = double_a * double_c;  */        \
            asm ("mtfsf 0xFF,%2\n fmuls %0,%3,%4\n mffs %1"  \
                 : "=f" (double_dest), "=f" (fpscrout)       \
                 : "f" (fpscrin), "f" (double_a),            \
                   "f" (double_c) );                         \
            fp1 = (int *) (&fpscrout);                       \
            memcpy(&_fp, (fp1+1), 4);                        \
        }                                                    \
        dest = (qword_t *) (&double_dest);                   \
        /*PPC_SET_FPSCR( *(int *) (fp1+1));*/                \
        PPC_SET_FPSCR(_fp);                                  \
        PPC_SET_FPR_DW(FD, *dest);                           \
        if(ppcInstruction::debugPrintFPSCR) {                \
            printf("FPSCR: %#x fmuls (%g * %g = %g)\n",      \
                   _fp,double_a,double_c,double_dest);       \
        }                                                    \
    }                                                        \
}
        
DEFINST(FMULS,                  	0x32,
        "fmuls",                	"D,A,C",
        FloatMULT,              	F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,       PPC_DFPR(FA), PPC_DFPR(FC), PPC_DFPSCR,
        DNA, DNA, DNA,          	DNA, DNA)


#define FMULSD_IMPL                                      \
{                                                        \
    FMULS_IMPL;						 \
    PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000));  \
}

DEFINST(FMULSD,                   0x33,
        "fmuls.",                 "D,A,C",
        FloatMULT,                F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR, PPC_DFPR(FA), PPC_DFPR(FC), PPC_DFPSCR,
        PPC_DCR, DNA, DNA,        PPC_DCR, DNA)
  

#define FRES_IMPL					 \
{							 \
    qword_t _a;                                          \
    qword_t *dest;                                       \
    double /*double_a,*/ double_dest;                        \
    float fdest;                        /*wcm*/      \
    /*double fpscrin=0, fpscrout;*/     /*wcm*/      \
    /*int *fp1;                  */     /*wcm*/      \
    /*word_t _fp;                */     /*wcm*/      \
    printf("not implemented fres\n");		         \
    assert(0); \
    _a = PPC_FPR_DW(FB);                                 \
    /*memcpy(&double_a, &_a, sizeof(_a));*/			 \
    fdest = (float) 1.0/_a;             /*wcm*/      \
    double_dest = (double)fdest;        /*wcm*/      \
    /*asm ("mtfsf 0xFF,%2\n fabs %0,%3\n mffs %1" */  /*wcm*/ \
    /*     : "=f" (double_dest), "=f" (fpscrout)  */  /*wcm*/ \
    /*     : "f" (fpscrin), "f" (double_a) );     */  /*wcm*/ \
    /*fp1 = (int *) (&fpscrout);*/      /*wcm*/      \
    /*memcpy(&_fp, (fp1+1), 4);*/       /*wcm*/      \
    dest = (qword_t *) (&double_dest);                   \
    PPC_SET_FPR_DW(FD, *dest);                           \
    /*PPC_SET_FPSCR(*(int *)(fp1+1));*/  /*wcm*/     \
}

DEFINST(FRES,				0x30,
	"fres",				"D,B",
	FloatDIV,			F_FCOMP,
	PPC_DFPR(FD), PPC_DFPSCR,	PPC_DFPR(FB), PPC_DFPSCR,DNA,
	DNA, DNA, DNA,			DNA,DNA)


#define FRESD_IMPL					          \
{							          \
    qword_t  _b, _fc;                                             \
    word_t  _fp=0;						  \
    dfloat_t _fb;					          \
    qword_t  _a;       				                  \
    _b =  PPC_FPR_DW(FB);				          \
    _fb = PPC_FPR(FB);				                  \
    if(_b==NEGINFSP){				                  \
        PPC_SET_FPR_DW(FD,NEGZEROSP);	     	                  \
        PPC_SET_FPSCR_FPRF(0x12);		                  \
    }						                  \
    else if(_b==POSINFSP){				          \
        PPC_SET_FPR_DW(FD,POSZEROSP);		                  \
        PPC_SET_FPSCR_FPRF(0x02);		                  \
    }						                  \
    else if(_b==NEGZEROSP){				          \
        PPC_SET_FPR_DW(FD,NEGINFSP);		                  \
        PPC_SET_FPSCR_ZX;			                  \
        PPC_SET_FPSCR_FX;			                  \
        PPC_SET_FPSCR_FPRF(0x09);		                  \
    }						                  \
    else if(_b==POSZEROSP){				          \
        PPC_SET_FPR_DW(FD,POSINFSP);		                  \
        PPC_SET_FPSCR_ZX;			                  \
        PPC_SET_FPSCR_FX;			                  \
        PPC_SET_FPSCR_FPRF(0x3);		                  \
    }						                  \
    else if(isspSNan(_b)){				          \
        PPC_SET_FPR_DW(FD,_b|0x0008000000000000ll);	          \
        PPC_SET_FPSCR_VXSNAN;			                  \
        PPC_SET_FPSCR_FX;			                  \
        PPC_SET_FPSCR_FPRF(0x11);		                  \
    }						                  \
    else if(isspQNan(_b)){				          \
        PPC_SET_FPR_DW(FD,_b);      		                  \
        PPC_SET_FPSCR_FPRF(0x11);                                 \
    }						                  \
    else {						          \
        _fb=1.0/_fb;				                  \
        _fp=FPSCR;				                  \
        _fc=*(qword_t*)(&_fb);                                    \
	qword_t _fd = 0;                                          \
	unsigned long long int __fd = _fd;                        \
        ieee_CVTTS((_fp&0x3),_fc,&__fd,&_fp);    /* wcm:bugged? */ \
	_fd = __fd;                          \
        PPC_SET_FPSCR(_fp);                                       \
        PPC_SET_FPR_DW(FD,_fd);                                   \
        _a = *(qword_t*)(& _fb);		                  \
        if(_fb<0.0){				                  \
            if(_a&0x7f80000000000000ll) PPC_SET_FPSCR_FPRF(0x8);  \
            else PPC_SET_FPSCR_FPRF(0x18);	                  \
        }					                  \
        else{					                  \
            if(_a&0x7f80000000000000ll) PPC_SET_FPSCR_FPRF(0x4);  \
            else PPC_SET_FPSCR_FPRF(0x14);	                  \
        }					                  \
    }						                  \
    PPC_SET_CR((CR & 0xf0ffffffll) |(FPSCR &0x0f000000ll));       \
}


DEFINST(FRESD,				0x31,
	"fres.",			"D,B",
	FloatDIV,			F_FCOMP,
	PPC_DFPR(FD), PPC_DFPSCR,	PPC_DFPR(FB), PPC_DFPSCR,DNA,
	PPC_DCR, DNA, DNA,		DNA,DNA)



/* frD = -( (frA * frC) - frB ) */
#define FNMSUBS_IMPL                                          \
{                                                              \
    qword_t _a, _b,_c;                                          \
    double double_a, double_b, double_c;                         \
    double double_dest;                                           \
    double fpscrin=0.0, fpscrout;                                 \
    qword_t *dest;                                                \
    word_t _fp;                                                   \
    int *fp1;                                                     \
    if(PPC_INSTRUCTION_MODE) {                                    \
        _fp = FPSCR;                                              \
        fp1 = (int *)(&fpscrin)+1;                                \
        memcpy(fp1, &_fp, 4);                                     \
        _a = PPC_FPR_DW(FA);                                      \
        _b = PPC_FPR_DW(FB);                                      \
        _c = PPC_FPR_DW(FC);                                      \
        memcpy(&double_a, &_a, sizeof(_a));                       \
        memcpy(&double_b, &_b, sizeof(_b));                       \
        memcpy(&double_c, &_c, sizeof(_c));                       \
        if(ppcInstruction::fpu_mode_cplusplus) {                  \
            double_dest = -((double_a*double_c)-double_b);        \
        } else if(ppcInstruction::fpu_mode_software) {            \
	    fprintf(stderr,"need softfloat implementation of fnmsubs\n"); \
	    assert(0); \
        } else if(ppcInstruction::fpu_mode_asm_ppc) {             \
            /* double_dest = double_a * double_c - double_b;  */  \
            asm ("mtfsf 0xFF,%2\n fnmsubs %0,%3,%4,%5\n mffs %1"  \
                : "=f" (double_dest), "=f" (fpscrout)             \
                : "f" (fpscrin), "f" (double_a),                  \
                  "f" (double_c), "f" (double_b) );               \
            fp1 = (int *) (&fpscrout);                            \
            memcpy(&_fp, (fp1+1), 4);                             \
        }                                                         \
        dest = (qword_t *) (&double_dest);                        \
        PPC_SET_FPR_DW(FD, *dest);                                \
        PPC_SET_FPSCR(_fp);                                       \
        /*PPC_SET_FPSCR(*(int*)(fp1+1));*/                        \
        if(ppcInstruction::debugPrintFPSCR) {                     \
            printf("FPSCR: %#x fnmsubs -[(%g * %g)-%g] = %g\n",   \
                   _fp,double_a,double_c,double_b,double_dest);   \
        }                                                         \
    }                                                             \
}
        
DEFINST(FNMSUBS,                      0x3C,
        "fnmsubs",                    "D,A,C,B",
        FloatMULT,           F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,     PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPR(FC),
        DNA, DNA, DNA,                PPC_DFPSCR, DNA)




#define FNMSUBSD_IMPL                                          \
  {                                                            \
	FNMSUBS_IMPL;                                          \
        PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000));    \
  }

DEFINST(FNMSUBSD,                     0x3D,
        "fnmsubs.",                   "D,A,C,B",
        FloatMULT,           F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,     PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPR(FC),
        PPC_DCR, DNA, DNA,            PPC_DFPSCR, PPC_DCR)


#define FMSUBS_IMPL                                 \
{                                                    \
    qword_t _a, _b,_c;                                \
    double double_a, double_b, double_c;               \
    double double_dest;                                 \
    double fpscrin=0.0, fpscrout;                        \
    qword_t *dest;                                        \
    word_t _fp;                                            \
    int *fp1;                                               \
    if(PPC_INSTRUCTION_MODE) {                               \
        _fp = FPSCR;                                          \
        fp1 = (int *)(&fpscrin)+1;                             \
        memcpy(fp1, &_fp, 4);                                   \
        _a = PPC_FPR_DW(FA);                                     \
        _b = PPC_FPR_DW(FB);                                      \
        _c = PPC_FPR_DW(FC);                                       \
        memcpy(&double_a, &_a, sizeof(_a));                         \
        memcpy(&double_b, &_b, sizeof(_b));                         \
        memcpy(&double_c, &_c, sizeof(_c));	                    \
        if(ppcInstruction::fpu_mode_cplusplus) {                    \
            double_dest = (double_a*double_c)-double_b;             \
        } else if(ppcInstruction::fpu_mode_software) {              \
	    fprintf(stderr,"need softfloat implementation of fmsubs\n"); \
	    assert(0); \
        } else if(ppcInstruction::fpu_mode_asm_ppc) {               \
            asm ("mtfsf 0xFF,%2\n fmsubs %0,%3,%4,%5\n mffs %1"     \
                : "=f" (double_dest), "=f" (fpscrout)               \
                : "f" (fpscrin), "f" (double_a),                    \
                  "f" (double_c), "f" (double_b) );                 \
            fp1 = (int *) (&fpscrout);                              \
            memcpy(&_fp, (fp1+1), 4);                               \
        }                                                           \
        dest = (qword_t *) (&double_dest);                          \
        PPC_SET_FPR_DW(FD, *dest);                                  \
        PPC_SET_FPSCR(_fp);                                         \
        if(ppcInstruction::debugPrintFPSCR) {                       \
            printf("FPSCR: %#x fmsubs (%g * %g) - %g = %g\n",       \
                   _fp,double_a,double_c,double_b,double_dest);     \
        }                                                           \
    }                                                               \
}

DEFINST(FMSUBS,                       0x38,   
        "fmsubs",                     "D,A,C,B",
        FloatMULT,           F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,     PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPR(FC),
        DNA, DNA, DNA,                PPC_DFPSCR, DNA)

#define FMSUBSD_IMPL                                      \
{                                                         \
    FMSUBS_IMPL;                                          \
    PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000));   \
}
   
DEFINST(FMSUBSD,                      0x39,
        "fmsubs.",                    "D,A,C,B",
        FloatMULT,           F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,     PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPR(FC),
        PPC_DCR, DNA, DNA,            PPC_DFPSCR, PPC_DCR)





#define FMADDS_IMPL                                      \
{                                                         \
    qword_t _a, _b,_c;                                     \
    double double_a, double_b, double_c;                    \
    double double_dest;                                      \
    double fpscrin=0.0, fpscrout;                             \
    qword_t *dest;                                             \
    int *fp1;                                                   \
    word_t _fp;                                                  \
    if(PPC_INSTRUCTION_MODE) {                                    \
        _fp = FPSCR;                                               \
        fp1 = (int *)(&fpscrin)+1;                                  \
        memcpy(fp1, &_fp, 4);                                        \
        _a = PPC_FPR_DW(FA);                                         \
        _b = PPC_FPR_DW(FB);                                         \
        _c = PPC_FPR_DW(FC);                                         \
        memcpy(&double_a, &_a, sizeof(_a));	                     \
        memcpy(&double_b, &_b, sizeof(_b));                          \
        memcpy(&double_c, &_c, sizeof(_c));                          \
        if(ppcInstruction::fpu_mode_cplusplus) {                     \
            double_dest = (double_a*double_c)+double_b;              \
        } else if (ppcInstruction::fpu_mode_software) {              \
	    fprintf(stderr,"need softfloat implementation of fmadds\n"); \
	    assert(0); \
        } else if(ppcInstruction::fpu_mode_asm_ppc)  {               \
            /* double_dest = double_a * double_c + double_b;   */    \
            asm ("mtfsf 0xFF,%2\n fmadds %0,%3,%4,%5\n mffs %1"      \
                 : "=f" (double_dest), "=f" (fpscrout)               \
                 : "f" (fpscrin), "f" (double_a),                    \
                   "f" (double_c), "f" (double_b) );                 \
            fp1 = (int *) (&fpscrout);                               \
            memcpy(&_fp, (fp1+1), 4);                                \
        }                                                            \
        dest = (qword_t *) (&double_dest);                           \
        PPC_SET_FPR_DW(FD, *dest);                                   \
        PPC_SET_FPSCR(_fp);                                          \
        /*PPC_SET_FPSCR( *(int *) (fp1+1));*/                        \
        if(ppcInstruction::debugPrintFPSCR) {                        \
            printf("FPSCR: %#x fmadds (%g * %g) + %g = %g\n",        \
                   _fp,double_a,double_c,double_b,double_dest);      \
        }                                                            \
    }                                                                \
}
        
DEFINST(FMADDS,                 	0x3A,
        "fmadds",               	"D,A,C,B",
        FloatMULT,     	F_FCOMP, 
        PPC_DFPR(FD), PPC_DFPSCR,       PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPR(FC),
        DNA, DNA, DNA,          	PPC_DFPSCR, DNA)




#define FMADDSD_IMPL                                    \
  {                                                     \
	FMADDS_IMPL;                                    \
   PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000));  \
  }
   
DEFINST(FMADDSD,                      0x3B,
        "fmadds.",                    "D,A,C,B",    
        FloatMULT,           F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,     PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPR(FC),
        PPC_DCR, DNA, DNA,            PPC_DFPSCR, PPC_DCR)



        
#define FNMADDS_IMPL                                     \
{                                                         \
    qword_t _a, _b,_c;                                     \
    double double_a, double_b, double_c;                    \
    double double_dest;                                      \
    double fpscrin=0.0, fpscrout;                             \
    qword_t *dest;                                             \
    word_t _fp;                                                 \
    int *fp1;                                                    \
    if(PPC_INSTRUCTION_MODE) {                                    \
        _fp = FPSCR;                                               \
        fp1 = (int *)(&fpscrin)+1;                                  \
        memcpy(fp1, &_fp, 4);                                        \
        _a = PPC_FPR_DW(FA);                                         \
        _b = PPC_FPR_DW(FB);                                         \
        _c = PPC_FPR_DW(FC);                                         \
        memcpy(&double_a, &_a, sizeof(_a));			     \
        memcpy(&double_b, &_b, sizeof(_b));			     \
        memcpy(&double_c, &_c, sizeof(_c));			     \
        if(ppcInstruction::fpu_mode_cplusplus) {                     \
            double_dest = -((double_a*double_c)+double_b);           \
        } else if (ppcInstruction::fpu_mode_software) {              \
	    fprintf(stderr,"need softfloat implementation of fnmadds\n"); \
	    assert(0); \
        } else if(ppcInstruction::fpu_mode_asm_ppc) {                \
            /* double_dest = -(double_a * double_c + double_b);*/    \
            asm ("mtfsf 0xFF,%2\n fnmadds %0,%3,%4,%5\n mffs %1"     \
                 : "=f" (double_dest), "=f" (fpscrout)               \
                 : "f" (fpscrin), "f" (double_a),                    \
                   "f" (double_c), "f" (double_b) );                 \
            fp1 = (int *) (&fpscrout);                               \
            memcpy(&_fp, (fp1+1), 4);                                \
        }                                                            \
        dest = (qword_t *) (&double_dest);                           \
        PPC_SET_FPR_DW(FD, *dest);                                   \
        PPC_SET_FPSCR(_fp);                                          \
        /*PPC_SET_FPSCR( *(int *) (fp1+1));*/                        \
        if(ppcInstruction::debugPrintFPSCR) {                        \
            printf("FPSCR: %#x fnmadds -[(%g * %g) + %g] = %g\n",    \
                   _fp, double_a, double_c, double_b, double_dest);  \
        }                                                            \
    }                                                                \
}


DEFINST(FNMADDS,                      0x3E,
        "fnmadds",                    "D,A,C,B",
        FloatMULT,           F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,     PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPR(FC),
        DNA, DNA, DNA,                PPC_DFPSCR, DNA)



#define FNMADDSD_IMPL                                          \
  {                                                            \
   FNMADDS_IMPL;				               \
	PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000));    \
  }

DEFINST(FNMADDSD,                     0x3F,
        "fnmadds.",                   "D,A,C,B",
        FloatMULT,           F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,     PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPR(FC),
        PPC_DCR, DNA, DNA,            PPC_DFPSCR, PPC_DCR)

#ifdef __ppc__
#define FSQRTS_IMPL_PPC_ASM(fpscrout) do { \
	    register double fpscrin=0.0;                      \
            asm volatile ("mtfsf 0xFF,%2\nfsqrts %0,%3\nmffs %1" \
                 : "=f" (double_dest), "=f" (fpscrout)         \
                 : "f" (fpscrin), "f" (double_a) );            \
} while (0)
#else
#define FSQRTS_IMPL_PPC_ASM(fpscrout) do { } while (0)
#endif

#define FSQRTS_IMPL			        \
{				                 \
    qword_t _a;                                   \
    qword_t *dest;                                 \
    double double_a, double_dest;                   \
    int *fp1;                                         \
    word_t _fp;		                               \
    if(PPC_INSTRUCTION_MODE) {                          \
        printf("not implemented fsqrts\n");              \
        _a = PPC_FPR_DW(FB);                              \
        memcpy(&double_a, &_a, sizeof(_a));		   \
        if(ppcInstruction::fpu_mode_cplusplus) {            \
            double_dest = sqrt(double_a);                     \
        } else if (ppcInstruction::fpu_mode_software) {        \
	    fprintf(stderr,"need softfloat implementation of fsqrts\n"); \
	    assert(0); \
        } else if(ppcInstruction::fpu_mode_asm_ppc) {          \
	    double fpscrout = 0.0; \
	    FSQRTS_IMPL_PPC_ASM(fpscrout); \
            fp1 = (int *) (&fpscrout);                         \
            memcpy(&_fp, (fp1+1), 4);                          \
        }                                                      \
        dest = (qword_t *) (&double_dest);                     \
        PPC_SET_FPR_DW(FD, *dest);                             \
        PPC_SET_FPSCR(_fp);                                    \
        /*PPC_SET_FPSCR(*(int*)(fp1+1));*/                     \
        if(ppcInstruction::debugPrintFPSCR) {                  \
            printf("FPSCR: %#x fsqrts (%g) = %g\n",            \
                   _fp,double_a,double_dest);                  \
        }                                                      \
    }                                                          \
}

DEFINST(FSQRTS,			        0x2C,
	"fsqrts",			"D,B",
	FloatSQRT,			F_FCOMP,
	PPC_DFPR(FD), PPC_DFPSCR,	PPC_DFPR(FB), PPC_DFPSCR,DNA,
	DNA, DNA, DNA,			DNA,DNA)


#define FSQRTSD_IMPL					      \
   {							      \
		FSQRTS_IMPL;				      \
        PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000));   \
   }

DEFINST(FSQRTSD,			0x2D,
	"fsqrts.",			"D,B",
	FloatSQRT,			F_FCOMP,
	PPC_DFPR(FD), PPC_DFPSCR,	PPC_DFPR(FB), PPC_DFPSCR,DNA,
	PPC_DCR, DNA, DNA,		DNA,DNA)




CONNECT(FCMPU_LINK)


#define FCMPU_IMPL                                      \
   {                                                    \
	dfloat_t _fa,_fb;                               \
	word_t _c,_cr;                                  \
	qword_t _a, _b;                                 \
        _fa=PPC_FPR(RA);                                \
        _fb=PPC_FPR(RB);                                \
        _a=PPC_FPR_DW(RA);                              \
        _b=PPC_FPR_DW(RB);                              \
        if(isdpNan(_a)||isdpNan(_b)){                   \
                _c=1;                                   \
        }                                               \
        else if(_fa<_fb) _c = 8;                        \
        else if(_fa>_fb) _c = 4;                        \
        else _c =2;                                     \
        PPC_SET_FPSCR_FPCC(_c);                         \
        _cr = (CR & (~(0xf<<((7-CRFD)*4)))) | (_c <<((7-CRFD)*4));    \
        PPC_SET_CR(_cr);                                \
                                                        \
        if(isdpSNan(_a)||isdpSNan(_b)){                 \
               PPC_SET_FPSCR_VXSNAN;                    \
        }                                               \
   }
    
DEFINST(FCMPU,                  0x0,
        "fcmpu",                "r,A,B",
        FloatCMP,               F_FCOMP,
        PPC_DFPSCR,PPC_DCR,     PPC_DFPR(RA),PPC_DFPR(RB),PPC_DFPSCR,
        DNA,DNA,DNA,            PPC_DCR,DNA)



#define FCMPO_IMPL					\
   {							\
	dfloat_t _fa,_fb;			        \
	qword_t   _a, _b;				\
        word_t  _c,_cr;                                 \
	_fa=PPC_FPR(RA);				\
	_fb=PPC_FPR(RB);		      		\
	_a=PPC_FPR_DW(RA);				\
	_b=PPC_FPR_DW(RB);			     	\
	if(isdpNan(_a)||isdpNan(_b)){			\
		_c=1;					\
	}						\
	else if(_fa<_fb) _c = 8;			\
	else if(_fa>_fb) _c = 4;			\
	else _c =2;					\
	PPC_SET_FPSCR_FPCC(_c);				\
	_cr = (CR & (~(0xf<<((7-CRFD)*4)))) | (_c <<((7-CRFD)*4));	\
	PPC_SET_CR(_cr);				\
							\
	if(isdpSNan(_a)||isdpSNan(_b)){			\
               PPC_SET_FPSCR_VXSNAN;			\
		if(PPC_GET_FPSCR_VE==0) PPC_SET_FPSCR_VXVC;	\
        }						\
	else if(isdpQNan(_a)||isdpQNan(_b)){		\
                PPC_SET_FPSCR_VXVC;           		\
        }						\
   }

DEFINST(FCMPO,			0x040,
	"fcmpo",		"r, A, B",
	FloatCMP,		F_FCOMP,
	PPC_DFPSCR,PPC_DCR,	PPC_DFPR(RA),PPC_DFPR(RB),PPC_DFPSCR,
	DNA,DNA,DNA,		PPC_DCR,DNA)




#define MCRFS_IMPL						\
   {								\
	word_t _f, _m, _c, _cr;					\
	_cr = CRFS;                                             \
	_m=  ( 0xf << ((7-_cr)*4) );				\
	_f= FPSCR & _m;						\
	_c = (CR & (~ (_m))) | _f;				\
								\
	if(_cr==0){						\
	PPC_RESET_FPSCR_FX;			       		\
	PPC_RESET_FPSCR_OX;			       		\
	}							\
	else if(_cr==1){					\
	PPC_RESET_FPSCR_UX;			       		\
	PPC_RESET_FPSCR_ZX;			       		\
	PPC_RESET_FPSCR_ZX;			       		\
	PPC_RESET_FPSCR_VXSNAN;					\
        }							\
        else  if(_cr==2){					\
    	PPC_RESET_FPSCR_VXISI;					\
    	PPC_RESET_FPSCR_VXIDI;					\
    	PPC_RESET_FPSCR_VXZDZ;					\
    	PPC_RESET_FPSCR_VXIMZ;					\
        }							\
        else  if(_cr==3){					\
        PPC_RESET_FPSCR_VXVC;				        \
        }							\
        else  if(_cr==5){					\
        PPC_RESET_FPSCR_VXSOFT;					\
        PPC_RESET_FPSCR_VXSQRT;					\
        PPC_RESET_FPSCR_VXCVI;					\
        }							\
   }


DEFINST(MCRFS,			0x080,
	"mcrfs",		"r,w",
	IntALU,			F_ICOMP,
	PPC_DFPSCR,PPC_DCR,	PPC_DFPSCR,PPC_DCR,DNA,
        DNA, DNA, DNA,		DNA, DNA)

#if IS_CMMT
#define FRSP_IMPL				               \
{                                                              \
    qword_t _b;                                                \
    qword_t *dest;                                             \
    double double_b, double_dest;                              \
    /*double fpscrin=0.0, fpscrout;*/			       \
    /*int *fp1;	*/					       \
    /*word_t _fp; */					       \
    float tempf;                     /*wcm*/             \
    /*word_t *ptempf;*/                  /*wcm*/             \
    int *a, *b;                      /*wcm*/             \
    a = (int*)&double_dest;          /*wcm*/             \
    b = (int*)&double_dest;          /*wcm*/             \
    /*_fp = FPSCR;*/                 /*wcm*/             \
    /*fp1 = (int *)(&fpscrin)+1;*/   /*wcm*/             \
    /*memcpy(fp1, &_fp, 4); */       /*wcm*/             \
    _b = PPC_FPR_DW(RB);                                       \
    memcpy(&double_b, &_b, sizeof(_b));			       \
    tempf = (float)double_b;         /*wcm*/             \
    double_dest = (double)tempf;     /*wcm*/             \
    dest = (qword_t*)(&double_dest); /*wcm*/             \
    /*asm ("mtfsf 0xFF,%2\n frsp %0,%3\n mffs %1"*/      \
    /*     : "=f" (double_dest), "=f" (fpscrout) */      \
    /*     : "f" (fpscrin), "f" (double_b) );    */      \
    /*fp1 = (int *) (&fpscrout);*/   /*wcm*/             \
    /*memcpy(&_fp, (fp1+1), 4);*/    /*wcm*/             \
    /*dest = (qword_t *) (&double_dest);*/ /*wcm*/       \
    PPC_SET_FPR_DW(FD, *dest);                                 \
    /*PPC_SET_FPSCR( *(int *) (fp1+1));*/ /*wcm*/        \
}
#else
#define FRSP_IMPL { }
#endif

DEFINST(FRSP,                   	0x018,
        "frsp",                 	"D,B",
        FloatADD,               	F_FCOMP,   
        PPC_DFPR(FD),PPC_DFPSCR,        PPC_DFPR(FB),PPC_DFPSCR,DNA,
        DNA, DNA, DNA,          	DNA, DNA)



#define FRSPD_IMPL                                      \
{                                                       \
    FRSP_IMPL					        \
    PPC_SET_CR((CR&0xf0ffffff)|(FPSCR&0x0f000000));	\
}     
  

DEFINST(FRSPD,                  	0x019,
        "frsp.",                	"D,B",
        FloatADD,               	F_FCOMP,
        PPC_DFPR(FD),PPC_DFPSCR,        PPC_DFPR(FB),PPC_DFPSCR,DNA,
        PPC_DCR, DNA, DNA,          	PPC_DCR, DNA)


#ifdef FP_ROUND_CONVERSION_INST

#define FCTIW_IMPL		                          \
{				                           \
    int *fp1;                                               \
    double double_b, double_dest;                            \
    double fpscrin=0.0, fpscrout;                             \
    qword_t _b;                                                \
    qword_t *dest;                                              \
    word_t _fp;                                                 \
    if(PPC_INSTRUCTION_MODE) {                                  \
        _fp = FPSCR;                                            \
        fp1 = (int *)(&fpscrin)+1;                              \
        memcpy(fp1, &_fp, 4);                                   \
        _b = PPC_FPR_DW(RB);                                    \
        memcpy(&double_b, &_b, sizeof(double));                 \
        if ((ppcInstruction::fpu_mode_cplusplus) /*||             \
            (ppcInstruction::fpu_mode_software)*/) {              \
           /* wcm: from the ppc-nonnative.def file */           \
           word_t temp;                                         \
           qword_t res;                                         \
           temp = (int)double_b;                                \
	   /* for little endian machines, we swap where the bytes */	\
	   /* end up*/							\
	   if (ppcInstruction::little_endian) {				\
	     res = temp;                                                \
	     memcpy(&double_dest, &res, sizeof(double));		\
	   } else {							\
	     res = (qword_t)temp << 32;                                 \
	     memcpy(&double_dest, &res, sizeof(double));		\
	   }								\
        } else if(ppcInstruction::fpu_mode_software) {      \
	    qword_t res;                                     \
	    float64 f64_b;                                   \
	    uint32_t temp;                                   \
	    memcpy(&f64_b, &double_b, sizeof(float64));      \
	    float_rounding_mode = PPCHW_GET_FPSCR_RN(FPSCR); \
	    temp = float64_to_int32(f64_b); \
	    res = ((qword_t)0xfff80000 << 32) | temp;        \
	    memcpy(&double_dest, &res, sizeof(double));   \
	    _fp = fpscr_set_D(FPSCR, FP_ROUNDOP, 0.0,     \
		    double_b, double_b,                         \
		    float_exception_flags,                      \
		    float_rounding_flags);                      \
        } else if(ppcInstruction::fpu_mode_asm_ppc) {           \
            asm ("mtfsf 0xFF,%2\n fctiw %0,%3\n mffs %1"        \
                 : "=f" (double_dest),                          \
                   "=f" (fpscrout)                              \
                 : "f"  (fpscrin),                              \
                   "f"  (double_b) );                           \
            fp1 = (int *) (&fpscrout);                          \
            memcpy(&_fp, (fp1+1), 4);                           \
        }                                                       \
        dest = (qword_t*)(&double_dest);                        \
        PPC_SET_FPR_DW(FD, *dest);                              \
        PPC_SET_FPSCR(_fp);                                     \
        /*PPC_SET_FPSCR( *(int*) (fp1+1));*/                    \
        if(ppcInstruction::debugPrintFPSCR) {                   \
            printf("FCTIW: %#llx\n",(unsigned long long) double_dest);\
        }                                                       \
    }                                                           \
}

#else

#define FCTIW_IMPL                                                 \
{					                           \
    fprintf(stderr,                                                \
	    "ALERT:  FCTIW instruction not implemented"            \
            " on this machine! unable to inline. quitting.\n");    \
    exit(1);                                                       \
}

#endif

DEFINST(FCTIW,                  	0x01C,
        "fctiw",                	"D,B",
        FloatADD,               	F_FCOMP,
        PPC_DFPR(FD),PPC_DFPSCR,        PPC_DFPR(FB),PPC_DFPSCR,DNA,
        DNA, DNA, DNA,        		DNA,DNA)

#define FCTIWD_IMPL					\
  {							\
	FCTIW_IMPL					\
   PPC_SET_CR((CR&0xf0ffffff)|(FPSCR&0x0f000000));	\
  }

DEFINST(FCTIWD,                 	0x01D,
        "fctiw.",               	"D,B",
        FloatADD,               	F_FCOMP,
        PPC_DFPR(FD),PPC_DFPSCR,        PPC_DFPR(FB),PPC_DFPSCR,DNA,
        PPC_DCR, DNA, DNA,        	PPC_DCR, DNA)


#ifdef FP_ROUND_CONVERSION_INST

#ifdef __ppc__
#define FCTIWZ_IMPL_ASM(double_dest,fpscrout,fpscrin,double_b) \
    asm volatile ("mtfsf 0xFF,%2\n fctiwz %0,%3\n mffs %1\n"    \
                          : "=f" (double_dest), "=f" (fpscrout)	\
                          : "f" (fpscrin), "f" (double_b) );
#else
#define FCTIWZ_IMPL_ASM(...)
#endif

#define FCTIWZ_IMPL					              \
{							              \
    qword_t _b;                                                       \
    qword_t *dest;                                                    \
    double double_b, double_dest;                                     \
    double fpscrin=0.0, fpscrout;                                     \
    int *fp1;                                                         \
    word_t _fp;                                                       \
    if(PPC_INSTRUCTION_MODE) {                                        \
        /*OPCODEBUG("fctiwz");*/                                      \
        _fp = FPSCR;                                                  \
        fp1 = (int *)(&fpscrin)+1;                                    \
        memcpy(fp1, &_fp, 4);                                         \
        _b = PPC_FPR_DW(FB);                                          \
        memcpy(&double_b, &_b, sizeof(double));	                      \
        if( (ppcInstruction::fpu_mode_cplusplus) /*||                   \
	    (ppcInstruction::fpu_mode_software)*/) {                    \
            /* wcm: pulled from ppc-nonnative.def file */             \
            qword_t res;                                              \
            word_t  temp;                                             \
            temp = (int)double_b;	                              \
	    /* for little endian machines, we swap where the bytes */	\
	    /* end up*/							\
	    res = ((qword_t)0xfff80000 << 32) | temp;                   \
	} else if (ppcInstruction::fpu_mode_software) {                \
	    /* From the ISR:                                          \
	     * Except for trap-enabled invalid operation exceptions,  \
	     * FPSCR[FPRF] is undefined. FPSCR[FR] is set if the      \
	     * result is incremented when rounded. FPSCR[FI] is set   \
	     * if the result is inexact. */                           \
	    float64 f64_b;                                             \
	    uint32_t temp;                                             \
	    qword_t res;                                               \
            memcpy(&f64_b, &_b, sizeof(_b));                           \
	    float_exception_flags = 0;                                 \
	    temp = float64_to_int32_round_to_zero(f64_b);              \
	    res = ((qword_t)0xfff80000 << 32) | temp;                  \
	    memcpy(&double_dest, &res, sizeof(double) );              \
	    _fp = fpscr_set_D(FPSCR, FP_ROUNDOP, 0.0,          \
		    double_b, double_b,                                \
		    float_exception_flags, float_rounding_flags);     \
        } else if(ppcInstruction::fpu_mode_asm_ppc) {                 \
	  FCTIWZ_IMPL_ASM(double_dest,fpscrout,fpscrin,double_b);     \
	  fp1 = (int *) (&fpscrout);				      \
	  memcpy(&_fp, (fp1+1), 4);				      \
        }                                                             \
        dest = (qword_t *) (&double_dest);                            \
        PPC_SET_FPR_DW(FD, *dest);                                    \
        PPC_SET_FPSCR(_fp);                                           \
        /*PPC_SET_FPSCR( *(int *) (fp1+1));*/                         \
    }                                                                 \
}

#else

#define FCTIWZ_IMPL	                                                \
  {									\
    fprintf(stderr, "ALERT:  FCTIWZ instruction not implemented on this machine! unable to inline. quitting.\n"); \
    /*printf("PC %x\n", (unsigned int)CPC);*/				\
    /*exit(1);*/							\
  }
  
#endif

DEFINST(FCTIWZ,                 	0x1E,
        "fctiwz",               	"D,B",
        FloatADD,               	F_FCOMP,
        PPC_DFPR(FD),PPC_DFPSCR,        PPC_DFPR(FB),PPC_DFPSCR,DNA,
        DNA, DNA, DNA,        		DNA, DNA)

#define FCTIWZD_IMPL	                                \
  {				                        \
	FCTIWZ_IMPL			                \
   PPC_SET_CR((CR&0xf0ffffff)|(FPSCR&0x0f000000));      \
  }


DEFINST(FCTIWZD,                	0x1F,
        "fctiwzd",              	"D,B",
        FloatADD,               	F_FCOMP,
        PPC_DFPR(FD),PPC_DFPSCR,        PPC_DFPR(FB),PPC_DFPSCR,DNA,
        PPC_DCR, DNA, DNA,        	PPC_DCR, DNA)

#define FDIV_IMPL                                                \
{                                                                \
   qword_t _a, _b;                                               \
   qword_t *dest;                                                \
   double double_a, double_b, double_dest;                       \
   double fpscrin=0.0, fpscrout;                                 \
   int *fp1;                                                     \
   word_t _fp;                                                   \
   if(PPC_INSTRUCTION_MODE) {                                    \
       _fp = FPSCR;                                              \
       fp1 = (int *)(&fpscrin)+1;                                \
       memcpy(fp1, &_fp, 4);                                     \
       _a = PPC_FPR_DW(RA);                                      \
       _b = PPC_FPR_DW(RB);                                      \
       memcpy(&double_a, &_a, sizeof(_a));		         \
       memcpy(&double_b, &_b, sizeof(_b));                       \
       if(ppcInstruction::fpu_mode_cplusplus) {                  \
           double_dest = double_a / double_b;                    \
       }                                                         \
       else if(ppcInstruction::fpu_mode_software) {              \
           float64 f64_a,f64_b,f64_dest;                         \
           float_rounding_mode = PPCHW_GET_FPSCR_RN(FPSCR);      \
           memcpy(&f64_a, &_a, sizeof(f64_a));                   \
           memcpy(&f64_b, &_b, sizeof(f64_b));                   \
	   float_exception_flags = 0;                            \
	   float_rounding_flags = 0;                             \
           f64_dest = float64_div(f64_a,f64_b);                  \
           memcpy(&double_dest, &f64_dest, sizeof(double_dest)); \
           _fp = fpscr_set_D(_fp, FP_DIVOP, double_dest,         \
                             double_a, double_b,                 \
                             float_exception_flags,              \
                             float_rounding_flags);              \
       } else if(ppcInstruction::fpu_mode_asm_ppc) {             \
           asm("mtfsf 0xFF,%2\n fdiv %0,%3,%4\n mffs %1"         \
               : "=f" (double_dest), "=f" (fpscrout)             \
               : "f" (fpscrin), "f" (double_a),                  \
                 "f" (double_b) );                               \
           fp1 = (int *) (&fpscrout);                            \
           memcpy(&_fp, (fp1+1), 4);                             \
       }                                                         \
       dest = (qword_t *) (&double_dest);                        \
       PPC_SET_FPR_DW(FD, *dest);                                \
       /*PPC_SET_FPSCR( *(int *) (fp1+1));*/                     \
       PPC_SET_FPSCR(_fp);                                       \
       if(ppcInstruction::debugPrintFPSCR)                       \
           printf("FPSCR: %#x  (%g / %g = %g)\n",                \
                  FPSCR,double_a,double_b,double_dest);          \
   }                                                             \
}
        
DEFINST(FDIV,                   	0x24,
        "fdiv",                 	"D,A,B",
        FloatDIV,               	F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,       PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPSCR,
        DNA, DNA, DNA,          	DNA, DNA)
        

#define FDIVD_IMPL                                     	\
  {                                                     \
	FDIV_IMPL					\
   PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000));  \
  }

DEFINST(FDIVD,                  	0x25,
        "fdiv.",                	"D,A,B",
        FloatDIV,               	F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,       PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPSCR,
        PPC_DCR, DNA, DNA,          	PPC_DCR, DNA)




#define MTFSB1_IMPL                                                     \
   {                                                                    \
        word_t _m, _f;                                                  \
        _m =  0x1 << (31 - CRBD);                                       \
        _f = FPSCR | _m;                                           	\
        if(!((CRBD==1) || (CRBD == 2)))                                 \
        {                                                               \
                PPC_SET_FPSCR(_f);                                      \
        }                                                               \
   }


DEFINST(MTFSB1,                 0x04C,
        "mtfsb1",               "frd",
        IntALU,                 F_ICOMP,
        PPC_DFPSCR,DNA,         PPC_DFPSCR,DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)


#define MTFSB1D_IMPL                                                    \
   {                                                                    \
        word_t _m, _f, _c;                                              \
        _m =  0x1 << (31 - CRBD);                                       \
        _f = FPSCR | _m;                                           	\
        if(!((CRBD==1) || (CRBD == 2)))                                 \
        {                                                               \
                PPC_SET_FPSCR(_f);                                      \
        }                                                               \
        _c = CR;                                                        \
        PPC_SET_CR( (_c & 0xf0ffffff) | (_f & 0x0f000000) );            \
   }
        
    
DEFINST(MTFSB1D,                0x4D,
        "mtfsb1.",              "D",
        IntALU,                 F_ICOMP,
        PPC_DFPSCR,PPC_DCR,     PPC_DFPSCR,PPC_DCR,DNA,
        DNA, DNA, DNA,        	DNA, DNA)




#define FNEG_IMPL                                                      \
   {                                                                   \
         PPC_SET_FPR_D( FD, ( -PPC_FPR(FB) ) );	                       \
   }    

DEFINST(FNEG,                   0x050,
        "fneg",                 "D,B",
        FloatADD,               F_FCOMP,
        PPC_DFPR(FD), DNA,      PPC_DFPR(FB), DNA, DNA,
        DNA, DNA, DNA,          DNA, DNA)



#define FNEGD_IMPL                                                      \
   {                                                                    \
        PPC_SET_FPR_D( FD, ( -PPC_FPR(FB) ) );                          \
	PPC_SET_CR( (CR & 0xf0ffffff) | (((FPSCR)>>4) & 0x0f000000)  );	\
   }
    
DEFINST(FNEGD,                  0x051,
        "fneg.",                "D,B",
        FloatADD,               F_FCOMP, 
        PPC_DFPR(FD), DNA,      PPC_DFPR(FB), PPC_DFPSCR, PPC_DCR,
        DNA, DNA, DNA,         	DNA, DNA)

#define MTFSB0_IMPL                                                     \
   {                                                                    \
	word_t _m, _f;							\
	_m =  0x1 << (31 - CRBD);					\
	_f = FPSCR & (~(_m));						\
	if(!((CRBD==1) || (CRBD == 2)))					\
	{								\
		PPC_SET_FPSCR(_f);					\
	}								\
   }
        
    
DEFINST(MTFSB0,                 0x8C,
        "mtfsb0",               "D",
        IntALU,                 F_ICOMP,
        PPC_DFPSCR,DNA,         PPC_DFPSCR,DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)


#define MTFSB0D_IMPL                                                    \
   {                                                                    \
        word_t _m, _f, _c;                                              \
        _m =  0x1 << (31 - CRBD);                                       \
        _f = FPSCR & (~(_m));                                           \
        if(!((CRBD==1) || (CRBD == 2)))                                 \
        {                                                               \
                PPC_SET_FPSCR(_f);                                      \
        }                                                               \
        _c = CR;                                                        \
        PPC_SET_CR( (_c & 0xf0ffffff) | (_f & 0x0f000000) );            \
   }


DEFINST(MTFSB0D,                0x8D,   
        "mtfsb0.",              "D",  
        IntALU,                 F_ICOMP,
        PPC_DFPSCR,PPC_DCR,     PPC_DFPSCR,PPC_DCR,DNA,
        DNA, DNA, DNA,        	DNA, DNA)




#define FMR_IMPL							\
   {									\
	PPC_SET_FPR_D(FD, PPC_FPR(FB));				\
   }

DEFINST(FMR,			0x090,
	"fmr",			"D,B",
	FloatADD,		F_FCOMP,
	PPC_DFPR(FD), DNA,      PPC_DFPR(FB), DNA, DNA,
        DNA, DNA, DNA,          DNA, DNA)

#define FMRD_IMPL                                                       \
   {                                                                    \
        PPC_SET_FPR_D(FD, PPC_FPR(FB));                                 \
	PPC_SET_CR( (CR & 0xf0ffffff) | (((FPSCR)>>4) & 0x0f000000)  ); \
   }

DEFINST(FMRD,                   0x091,
        "fmr.",                 "D,B",
        FloatADD,               F_FCOMP,
        PPC_DFPR(FD), DNA,      PPC_DFPR(FB), PPC_DFPSCR, PPC_DCR,
        DNA, DNA, DNA,          DNA, DNA)



#define FSUB_IMPL                                                         \
{                                                                         \
    qword_t _a, _b;                                                       \
    qword_t *dest;                                                        \
    double double_a, double_b, double_dest;                               \
    double fpscrin=0.0, fpscrout;		                          \
    int *fp1;				                                  \
    word_t _fp;                                                           \
    if(PPC_INSTRUCTION_MODE) {                                            \
        _fp = FPSCR;                                                      \
        fp1 = (int *)(&fpscrin)+1;                                        \
        memcpy(fp1, &_fp, 4);                                             \
        _a = PPC_FPR_DW(RA);                                              \
        _b = PPC_FPR_DW(RB);                                              \
        memcpy(&double_a, &_a, sizeof(_a));                               \
        memcpy(&double_b, &_b, sizeof(_b));                               \
        if(ppcInstruction::fpu_mode_cplusplus) {                          \
            double_dest = double_a - double_b;                            \
        } else if(ppcInstruction::fpu_mode_software) {                    \
            float64 f64_a, f64_b, f64_dest;                               \
            float_rounding_mode = PPCHW_GET_FPSCR_RN(_fp);                \
            memcpy(&f64_a, &_a, sizeof(_a));                              \
            memcpy(&f64_b, &_b, sizeof(_b));                              \
	    float_exception_flags = 0; \
	    float_rounding_flags = 0; \
            f64_dest = float64_sub(f64_a, f64_b);                         \
            memcpy(&double_dest, &f64_dest, sizeof(f64_dest));            \
            _fp = fpscr_set_D(_fp,FP_SUBOP,double_dest,                   \
                              double_a,double_b,                          \
                              float_exception_flags,                      \
                              float_rounding_flags);                      \
        } else if(ppcInstruction::fpu_mode_asm_ppc) {                     \
            /*ptempf = (word_t *) (&double_a);			          \
            asm("stfd %0, 0(%1)": : "f" (_a), "g" (*ptempf) : "r0" );     \
            ptempf = (word_t *) (&double_b);			          \
            asm("stfd %0, 0(%1)": : "f" (_b), "g" (*ptempf) : "r0" );*/   \
            double_dest = double_a - double_b;                            \
            asm ("mtfsf 0xFF,%2\n fsub %0,%3,%4\n mffs %1"                \
                 : "=f" (double_dest),                                    \
                   "=f" (fpscrout)                                        \
                 : "f"  (fpscrin),                                        \
                   "f"  (double_a),                                       \
                   "f"  (double_b) );                                     \
            fp1 = (int *) (&fpscrout);                                    \
            memcpy(&_fp, (fp1+1), 4);                                     \
        } else {                                                          \
           fprintf(stderr,"Error: invalid FPU emulation mode!\n");        \
        }                                                                 \
        dest = (qword_t *) (&double_dest);                                \
        PPC_SET_FPR_DW(FD, *dest);                                        \
        PPC_SET_FPSCR(_fp);			                          \
        if(ppcInstruction::debugPrintFPSCR)                               \
            printf("FPSCR: %#x  fsub (%g - %g = %g)\n",                   \
                   FPSCR,double_a,double_b,double_dest);                  \
    }                                                                     \
}
        
DEFINST(FSUB,                   	0x28,
        "fsub",                 	"D,A,B",
        FloatADD,               	F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,       PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPSCR,
        DNA, DNA, DNA,          	DNA, DNA)


#define FSUBD_IMPL                                                   \
{                                                                    \
    FSUB_IMPL                                                        \
    PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000));              \
}

DEFINST(FSUBD,                  	0x29,
        "fsub.",                	"D,A,B",
        FloatADD,               	F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,       PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPSCR,
        PPC_DCR, DNA, DNA,          	PPC_DCR, DNA)




#define FADD_IMPL                                         \
{                                                          \
    qword_t  _a, _b;                                        \
    qword_t* dest;                                           \
    double   double_a, double_b, double_dest;                 \
    double   fpscrin=0.0, fpscrout;		               \
    int*     fp1;                                               \
    word_t   _fp;                                                \
    if(PPC_INSTRUCTION_MODE) {                                    \
        _fp = FPSCR;                                               \
        fp1 = (int *)(&fpscrin)+1;                                  \
        memcpy(fp1, &_fp, 4);                                        \
        _a = PPC_FPR_DW(RA);                                          \
        _b = PPC_FPR_DW(RB);                                           \
        memcpy(&double_a, &_a, sizeof(_a));                             \
        memcpy(&double_b, &_b, sizeof(_b));                              \
        if(ppcInstruction::fpu_mode_cplusplus) {                          \
            double_dest = double_a + double_b;                            \
        }                                                                 \
        else if(ppcInstruction::fpu_mode_software) {                      \
            float64 f64_a, f64_b, f64_dest;                               \
            float_rounding_mode = PPCHW_GET_FPSCR_RN(FPSCR);              \
            memcpy(&f64_a, &_a, sizeof(_a));                              \
            memcpy(&f64_b, &_b, sizeof(_b));                              \
            f64_dest = float64_add(f64_a, f64_b);                         \
            memcpy(&double_dest, &f64_dest, sizeof(f64_dest));            \
            _fp = fpscr_set_D(_fp,FP_ADDOP,double_dest,                   \
                              double_a,double_b,                          \
                              float_exception_flags,                      \
                              float_rounding_flags);                      \
        }                                                                 \
        else if(ppcInstruction::fpu_mode_asm_ppc) {                       \
            asm ("mtfsf 0xFF,%2\n fadd %0,%3,%4\n mffs %1"                \
                 : "=f" (double_dest),                                    \
                   "=f" (fpscrout)                                        \
                 : "f"  (fpscrin),                                        \
                   "f"  (double_a),                                       \
                   "f"  (double_b) );                                     \
            fp1 = (int *) (&fpscrout);	                                  \
            memcpy(&_fp, (fp1+1), 4);	                                  \
        }                                                                 \
        dest = (qword_t *)(&double_dest);                                 \
        PPC_SET_FPR_DW(FD, *dest);                                        \
        PPC_SET_FPSCR(_fp);                                               \
        /*print_fpscr_bits(_fp);*/                                        \
        if(ppcInstruction::debugPrintFPSCR)                               \
            printf("FPSCR: %#x  fadd (%g + %g = %g)\n",                   \
                   FPSCR,double_a,double_b,double_dest);                  \
    }                                                                     \
}


DEFINST(FADD,                   	0x2A,
        "fadd",                 	"D,A,B",
        FloatADD,               	F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,       PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPSCR,
        DNA, DNA, DNA,         		DNA, DNA)


#define FADDD_IMPL					\
{                                                       \
    FADD_IMPL                                           \
    PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000));	\
}


DEFINST(FADDD,                  	0x2B,
        "fadd.",                	"D,A,B",
        FloatADD,               	F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,       PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPSCR,
        PPC_DCR, DNA, DNA,          	PPC_DCR, DNA)




#define FSEL_IMPL				\
   {						\
	if(PPC_FPR(FA)>=0.0){			\
		PPC_SET_FPR_D(FD,PPC_FPR(FC));	\
	}					\
	else{					\
		PPC_SET_FPR_D(FD,PPC_FPR(FB));  \
	}					\
   }

DEFINST(FSEL,			0x2E,
	"fsel",			"D,A,C,B",
	FloatCMP,		F_FCOMP,
	PPC_DFPR(FD),DNA,	PPC_DFPR(FA),PPC_DFPR(FB),PPC_DFPR(FC),
	DNA,DNA,DNA,		DNA,DNA)

#define FSELD_IMPL                              \
   {                                            \
        if(PPC_FPR(FA)>=0.0){                   \
                PPC_SET_FPR_D(FD,PPC_FPR(FC));  \
        }                                       \
        else{                                   \
                PPC_SET_FPR_D(FD,PPC_FPR(FB));  \
        }                                       \
        PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000)); \
   }
    
DEFINST(FSELD,                  0x2F,
        "fsel.",                "D,A,C,B",
        FloatCMP,               F_FCOMP,
        PPC_DFPR(FD),DNA,       PPC_DFPR(FA),PPC_DFPR(FB),PPC_DFPR(FC),
        DNA,DNA,DNA,            DNA,DNA)



#define FNMSUB_IMPL                                                  \
{                                                                    \
    qword_t _a, _b,_c;                                               \
    double double_a, double_b, double_c;                             \
    double double_dest;                                              \
    double fpscrin=0.0, fpscrout;                                    \
    qword_t *dest;                                                   \
    word_t _fp;                                                      \
    int *fp1;                                                        \
    if(PPC_INSTRUCTION_MODE) {                                       \
        _fp = FPSCR;                                                 \
        fp1 = (int *)(&fpscrin)+1;                                   \
        memcpy(fp1, &_fp, 4);                                        \
        _a = PPC_FPR_DW(FA);                                         \
        _b = PPC_FPR_DW(FB);                                         \
        _c = PPC_FPR_DW(FC);                                         \
        memcpy(&double_a, &_a, sizeof(_a));			     \
        memcpy(&double_b, &_b, sizeof(_b));			     \
        memcpy(&double_c, &_c, sizeof(_c));		             \
        if(ppcInstruction::fpu_mode_cplusplus) {                     \
            double_dest = -((double_a*double_c)-double_b);           \
        } else if(ppcInstruction::fpu_mode_software) {               \
            float64 f64_a, f64_b, f64_c, f64_d,tmp;                  \
            float_rounding_mode = PPCHW_GET_FPSCR_RN(FPSCR);         \
            memcpy(&f64_a, &_a, sizeof(f64_a));                      \
            memcpy(&f64_b, &_b, sizeof(f64_b));                      \
            memcpy(&f64_c, &_c, sizeof(f64_c));                      \
            tmp = float64_mul(f64_a, f64_c);                         \
            f64_d = float64_sub(tmp, f64_b);                         \
            memcpy(&double_dest,&f64_d,sizeof(double_dest));         \
            double_dest = -double_dest;  /* negate! */               \
            /* wcm: FPSCR not fully implemented */                   \
            _fp = fpscr_set_D(_fp,FP_SUBOP,double_dest,              \
                              double_a, double_b,                    \
                              float_exception_flags,                 \
                              float_rounding_flags);                 \
        } else if(ppcInstruction::fpu_mode_asm_ppc) {                \
            /* double_dest = double_a * double_c - double_b;  */     \
            asm ("mtfsf 0xFF,%2\n fnmsub %0,%3,%4,%5\n mffs %1"      \
            : "=f" (double_dest),                                    \
              "=f" (fpscrout)                                        \
            : "f" (fpscrin),                                         \
              "f" (double_a),                                        \
              "f" (double_c),                                        \
              "f" (double_b) );                                      \
            fp1 = (int *) (&fpscrout);                               \
            memcpy(&_fp, (fp1+1), 4);                                \
        }                                                            \
        dest = (qword_t *) (&double_dest);                           \
        PPC_SET_FPR_DW(FD, *dest);                                   \
        PPC_SET_FPSCR( _fp );                                        \
        /* PPC_SET_FPSCR( *(int *) (fp1+1));*/                       \
        if(ppcInstruction::debugPrintFPSCR)                          \
            printf("FPSCR: %#x fnmsub -[(%g  * %g)-%g] = %g\n",      \
                   FPSCR,double_a,double_c,double_b,double_dest);    \
    }                                                                \
}
   
DEFINST(FNMSUB,              0x3C,
        "fnmsub",            "D,A,C,B",
        FloatMULT,           F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR, PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPR(FC),
        DNA, DNA, DNA, PPC_DFPSCR, DNA)

#define FNMSUBD_IMPL                                        \
  {                                                         \
	FNMSUB_IMPL					    \
	PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000)); \
  }

DEFINST(FNMSUBD,                      0x3D,
        "fnmsub.",                    "D,A,C,B",
        FloatMULT,           F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,     PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPR(FC),
        PPC_DCR, DNA, DNA,            PPC_DFPSCR, PPC_DCR)



#define FMUL_IMPL                                                         \
{                                                                         \
    qword_t _a,_c;                                                        \
    qword_t *dest;				                          \
    double double_a, double_c,  double_dest;                              \
    double fpscrin=0.0, fpscrout;                                         \
    int *fp1;                                                             \
    word_t _fp; 	                                                  \
    if(PPC_INSTRUCTION_MODE) {                                            \
        _fp = FPSCR;                                                      \
        fp1 = (int *)(&fpscrin)+1;                                        \
        memcpy(fp1, &_fp, 4);                                             \
        _a = PPC_FPR_DW(RA);                                              \
        _c = PPC_FPR_DW(RC);                                              \
        memcpy(&double_a, &_a, sizeof(_a));			          \
        memcpy(&double_c, &_c, sizeof(_c));			          \
        if(ppcInstruction::fpu_mode_cplusplus) {                          \
            double_dest = double_a * double_c;                            \
        }                                                                 \
        else if(ppcInstruction::fpu_mode_software) {                      \
            float64 f64_a, f64_c, f64_dest;                               \
            float_rounding_mode = PPCHW_GET_FPSCR_RN(FPSCR);              \
            memcpy(&f64_a, &_a, sizeof(f64_a));                           \
            memcpy(&f64_c, &_c, sizeof(f64_c));                           \
	    float_exception_flags = 0;                                    \
            f64_dest = float64_mul(f64_a, f64_c);                         \
	    float_rounding_flags = 0; \
            memcpy(&double_dest, &f64_dest, sizeof(double_dest));         \
            _fp = fpscr_set_D(_fp,FP_MULOP, double_dest,                  \
                              double_a, double_c,                         \
                              float_exception_flags,                      \
                              float_rounding_flags);                      \
        } else if(ppcInstruction::fpu_mode_asm_ppc) {                     \
            /*ptempf = (word_t *) (&double_a);		                  \
            asm("stfd %0, 0(%1)": : "f" (_a), "g" (*ptempf) : "r0" );     \
            ptempf = (word_t *) (&double_c);                              \
            asm("stfd %0, 0(%1)": : "f" (_c), "g" (*ptempf) : "r0" ); */  \
            /* double_dest = double_a * double_c;	*/	          \
            asm ("mtfsf 0xFF,%2\n fmul %0,%3,%4\n mffs %1"                \
               : "=f" (double_dest),                                      \
                 "=f" (fpscrout)                                          \
               : "f" (fpscrin),                                           \
                 "f" (double_a),                                          \
                 "f" (double_c) );                                        \
            fp1 = (int *) (&fpscrout);                                    \
            memcpy(&_fp, (fp1+1), 4);                                     \
        }                                                                 \
        dest = (qword_t *) (&double_dest);			          \
        PPC_SET_FPSCR(_fp);                                               \
        PPC_SET_FPR_DW(FD, *dest);                                        \
        if(ppcInstruction::debugPrintFPSCR)                               \
            printf("FPSCR: %#x  fmul ( %g * %g ) = %g\n",                 \
                   FPSCR,double_a,double_c,double_dest);                  \
    }                                                                     \
}

DEFINST(FMUL,                   	0x32,
        "fmul",                 	"D,A,C",
        FloatMULT,              	F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,       PPC_DFPR(FA), PPC_DFPR(FC), PPC_DFPSCR,
        DNA, DNA, DNA,          	DNA, DNA)
  


#define FMULD_IMPL                                      \
  {                                                     \
	FMUL_IMPL					\
	PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000)); \
  }
        
DEFINST(FMULD,                  	0x33,
        "fmul.",                	"D,A,C",
        FloatMULT,              	F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,       PPC_DFPR(FA), PPC_DFPR(FC), PPC_DFPSCR,
        PPC_DCR, DNA, DNA,          	PPC_DCR, DNA)


#define FMSUB_IMPL                                                   \
{                                                                    \
    qword_t _a, _b,_c;                                               \
    double double_a, double_b, double_c;                             \
    double double_dest;                                              \
    double fpscrin=0.0, fpscrout;                                    \
    qword_t *dest;                                                   \
    word_t _fp;                                                      \
    int *fp1;			                                     \
    if(PPC_INSTRUCTION_MODE) {                                       \
        _fp = FPSCR;                                                 \
        fp1 = (int *)(&fpscrin)+1;                                   \
        memcpy(fp1, &_fp, 4);                                        \
        _a = PPC_FPR_DW(FA);                                         \
        _b = PPC_FPR_DW(FB);                                         \
        _c = PPC_FPR_DW(FC);                                         \
        memcpy(&double_a, &_a, sizeof(_a));		             \
        memcpy(&double_b, &_b, sizeof(_b));		             \
        memcpy(&double_c, &_c, sizeof(_c));		             \
        if(ppcInstruction::fpu_mode_cplusplus) {                     \
            double_dest = (double_a*double_c)-double_b;              \
        }                                                            \
        else if(ppcInstruction::fpu_mode_software) {                 \
            /*wcm: no direct softFloat impl. of FMSUB,               \
                   so this implementation is not expected to         \
                   100% match true hardware implementation on PPC */ \
            float_rounding_mode = PPCHW_GET_FPSCR_RN(FPSCR);         \
            float64 f64_a, f64_b, f64_c, f64_dest;                   \
            double temp;                                             \
            memcpy(&f64_a, &_a, sizeof(_a));                         \
            memcpy(&f64_b, &_b, sizeof(_b));                         \
            memcpy(&f64_c, &_c, sizeof(_c));                         \
            f64_dest = float64_mul(f64_a, f64_c);                    \
            memcpy(&double_dest, &f64_dest, sizeof(double_dest));    \
            _fp = fpscr_set_D(_fp,FP_MULOP,double_dest,              \
                              double_a, double_c,                    \
                              float_exception_flags,                 \
                              float_rounding_flags);                 \
            temp = double_dest;                                      \
            f64_dest = float64_sub(f64_dest, f64_b);                 \
            memcpy(&double_dest, &f64_dest, sizeof(double_dest));    \
            _fp = fpscr_set_D(_fp, FP_SUBOP, double_dest,            \
                              temp, double_b,                        \
                              float_exception_flags,                 \
                              float_rounding_flags);                 \
        }                                                            \
        else if(ppcInstruction::fpu_mode_asm_ppc) {                  \
            /* double_dest = double_a * double_c - double_b;  */     \
            asm ("mtfsf 0xFF,%2\n fmsub %0,%3,%4,%5\n mffs %1"       \
                 : "=f" (double_dest),                               \
                   "=f" (fpscrout)                                   \
                 :  "f" (fpscrin),                                   \
                    "f" (double_a),                                  \
                    "f" (double_c),                                  \
                    "f" (double_b) );                                \
            fp1 = (int *) (&fpscrout);                               \
            memcpy(&_fp, (fp1+1), 4);                                \
        }                                                            \
        dest = (qword_t *) (&double_dest);                           \
        PPC_SET_FPR_DW(FD, *dest);                                   \
        /* PPC_SET_FPSCR( *(int *) (fp1+1));  */                     \
        PPC_SET_FPSCR( _fp );                                        \
        if(ppcInstruction::debugPrintFPSCR)                          \
            printf("FPSCR: %#x fmsub (%g * %g) - %g = %g\n",         \
                   FPSCR,double_a,double_c,double_b,double_dest);    \
    }                                                                \
}
        
DEFINST(FMSUB,                        0x38,   
        "fmsub",                      "D,A,C,B",
        FloatMULT,           F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,     PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPR(FC),
        DNA, DNA, DNA,                PPC_DFPSCR, DNA)





#define FMSUBD_IMPL                                     \
  {                                                     \
	FMSUB_IMPL					\
  	PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000)); \
  }
   
DEFINST(FMSUBD,                       0x39,
        "fmsub.",                     "D,A,C,B",
        FloatMULT,           F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,     PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPR(FC),
        PPC_DCR, DNA, DNA,            PPC_DFPSCR, PPC_DCR)




        
#define FMADD_IMPL                                                     \
{                                                                      \
    qword_t _a, _b,_c;                                                 \
    double double_a, double_b, double_c;	                       \
    double temp;                                                       \
    double double_dest;				                       \
    double fpscrin=0.0, fpscrout;                                      \
    qword_t *dest;				                       \
    word_t _fp;                                                        \
    int *fp1;				                               \
    if(PPC_INSTRUCTION_MODE) {                                         \
        _fp = FPSCR;                                                   \
        fp1 = (int *)(&fpscrin)+1;                                     \
        memcpy(fp1, &_fp, 4);                                          \
        _a = PPC_FPR_DW(FA);                                           \
        _b = PPC_FPR_DW(FB);                                           \
        _c = PPC_FPR_DW(FC);                                           \
        /*ptempf = (word_t *) (&double_a);                             \
        asm("stfd %0, 0(%1)": : "f" (_a), "g" (*ptempf) : "r0" );      \
        ptempf = (word_t *) (&double_b);                               \
        asm("stfd %0, 0(%1)": : "f" (_b), "g" (*ptempf) : "r0" );      \
        ptempf = (word_t *) (&double_c);			       \
        asm("stfd %0, 0(%1)": : "f" (_c), "g" (*ptempf) : "r0" );*/    \
        memcpy(&double_a, &_a, sizeof(_a));	                       \
        memcpy(&double_b, &_b, sizeof(_b));	                       \
        memcpy(&double_c, &_c, sizeof(_c));	                       \
        if(ppcInstruction::fpu_mode_cplusplus) {                       \
            double_dest = (double_a*double_c)+double_b;                \
        }                                                              \
        else if(ppcInstruction::fpu_mode_software) {                   \
            /*wcm: no direct softFloat implementation of this          \
                   function, FPSCR can't be expected to be 100%        \
                   and some results not fully matching HW impl. */     \
	    /*kbw: FPSCR mostly verified against real HW. */           \
            float_rounding_mode = PPCHW_GET_FPSCR_RN(FPSCR);           \
            float64 f64_a, f64_b, f64_c, f64_dest;                     \
            memcpy(&f64_a, &_a, sizeof(_a));                           \
            memcpy(&f64_b, &_b, sizeof(_b));                           \
            memcpy(&f64_c, &_c, sizeof(_c));                           \
\
	    float_exception_flags = 0; \
	    float_rounding_flags = 0; \
            f64_dest = float64_mul(f64_a, f64_c);                      \
            memcpy(&double_dest, &f64_dest, sizeof(double_dest));      \
            _fp = fpscr_set_D(_fp, FP_MULOP, double_dest,              \
                              double_a,double_c,                       \
                              float_exception_flags,                   \
                              float_rounding_flags);                   \
            temp = double_dest;                                        \
            f64_dest = float64_add(f64_dest, f64_b);                   \
            memcpy(&double_dest, &f64_dest, sizeof(double_dest));      \
	    float_rounding_flags = 0; \
            _fp = fpscr_set_D(_fp, FP_ADDOP, double_dest,              \
                              temp, double_b,                          \
                              float_exception_flags,                   \
                              float_rounding_flags);                   \
        }                                                              \
        else if(ppcInstruction::fpu_mode_asm_ppc) {                    \
            /* double_dest = double_a * double_c + double_b;*/         \
            asm ("mtfsf 0xFF,%2\n fmadd %0,%3,%4,%5\n mffs %1"         \
                 : "=f" (double_dest), "=f" (fpscrout)                 \
                 : "f" (fpscrin), "f" (double_a),                      \
                   "f" (double_c), "f" (double_b) );                   \
            fp1 = (int *) (&fpscrout);                                 \
            memcpy(&_fp, (fp1+1), 4);                                  \
        }                                                              \
        dest = (qword_t *) (&double_dest);		               \
        PPC_SET_FPR_DW(FD, *dest);                                     \
        PPC_SET_FPSCR( _fp );                                          \
        /*PPC_SET_FPSCR( *(int *) (fp1+1));*/                          \
        if(ppcInstruction::debugPrintFPSCR)                            \
            printf("FPSCR: %#x  fmadd (%g * %g) + %g = %g\n",          \
                   FPSCR,double_a,double_c,double_b,double_dest);      \
    }                                                                  \
}

DEFINST(FMADD,                        0x3A,
        "fmadd",                      "D,A,C,B",
        FloatMULT,                    F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,     PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPR(FC),
        DNA, DNA, DNA,                PPC_DFPSCR, DNA)



#define FMADDD_IMPL                                     \
  {                                                     \
	FMADD_IMPL                                      \
   PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000));  \
  }

DEFINST(FMADDD,                       0x3B,
        "fmadd.",                     "D,A,C,B",
        FloatMULT,                    F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,     PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPR(FC),
        DNA, DNA, DNA,                PPC_DFPSCR, PPC_DCR)


#define FNMADD_IMPL                                                    \
{                                                                      \
    qword_t _a, _b,_c;                                                 \
    double double_a, double_b, double_c;                               \
    double double_dest;                                                \
    double fpscrin=0.0, fpscrout;                                      \
    qword_t *dest;                                                     \
    word_t _fp;                                                        \
    int *fp1;                                                          \
    if(PPC_INSTRUCTION_MODE) {                                         \
        _fp = FPSCR; fp1 = (int *)(&fpscrin)+1; memcpy(fp1, &_fp, 4);  \
        _a = PPC_FPR_DW(FA);                                           \
        _b = PPC_FPR_DW(FB);                                           \
        _c = PPC_FPR_DW(FC);                                           \
        memcpy(&double_a, &_a, sizeof(_a));                            \
        memcpy(&double_b, &_b, sizeof(_b));		               \
        memcpy(&double_c, &_c, sizeof(_c));		               \
        if(ppcInstruction::fpu_mode_cplusplus) {                       \
            /* wcm: c++ mode ignores FPSCR. */                         \
            double_dest = -((double_a*double_c)+double_b);             \
        } else if(ppcInstruction::fpu_mode_software) {                 \
            float64 f64_a,f64_b,f64_c,f64_d,tmp;                       \
            float_rounding_mode = PPCHW_GET_FPSCR_RN(FPSCR);           \
            memcpy(&f64_a,&_a,sizeof(f64_a));                          \
            memcpy(&f64_b,&_b,sizeof(f64_b));                          \
            memcpy(&f64_c,&_c,sizeof(f64_c));                          \
            tmp = float64_mul(f64_a,f64_c);                            \
            f64_d = float64_add(tmp,f64_b);                            \
            memcpy(&double_dest,&f64_d,sizeof(double_dest));           \
            double_dest = -double_dest;                                \
            /* wcm: FPSCR not fully implemented! */                    \
            _fp = fpscr_set_D(_fp,FP_ADDOP,double_dest,                \
                              double_a, double_b,                      \
                              float_exception_flags,                   \
                              float_rounding_flags);                   \
        } else if(ppcInstruction::fpu_mode_asm_ppc) {                  \
            /* double_dest = -(double_a * double_c + double_b);   */   \
            asm ("mtfsf 0xFF,%2\n fnmadd %0,%3,%4,%5\n mffs %1"        \
                 : "=f" (double_dest), "=f" (fpscrout)                 \
                 : "f" (fpscrin), "f" (double_a),                      \
                   "f" (double_c), "f" (double_b) );                   \
            fp1 = (int *) (&fpscrout);                                 \
            memcpy(&_fp, (fp1+1), 4);                                  \
        }                                                              \
        dest = (qword_t *) (&double_dest);                             \
        PPC_SET_FPR_DW(FD, *dest);                                     \
        /*PPC_SET_FPSCR( *(int *) (fp1+1));*/                          \
        PPC_SET_FPSCR(_fp);                                            \
        if(ppcInstruction::debugPrintFPSCR)                            \
            printf("FPSCR: %#x fnmadd -[(%g * %g)+%g] = %g\n",         \
                   FPSCR,double_a,double_c,double_b,double_dest);      \
    }                                                                  \
}



DEFINST(FNMADD,                       0x3E,
        "fnmadd",                     "D,A,C,B",
        FloatMULT,           F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,     PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPR(FC),
        DNA, DNA, DNA,                PPC_DFPSCR, DNA)


#define FNMADDD_IMPL                                        \
  {                                                         \
	FNMADD_IMPL                                         \
	PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000)); \
  }

DEFINST(FNMADDD,                      0x3F,   
        "fnmadd.",                    "D,A,C,B",
        FloatMULT,                    F_FCOMP,
        PPC_DFPR(FD), PPC_DFPSCR,     PPC_DFPR(FA), PPC_DFPR(FB), PPC_DFPR(FC),
        PPC_DCR, DNA, DNA,            PPC_DFPSCR, PPC_DCR)


#define MTFSFI_IMPL						\
{                                                               \
    word_t _m,_f;						\
    _f = FPSCR;							\
    if(CRFD!=0){						\
        _m = 15 << ((7-CRFD)*4);				\
        _f = (_f & (~(_m)))| (MTFSFI_IMM <<((7-CRFD)*4) );	\
    }								\
    else{							\
        _m = 0x6 <<28;						\
        _f = (_f & (~(_m)))| ( (MTFSFI_IMM & 0x6) <<28);	\
    }								\
    PPC_SET_FPSCR(_f);						\
}

DEFINST(MTFSFI,                 0x10C,
        "mtfsfi",               "D",
        IntALU,                 F_ICOMP|F_IMM,
        PPC_DFPSCR,DNA,         PPC_DFPSCR,DNA,DNA,
        DNA, DNA, DNA,        	DNA, DNA)


#define MTFSFID_IMPL                                                    \
   {                                                                    \
        word_t _m,_f;                                                   \
        _f = FPSCR;                                                     \
        if(CRFD!=0){                                                    \
                _m = ((0xf) << ((7-CRFD)*4));                           \
                _f = (_f & (~(_m)))| (MTFSFI_IMM <<((7-CRFD)*4) );      \
        }                                                               \
        else{                                                           \
                _m = 0x6 <<28;						\
                _f = (_f & (~(_m)))| ( (MTFSFI_IMM & 0x6) <<28 );	\
        }                                                               \
	PPC_SET_FPSCR(_f);						\
        PPC_SET_CR( (CR & ~( 0x0f000000)) | (FPSCR & 0x0f000000) );     \
   }


DEFINST(MTFSFID,                0x10D,
        "mtfsfi.",              "D",
        IntALU,                 F_ICOMP|F_IMM,
        PPC_DFPSCR,PPC_DCR,     PPC_DFPSCR,PPC_DCR,DNA,
        DNA, DNA, DNA,        	DNA, DNA)


#define MTFSF_IMPL                                                    	\
   {									\
        word_t _m,_f, _fm, _rb,_c;					\
	int _i;								\
	_rb = PPC_FPR_W(FB);						\
	_f=FPSCR;							\
	_fm = MTFSFI_FM;						\
	if(_fm & 0x80)							\
	{								\
	 _m = 0x60000000;						\
	}								\
	else{								\
	 _m=0x0;							\
	}								\
	_c=0x1;								\
	for(_i=0;_i<7;_i++){						\
		if(_c & _fm)						\
		{							\
			_m= _m | (0xf<<(_i*4));				\
		}							\
		_c=_c<<1;						\
	}								\
	_f = _rb & _m ;						        \
	PPC_SET_FPSCR(_f);						\
   }


DEFINST(MTFSF,                 0x58E,
        "mtfsf",               "M,B",
        IntALU,                F_ICOMP,
        PPC_DFPSCR,DNA,        PPC_DFPSCR,PPC_DFPR(FB),DNA,
        DNA, DNA, DNA,         DNA, DNA)



#define MTFSFD_IMPL					    \
{                                                           \
    word_t _m,_f, _fm, _rb,_c;                              \
    int _i;                                                 \
    _rb = PPC_FPR_W(FB);                                    \
    _f=FPSCR;                                               \
    _fm = MTFSFI_FM;                                        \
    if(_fm & 0x80)                                          \
    {                                                       \
        _m = 0x60000000;                                    \
    }                                                       \
    else {                                                  \
        _m=0x0;                                             \
    }                                                       \
    _c=0x1;                                                 \
    for(_i=0;_i<7;_i++){                                    \
        if(_c & _fm)                                        \
        {                                                   \
            _m= _m | (0xf<<(_i*4));                         \
        }                                                   \
        _c=_c<<1;                                           \
    }                                                       \
    _f = _rb & _m;					    \
    PPC_SET_FPSCR(_f);                                      \
    PPC_SET_CR( (_f & 0x0f000000) | (CR & 0xf0ffffff));	    \
}


DEFINST(MTFSFD,                0x58F,
        "mtfsf.",              "M,B",
        IntALU,                F_ICOMP,
        PPC_DFPSCR,PPC_DCR,    PPC_DFPSCR,PPC_DFPR(FB),DNA,
        DNA, DNA, DNA,         DNA, DNA)

#define FABS_IMPL					\
   {							\
/*	PPC_SET_FPR_D(FD, fabs(PPC_FPR(FB))); */	\
   qword_t _a;                                          \
   qword_t *dest;                                       \
   double double_a, double_dest;                        \
   word_t *ptempf;                                      \
   _a = PPC_FPR_DW(FB);                                 \
   ptempf = (word_t *) (&double_a);                     \
   memcpy(&double_a, &_a, sizeof(_a));			\
   double_dest = fabs(double_a) ;                       \
   dest = (qword_t *) (&double_dest);                   \
   PPC_SET_FPR_DW(FD, *dest);                           \
}

DEFINST(FABS,			0x210,
	"fabs",			"D,B",
	FloatADD,		F_FCOMP,	
	PPC_DFPR(FD), DNA,      PPC_DFPR(FB), DNA, DNA,
        DNA, DNA, DNA,          DNA, DNA)



#define FABSD_IMPL                                         \
{                                                          \
   /* PPC_SET_FPR_D(FD, fabs(PPC_FPR(FB)));  */            \
   qword_t _a;                                             \
   qword_t *dest;                                          \
   double double_a, double_dest;                           \
   word_t *ptempf;                                         \
   _a = PPC_FPR_DW(FB);                                    \
   ptempf = (word_t *) (&double_a);                        \
   memcpy(&double_a, &_a, sizeof(_a));			   \
   double_dest = fabs(double_a) ;                          \
   dest = (qword_t *) (&double_dest);                      \
   PPC_SET_FPR_DW(FD, *dest);                              \
   PPC_SET_CR( (CR & 0xf0ffffff) | (((FPSCR)>>4) & 0x0f000000)  );  \
}

DEFINST(FABSD,                  0x211,
        "fabs.",                "D,B",
        FloatADD,               F_FCOMP,
        PPC_DFPR(FD), PPC_DCR,  PPC_DFPR(FB), PPC_DFPSCR, PPC_DCR,
        DNA, DNA, DNA,          DNA, DNA)

 
#define FNABS_IMPL                                               \
{                                                                \
    /* PPC_SET_FPR_D( FD, ( -(fabs(PPC_FPR(FB))) ) );*/          \
    qword_t _a;                                                  \
    qword_t *dest;                                               \
    double double_a, double_dest;                                \
    word_t *ptempf;                                              \
    _a = PPC_FPR_DW(FB);                                         \
    ptempf = (word_t *) (&double_a);                             \
    memcpy(&double_a, &_a, sizeof(_a));				 \
    double_dest = -fabs(double_a);                               \
    dest = (qword_t *) (&double_dest);                           \
    PPC_SET_FPR_DW(FD, *dest);                                   \
}

DEFINST(FNABS,                  0x110,
        "fnabs",                "D,B",
        FloatADD,               F_FCOMP,
        PPC_DFPR(FD), DNA,      PPC_DFPR(FB), DNA, DNA,
        DNA, DNA, DNA,          DNA, DNA)


#define FNABSD_IMPL                                            \
{                                                              \
    /* PPC_SET_FPR_D( FD, ( -(fabs(PPC_FPR(FD))) ) );*/        \
    qword_t _a;                                                \
    qword_t *dest;                                             \
    double double_a, double_dest;                              \
    word_t *ptempf;                                            \
    _a = PPC_FPR_DW(FB);                                       \
    ptempf = (word_t *) (&double_a);                           \
    memcpy(&double_a, &_a, sizeof(_a));	                       \
    double_dest = -fabs(double_a) ;                            \
    dest = (qword_t *) (&double_dest);                         \
    PPC_SET_FPR_DW(FD, *dest);                                 \
    PPC_SET_CR( (CR & 0xf0ffffff) | (((FPSCR)>>4) & 0x0f000000)  );  \
}

DEFINST(FNABSD,                 0x111,
        "fnabs.",               "D,B",
        FloatADD,               F_FCOMP,
        PPC_DFPR(FD), DNA,      PPC_DFPR(FB), PPC_DFPSCR, PPC_DCR,
        DNA, DNA, DNA,          DNA, DNA)




#define MFFS_IMPL                                               \
{                                                            	\
    qword_t _f;							\
    _f= (qword_t)FPSCR;						\
    PPC_SET_FPR_DW(FD, _f);					\
}


DEFINST(MFFS,                   0x48E,
        "mffs",                 "D",
        IntALU,                 F_ICOMP,
        PPC_DFPR(FD),PPC_DCR,   PPC_DFPSCR,PPC_DCR,DNA,
        DNA, DNA, DNA,        	DNA, DNA)



#define MFFSD_IMPL                                                    \
   {                                                                  \
	word_t _c, _fp;                                               \
        qword_t _f;                                                   \
        _f= (qword_t)FPSCR;                                           \
        PPC_SET_FPR_DW(FD, _f);                                       \
	_c = CR;						      \
	_fp = FPSCR;						      \
	PPC_SET_CR( (CR & ~( 0x0f000000)) | (FPSCR & 0x0f000000) );   \
   }
        

DEFINST(MFFSD,                  0x48F, 
        "mffs.",                "D",
        IntALU,                 F_ICOMP,
        PPC_DFPR(FD),PPC_DCR,   PPC_DFPSCR,PPC_DCR,DNA,
        DNA, DNA, DNA,        	DNA, DNA)

#ifdef __ppc__
#define FSQRT_IMPL_PPC_ASM(double_dest,fpscrout,double_a) do { \
    register double fpscrin = 0.0; \
    __asm__ __volatile__ ("mtfsf 0xFF,%2\nfsqrt %0,%3\nmffs %1"          \
             : "=f" (double_dest),                          \
               "=f" (fpscrout)                              \
             : "f" (fpscrin),    /*bug here??? */           \
               "f" (double_a) );			    \
} while (0)
#else
#define FSQRT_IMPL_PPC_ASM(double_dest,fpscrout,double_a) do { } while (0)
#endif

#define FSQRT_IMPL                                 \
{					            \
  qword_t _a;                                        \
  qword_t *dest;                                      \
  double double_a, double_dest;                        \
  word_t *ptempf;                                       \
  int *fp1;                                               \
  word_t _fp;				                   \
  if(PPC_INSTRUCTION_MODE) {                                \
    _a = PPC_FPR_DW(FB);                                    \
    ptempf = (word_t *) (&double_a);                        \
    memcpy(&double_a, &_a, sizeof(_a));		            \
    if(ppcInstruction::fpu_mode_cplusplus) {                \
        double_dest = sqrt(double_a);                       \
    }                                                       \
    else if(ppcInstruction::fpu_mode_software) {            \
        float64 f64_a,f64_dest;                             \
        float_rounding_mode = PPCHW_GET_FPSCR_RN(FPSCR);    \
        memcpy(&f64_a, &_a, sizeof(float64));               \
	float_exception_flags = 0;                          \
	float_rounding_flags = 0;                           \
        f64_dest = float64_sqrt(f64_a);                     \
        memcpy(&double_dest,&f64_dest,sizeof(double));      \
	_fp = fpscr_set_D(FPSCR, FP_SQRTOP,                 \
		double_dest, double_a, 0.0,                 \
		float_exception_flags,                      \
		float_rounding_flags);                      \
    }                                                       \
    else if(ppcInstruction::fpu_mode_asm_ppc) {             \
	double fpscrout;                       \
	FSQRT_IMPL_PPC_ASM(double_dest,fpscrout,double_a); \
        fp1 = (int *) (&fpscrout);                          \
        memcpy(&_fp, (fp1+1), 4);                           \
    }                                                       \
    dest = (qword_t *) (&double_dest);                      \
    PPC_SET_FPR_DW(FD, *dest);                              \
    /*PPC_SET_FPSCR( *(int *) (fp1+1));*/                   \
    printf("sqrt(%g) = %g\n", double_a, double_dest);       \
    PPC_SET_FPSCR( _fp );                                   \
  }                                                         \
}

DEFINST(FSQRT,			        0x2C,
	"fsqrt",			"D,B",
	FloatSQRT,			F_FCOMP,
	PPC_DFPR(FD), PPC_DFPSCR,	PPC_DFPR(FB), PPC_DFPSCR,DNA,
	DNA, DNA, DNA,			DNA,DNA)


#define FSQRTD_IMPL					                  \
{							                  \
    FSQRT_IMPL;			                                          \
    PPC_SET_CR((CR & 0xf0ffffff) |(FPSCR &0x0f000000));                   \
}

DEFINST(FSQRTD,			        0x2D,
	"fsqrt.",			"D,B",
	FloatSQRT,			F_FCOMP,
	PPC_DFPR(FD), PPC_DFPSCR,	PPC_DFPR(FB), PPC_DFPSCR,DNA,
	PPC_DCR, DNA, DNA,		DNA,DNA)



#define FRSQRTE_IMPL					                  \
   {							                  \
	qword_t _b,_fc;				                          \
	dfloat_t _fb;					                  \
	qword_t _a;		        		                  \
	word_t _fp;		        		                  \
	_b =  PPC_FPR_DW(FB);				                  \
	_fb = PPC_FPR(FB);				                  \
	if(_b==NEGINFSP){				                  \
		 PPC_SET_FPR_DW(FD,_b|0x0008000000000000ll);     \
		 PPC_SET_FPSCR_FPRF(0x11);		                  \
		 PPC_SET_FPSCR_FX;			                  \
		 PPC_SET_FPSCR_VXSQRT;			                  \
	}						                  \
	else if(_b==POSINFSP){				                  \
		 PPC_SET_FPR_DW(FD,POSZEROSP);		                  \
		 PPC_SET_FPSCR_FPRF(0x02);		                  \
	}						                  \
	else if(_b==NEGZEROSP){				                  \
		 PPC_SET_FPR_DW(FD,NEGINFSP);		                  \
		 PPC_SET_FPSCR_ZX;			                  \
		 PPC_SET_FPSCR_FX;			                  \
		 PPC_SET_FPSCR_FPRF(0x09);		                  \
	}						                  \
	else if(_b==POSZEROSP){				                  \
	 	PPC_SET_FPR_DW(FD,POSINFSP);		                  \
		PPC_SET_FPSCR_ZX;			                  \
		PPC_SET_FPSCR_FX;			                  \
		PPC_SET_FPSCR_FPRF(0x3);		                  \
	}						                  \
	else if(isspSNan(_b)){				                  \
		PPC_SET_FPR_DW(FD,_b|0x0008000000000000ll);	\
		PPC_SET_FPSCR_VXSNAN;			                  \
		PPC_SET_FPSCR_FX;			                  \
		PPC_SET_FPSCR_FPRF(0x11);		                  \
	}						                  \
	else if(isspQNan(_b)){				                  \
		PPC_SET_FPR_DW(FD,_b);      		                  \
                PPC_SET_FPSCR_FPRF(0x11);                                 \
	}						                  \
        else if(_fp<0){				                          \
		 PPC_SET_FPR_DW(FD,_b|0x7ff8000000000000ll);     \
		 PPC_SET_FPSCR_FPRF(0x11);		                  \
		 PPC_SET_FPSCR_FX;			                  \
		 PPC_SET_FPSCR_VXSQRT;			                  \
	}						                  \
	else {						                  \
		_fb=1.0/sqrt(_fb);			                  \
		_fp=FPSCR;				                  \
                PPC_SET_FPSCR(_fp);                                       \
                _fc = *(qword_t *)&_fb;                                   \
                PPC_SET_FPR_DW(FD,_fc);                                   \
		_a = *(qword_t*)(& _fb);		                  \
		if(_fb<0.0){				                  \
			if(_a&0x7f80000000000000ll) PPC_SET_FPSCR_FPRF(0x8);\
			else PPC_SET_FPSCR_FPRF(0x18);	                  \
		}					                  \
		else{					                  \
			if(_a&0x7f80000000000000ll) PPC_SET_FPSCR_FPRF(0x4);\
                        else PPC_SET_FPSCR_FPRF(0x14);	                  \
		}					                  \
	}						                  \
   }

DEFINST(FRSQRTE,			0x34,
	"frsqrte",			"D,B",
	FloatSQRT,			F_FCOMP,
	PPC_DFPR(FD), PPC_DFPSCR,	PPC_DFPR(FB), PPC_DFPSCR,DNA,
	DNA, DNA, DNA,			DNA,DNA)


#define FRSQRTED_IMPL					                  \
{							                  \
    qword_t  _a, _b, _fc;				                  \
    dfloat_t _fb;					                  \
    word_t   _fp;		        		                  \
    _b  = PPC_FPR_DW(FB);			                          \
    _fb = PPC_FPR(FB);				                          \
    if(_b==NEGINFSP){				                          \
	PPC_SET_FPR_DW(FD,_b|0x0008000000000000ll);                       \
	PPC_SET_FPSCR_FPRF(0x11);		                          \
	PPC_SET_FPSCR_FX;			                          \
	PPC_SET_FPSCR_VXSQRT;			                          \
    }						                          \
    else if(_b==POSINFSP){				                  \
	PPC_SET_FPR_DW(FD,POSZEROSP);		                          \
	PPC_SET_FPSCR_FPRF(0x02);		                          \
    }						                          \
    else if(_b==NEGZEROSP){				                  \
	PPC_SET_FPR_DW(FD,NEGINFSP);		                          \
	PPC_SET_FPSCR_ZX;			                          \
	PPC_SET_FPSCR_FX;			                          \
	PPC_SET_FPSCR_FPRF(0x09);		                          \
    }						                          \
    else if(_b==POSZEROSP){				                  \
	PPC_SET_FPR_DW(FD,POSINFSP);		                          \
	PPC_SET_FPSCR_ZX;			                          \
	PPC_SET_FPSCR_FX;			                          \
	PPC_SET_FPSCR_FPRF(0x3);		                          \
    }						                          \
    else if(isspSNan(_b)){				                  \
	PPC_SET_FPR_DW(FD,_b|0x0008000000000000ll);	                  \
	PPC_SET_FPSCR_VXSNAN;			                          \
	PPC_SET_FPSCR_FX;			                          \
	PPC_SET_FPSCR_FPRF(0x11);		                          \
    }						                          \
    else if(isspQNan(_b)){				                  \
	PPC_SET_FPR_DW(FD,_b);      		                          \
        PPC_SET_FPSCR_FPRF(0x11);                                         \
    }						                          \
    else if(_fp<0) {				                          \
	PPC_SET_FPR_DW(FD,_b|0x7ff8000000000000ll);                       \
	PPC_SET_FPSCR_FPRF(0x11);		                          \
	PPC_SET_FPSCR_FX;			                          \
	PPC_SET_FPSCR_VXSQRT;			                          \
    }						                          \
    else {						                  \
	_fb=1.0/sqrt(_fb);			                          \
        _fp=(word_t)FPSCR;			                          \
        PPC_SET_FPSCR(_fb);                                               \
        _fc = *(qword_t *)&_fb;                                           \
        PPC_SET_FPR_DW(FD,_fc);                                           \
	_a = *(qword_t*)(& _fb);		                          \
	if(_fb<0.0){				                          \
	    if(_a&0x7f80000000000000ll) PPC_SET_FPSCR_FPRF(0x8);          \
	    else PPC_SET_FPSCR_FPRF(0x18);	                          \
	}					                          \
	else{					                          \
	    if(_a&0x7f80000000000000ll) PPC_SET_FPSCR_FPRF(0x4);          \
            else PPC_SET_FPSCR_FPRF(0x14);	                          \
	}					                          \
    }					  	                          \
    PPC_SET_CR((CR & 0xf0ffffffll) |(FPSCR &0x0f000000ll));               \
}

DEFINST(FRSQRTED,			0x35,
	"frsqrte.",			"D,B",
	FloatSQRT,			F_FCOMP,
	PPC_DFPR(FD), PPC_DFPSCR,	PPC_DFPR(FB), PPC_DFPSCR,DNA,
	PPC_DCR, DNA, DNA,		DNA,DNA)

/* clean up all definitions... */
#undef NOP_IMPL
/*Clean up Integer arithmetic defs*/

#undef NEWINST_IMPL

#undef ADD_IMPL
#undef ADDD_IMPL
#undef ADDO_IMPL
#undef ADDOD_IMPL
#undef ADDC_IMPL
#undef ADDCD_IMPL
#undef ADDCO_IMPL
#undef ADDCOD_IMPL
#undef ADDE_IMPL
#undef ADDED_IMPL
#undef ADDEO_IMPL
#undef ADDEOD_IMPL
#undef ADDI_IMPL
#undef ADDIC_IMPL
#undef ADDICD_IMPL
#undef ADDIS_IMPL
#undef ADDME_IMPL
#undef ADDMED_IMPL
#undef ADDMEO_IMPL
#undef ADDMEOD_IMPL
#undef ADDZE_IMPL
#undef ADDZED_IMPL
#undef ADDZEO_IMPL
#undef ADDZEOD_IMPL
#undef DIVW_IMPL
#undef DIVWD_IMPL
#undef DIVWO_IMPL
#undef DIVWOD_IMPL
#undef DIVWU_IMPL
#undef DIVWUD_IMPL
#undef DIVWUO_IMPL
#undef DIVWUOD_IMPL
#undef MULHW_IMPL
#undef MULHWD_IMPL
#undef MULHWU_IMPL
#undef MULHWUD_IMPL
#undef MULLI_IMPL
#undef MULLW_IMPL
#undef MULLWD_IMPL
#undef MULLWO_IMPL
#undef MULLWOD_IMPL
#undef NEG_IMPL
#undef NEGD_IMPL
#undef NEGO_IMPL
#undef NEGOD_IMPL
#undef SUBF_IMPL
#undef SUBFD_IMPL
#undef SUBFO_IMPL
#undef SUBFOD_IMPL
#undef SUBFC_IMPL
#undef SUBFCD_IMPL
#undef SUBFCO_IMPL
#undef SUBFCOD_IMPL
#undef SUBFIC_IMPL
#undef SUBFE_IMPL
#undef SUBFED_IMPL
#undef SUBFEO_IMPL
#undef SUBFEOD_IMPL
#undef SUBFME_IMPL
#undef SUBFMED_IMPL
#undef SUBFMEO_IMPL
#undef SUBFMEOD_IMPL
#undef SUBFZE_IMPL
#undef SUBFZED_IMPL
#undef SUBFZEO_IMPL
#undef SUBFZEOD_IMPL


/*Integer compare instructions*/
#undef CMP_IMPL
#undef CMPI_IMPL
#undef CMPI_IMPL
#undef CMPLI_IMPL


/*Integer logical instructions*/
#undef AND_IMPL
#undef ANDD_IMPL
#undef ANCD_IMPL
#undef ANDCD_IMPL
#undef ANDID_IMPL
#undef ANDISD_IMPL
#undef CNTLZW_IMPL
#undef CNTLZWD_IMPL
#undef EQV_IMPL
#undef EQVD_IMPL
#undef EXTSB_IMPL
#undef EXTSBD_IMPL
#undef EXTSH_IMPL
#undef EXTSHD_IMPL
#undef NAND_IMPL
#undef NANDD_IMPL
#undef NOR_IMPL
#undef NORD_IMPL
#undef OR_IMPL
#undef ORD_IMPL
#undef ORC_IMPL
#undef ORCD_IMPL
#undef ORI_IMPL
#undef ORIS_IMPL
#undef XOR_IMPL
#undef XORD_IMPL
#undef XORI_IMPL
#undef XORIS_IMPL


/*Integer rotate instructions*/

#undef RLWIMI_IMPL
#undef RLWIMID_IMPL
#undef RLWINM_IMPL
#undef RLWINMD_IMPL
#undef RLWNM_IMPL
#undef RLWNMD_IMPL

/*Integer shift instructions*/
#undef SLW_IMPL
#undef SLWD_IMPL
#undef SRAW_IMPL
#undef SRAWD_IMPL
#undef SRAWI_IMPL
#undef SRAWID_IMPL
#undef SRW_IMPL
#undef SRWD_IMPL

/*Floating point arithmetic instructions*/
#undef FADD_IMPL
#undef FADDD_IMPL
#undef FADDS_IMPL
#undef FADDSD_IMPL
#undef FDIV_IMPL
#undef FDIVD_IMPL
#undef FDIVS_IMPL
#undef FDIVSD_IMPL
#undef FMUL_IMPL
#undef FMULD_IMPL
#undef FMULS_IMPL
#undef FMULSD_IMPL
#undef FRES_IMPL
#undef FRESD_IMPL
#undef FRSQRTE_IMPL
#undef FRSQRTED_IMPL
#undef FSUB_IMPL
#undef FSUBD_IMPL
#undef FSUBS_IMPL
#undef FSUBSD_IMPL
#undef FSEL_IMPL
#undef FSELD_IMPL
#undef FMADD_IMPL
#undef FMADDD_IMPL
#undef FMADDS_IMPL
#undef FMADDSD_IMPL
#undef FMSUB_IMPL
#undef FMSUBD_IMPL
#undef FMSUBS_IMPL
#undef FMSUBSD_IMPL
#undef FNMADD_IMPL
#undef FNMADDD_IMPL
#undef FNMADDS_IMPL
#undef FNMADDSD_IMPL
#undef FNMSUB_IMPL
#undef FNMSUBD_IMPL
#undef FNMSUBS_IMPL
#undef FNMSUBSD_IMPL

/* Floating point rounding and conversion instructions*/
#undef FCTIW_IMPL
#undef FCTIWD_IMPL
#undef FCTIWZ_IMPL
#undef FCTIWZD_IMPL
#undef FCTID_IMPL
#undef FRSP_IMPL
#undef FRSPD_IMPL

/*Floating point compare instructions*/
#undef FCMPO_IMPL
#undef FCMPU_IMPL

/*Integer Load instructions*/
#undef LBZ_IMPL
#undef LBZU_IMPL
#undef LBZUX_IMPL
#undef LBZX_IMPL
#undef LHA_IMPL
#undef LHAU_IMPL
#undef LHAX_IMPL
#undef LHAUX_IMPL
#undef LHZ_IMPL
#undef LHZU_IMPL
#undef LHZX_IMPL
#undef LHZUX_IMPL
#undef LWZ_IMPL
#undef LWZU_IMPL
#undef LWZX_IMPL
#undef LWZUX_IMPL

/*Integer store instructions*/
#undef STB_IMPL
#undef STBU_IMPL
#undef STBUX_IMPL
#undef STBX_IMPL
#undef STH_IMPL
#undef STHU_IMPL
#undef STHUX_IMPL
#undef STHX_IMPL
#undef STW_IMPL
#undef STWU_IMPL
#undef STWUX_IMPL
#undef STWX_IMPL

/*Integer load and store with byte reverse instructions*/
#undef LHBRX_IMPL
#undef LWBRX_IMPL
#undef STHBRX_IMPL
#undef STWBRX_IMPL

/*Integer load and store multiple instructions*/
#undef LMW_IMPL
#undef STMW_IMPL

/*Integer load and store string instructions*/
#undef LSWI_IMPL
#undef LSWX_IMPL
#undef STSWI_IMPL
#undef STSWX_IMPL

/*Memory synchronization instructions*/
#undef EIEIO_IMPL
#undef ISYNC_IMPL
#undef LWARX_IMPL
#undef STWCXD_IMPL
#undef SYNC_IMPL

/*Floating point load instructions*/

#undef LFD_IMPL
#undef LFDU_IMPL
#undef LFDX_IMPL
#undef LFDUX_IMPL
#undef LFS_IMPL
#undef LFSU_IMPL
#undef LFSX_IMPL
#undef LFSUX_IMPL


/*Floating point store instructions*/
#undef STFD_IMPL
#undef STFDU_IMPL
#undef STFDX_IMPL
#undef STFDUX_IMPL
#undef STFIWX_IMPL
#undef STFS_IMPL
#undef STFSU_IMPL
#undef STFSX_IMPL
#undef STFSUX_IMPL

/*Floating point move instructions*/
#undef FABS_IMPL
#undef FABSD_IMPL
#undef FMR_IMPL
#undef FMRD_IMPL
#undef FNABS_IMPL
#undef FNABSD_IMPL
#undef FNEG_IMPL
#undef FNEGD_IMPL



/*Floating point status and control register instructions*/
#undef MCRF_IMPL
#undef MCRFS_IMPL
#undef MFFS_IMPL
#undef MFFSD_IMPL
#undef MTFSB0_IMPL
#undef MTFSB0D_IMPL
#undef MTFSB1_IMPL
#undef MTFSB1D_IMPL
#undef MTFSF_IMPL
#undef MTFSF_IMPL
#undef MTFSFI_IMPL
#undef MTFSFID_IMPL



/*Clean up branch defs*/

#undef B_IMPL
#undef BA_IMPL
#undef BL_IMPL
#undef BLA_IMPL
#undef BC_IMPL
#undef BCA_IMPL
#undef BCL_IMPL
#undef BCLA_IMPL
#undef BCCTR_IMPL
#undef BCCTRL_IMPL
#undef BCLR_IMPL
#undef BCLRL_IMPL


/*Condition register logical instructions*/
#undef CRAND_IMPL
#undef CRANDC_IMPL
#undef CREQV_IMPL
#undef CRNAND_IMPL
#undef CRNOR_IMPL
#undef CROR_IMPL
#undef CRORC_IMPL
#undef CRXOR_IMPL
#undef MCRF_IMPL


/*System Linkage instructions*/

#undef SC_IMPL

/*Trap instructions*/

#undef TW_IMPL
#undef TWI_IMPL

/*Processor control instructions*/

#undef MCRXR_IMPL
#undef MFCR_IMPL
#undef MFSPR_IMPL
#undef MFTB_IMPL
#undef MTCRF_IMPL
#undef MTSPR_IMPL

/*Cache management instructions*/
#undef DCBI_IMPL
#undef DCBF_IMPL
#undef DCBST_IMPL
#undef DCBT_IMPL
#undef DCBTST_IMPL
#undef DCBZ_IMPL
#undef ICBI_IMPL



/*External control instructions*/
#undef ECIWX_IMPL
#undef ECOWX_IMPL


/*Others */

#undef DEFINST

/*These havn't been used in this file*/
#undef DEFLINK
#undef CONNECT
